use crate::SqliteError;
use rusqlite::{Connection, params};
use wow_dbc::{DbcTable, LocalizedString, ExtendedLocalizedString};
use wow_dbc::wrath_tables::*;

pub(crate) fn write_to_sqlite(conn: &mut Connection, file_name: &str, file_contents: &mut &[u8]) -> Result<(), SqliteError> {
    let tx = conn.transaction()?;

    match file_name {
        "Achievement.dbc" => {
            let data = achievement::Achievement::read(file_contents)?;
            let (table, insert, _select) = Achievement();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.faction.id,
                row.instance_id.id,
                row.supercedes.id,
                &row.title_lang.en_gb,
                &row.title_lang.ko_kr,
                &row.title_lang.fr_fr,
                &row.title_lang.de_de,
                &row.title_lang.en_cn,
                &row.title_lang.en_tw,
                &row.title_lang.es_es,
                &row.title_lang.es_mx,
                &row.title_lang.ru_ru,
                &row.title_lang.ja_jp,
                &row.title_lang.pt_pt,
                &row.title_lang.it_it,
                &row.title_lang.unknown_12,
                &row.title_lang.unknown_13,
                &row.title_lang.unknown_14,
                &row.title_lang.unknown_15,
                &row.title_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                row.category.id,
                row.points,
                row.ui_order,
                row.flags,
                row.icon_id.id,
                &row.reward_lang.en_gb,
                &row.reward_lang.ko_kr,
                &row.reward_lang.fr_fr,
                &row.reward_lang.de_de,
                &row.reward_lang.en_cn,
                &row.reward_lang.en_tw,
                &row.reward_lang.es_es,
                &row.reward_lang.es_mx,
                &row.reward_lang.ru_ru,
                &row.reward_lang.ja_jp,
                &row.reward_lang.pt_pt,
                &row.reward_lang.it_it,
                &row.reward_lang.unknown_12,
                &row.reward_lang.unknown_13,
                &row.reward_lang.unknown_14,
                &row.reward_lang.unknown_15,
                &row.reward_lang.flags,
                row.minimum_criteria,
                row.shares_criteria.id,
                ])?;
            }
        }
        "Achievement_Category.dbc" => {
            let data = achievement_category::Achievement_Category::read(file_contents)?;
            let (table, insert, _select) = Achievement_Category();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.parent.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.ui_order,
                ])?;
            }
        }
        "Achievement_Criteria.dbc" => {
            let data = achievement_criteria::Achievement_Criteria::read(file_contents)?;
            let (table, insert, _select) = Achievement_Criteria();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.achievement_id.id,
                row.ty,
                row.asset_id,
                row.quantity,
                row.start_event,
                row.start_asset,
                row.fail_event,
                row.fail_asset,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                row.flags,
                row.timer_start_event,
                row.timer_asset_id,
                row.timer_time,
                row.ui_order,
                ])?;
            }
        }
        "AnimationData.dbc" => {
            let data = animation_data::AnimationData::read(file_contents)?;
            let (table, insert, _select) = AnimationData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.weaponflags,
                row.bodyflags,
                row.flags,
                row.fallback.id,
                row.behavior_id.id,
                row.behavior_tier,
                ])?;
            }
        }
        "AreaGroup.dbc" => {
            let data = area_group::AreaGroup::read(file_contents)?;
            let (table, insert, _select) = AreaGroup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.area_id[0],
                row.area_id[1],
                row.area_id[2],
                row.area_id[3],
                row.area_id[4],
                row.area_id[5],
                row.next_area_id.id,
                ])?;
            }
        }
        "AreaPOI.dbc" => {
            let data = area_poi::AreaPOI::read(file_contents)?;
            let (table, insert, _select) = AreaPOI();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.importance,
                row.icon[0],
                row.icon[1],
                row.icon[2],
                row.icon[3],
                row.icon[4],
                row.icon[5],
                row.icon[6],
                row.icon[7],
                row.icon[8],
                row.faction_id.id,
                row.pos[0],
                row.pos[1],
                row.pos[2],
                row.continent_id.id,
                row.flags,
                row.area_id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                row.world_state_id,
                row.world_map_link,
                ])?;
            }
        }
        "AreaTable.dbc" => {
            let data = area_table::AreaTable::read(file_contents)?;
            let (table, insert, _select) = AreaTable();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.continent_id.id,
                row.parent_area_id.id,
                row.area_bit,
                row.flags,
                row.sound_provider_pref.id,
                row.sound_provider_pref_underwater.id,
                row.ambience_id.id,
                row.zone_music.id,
                row.intro_sound.id,
                row.exploration_level,
                &row.area_name_lang.en_gb,
                &row.area_name_lang.ko_kr,
                &row.area_name_lang.fr_fr,
                &row.area_name_lang.de_de,
                &row.area_name_lang.en_cn,
                &row.area_name_lang.en_tw,
                &row.area_name_lang.es_es,
                &row.area_name_lang.es_mx,
                &row.area_name_lang.ru_ru,
                &row.area_name_lang.ja_jp,
                &row.area_name_lang.pt_pt,
                &row.area_name_lang.it_it,
                &row.area_name_lang.unknown_12,
                &row.area_name_lang.unknown_13,
                &row.area_name_lang.unknown_14,
                &row.area_name_lang.unknown_15,
                &row.area_name_lang.flags,
                row.faction_group_mask,
                row.liquid_type_id[0],
                row.liquid_type_id[1],
                row.liquid_type_id[2],
                row.liquid_type_id[3],
                row.min_elevation,
                row.ambient_multiplier,
                row.light_id.id,
                ])?;
            }
        }
        "AreaTrigger.dbc" => {
            let data = area_trigger::AreaTrigger::read(file_contents)?;
            let (table, insert, _select) = AreaTrigger();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.continent_id.id,
                row.pos[0],
                row.pos[1],
                row.pos[2],
                row.radius,
                row.box_length,
                row.box_width,
                row.box_height,
                row.box_yaw,
                ])?;
            }
        }
        "AttackAnimKits.dbc" => {
            let data = attack_anim_kits::AttackAnimKits::read(file_contents)?;
            let (table, insert, _select) = AttackAnimKits();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.item_subclass_id,
                row.anim_type_id,
                row.anim_frequency,
                row.which_hand,
                ])?;
            }
        }
        "AttackAnimTypes.dbc" => {
            let data = attack_anim_types::AttackAnimTypes::read(file_contents)?;
            let (table, insert, _select) = AttackAnimTypes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.anim_id,
                &row.anim_name,
                ])?;
            }
        }
        "AuctionHouse.dbc" => {
            let data = auction_house::AuctionHouse::read(file_contents)?;
            let (table, insert, _select) = AuctionHouse();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.faction_id.id,
                row.deposit_rate,
                row.consignment_rate,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "BankBagSlotPrices.dbc" => {
            let data = bank_bag_slot_prices::BankBagSlotPrices::read(file_contents)?;
            let (table, insert, _select) = BankBagSlotPrices();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.cost,
                ])?;
            }
        }
        "BannedAddOns.dbc" => {
            let data = banned_add_ons::BannedAddOns::read(file_contents)?;
            let (table, insert, _select) = BannedAddOns();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.name_m_d5[0],
                row.name_m_d5[1],
                row.name_m_d5[2],
                row.name_m_d5[3],
                row.version_m_d5[0],
                row.version_m_d5[1],
                row.version_m_d5[2],
                row.version_m_d5[3],
                row.last_modified,
                row.flags,
                ])?;
            }
        }
        "BarberShopStyle.dbc" => {
            let data = barber_shop_style::BarberShopStyle::read(file_contents)?;
            let (table, insert, _select) = BarberShopStyle();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ty,
                &row.display_name_lang.en_gb,
                &row.display_name_lang.ko_kr,
                &row.display_name_lang.fr_fr,
                &row.display_name_lang.de_de,
                &row.display_name_lang.en_cn,
                &row.display_name_lang.en_tw,
                &row.display_name_lang.es_es,
                &row.display_name_lang.es_mx,
                &row.display_name_lang.ru_ru,
                &row.display_name_lang.ja_jp,
                &row.display_name_lang.pt_pt,
                &row.display_name_lang.it_it,
                &row.display_name_lang.unknown_12,
                &row.display_name_lang.unknown_13,
                &row.display_name_lang.unknown_14,
                &row.display_name_lang.unknown_15,
                &row.display_name_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                row.cost_modifier,
                row.race.id,
                row.sex,
                row.data,
                ])?;
            }
        }
        "BattlemasterList.dbc" => {
            let data = battlemaster_list::BattlemasterList::read(file_contents)?;
            let (table, insert, _select) = BattlemasterList();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id[0],
                row.map_id[1],
                row.map_id[2],
                row.map_id[3],
                row.map_id[4],
                row.map_id[5],
                row.map_id[6],
                row.map_id[7],
                row.instance_type,
                row.groups_allowed,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.max_group_size,
                row.holiday_world_state,
                row.min_level,
                row.max_level,
                ])?;
            }
        }
        "CameraShakes.dbc" => {
            let data = camera_shakes::CameraShakes::read(file_contents)?;
            let (table, insert, _select) = CameraShakes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.shake_type,
                row.direction,
                row.amplitude,
                row.frequency,
                row.duration,
                row.phase,
                row.coefficient,
                ])?;
            }
        }
        "Cfg_Categories.dbc" => {
            let data = cfg_categories::Cfg_Categories::read(file_contents)?;
            let (table, insert, _select) = Cfg_Categories();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.locale_mask,
                row.create_charset_mask,
                row.flags,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "Cfg_Configs.dbc" => {
            let data = cfg_configs::Cfg_Configs::read(file_contents)?;
            let (table, insert, _select) = Cfg_Configs();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.realm_type,
                row.player_killing_allowed,
                row.roleplaying,
                ])?;
            }
        }
        "CharBaseInfo.dbc" => {
            let data = char_base_info::CharBaseInfo::read(file_contents)?;
            let (table, insert, _select) = CharBaseInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.race_id.id,
                row.class_id.id,
                ])?;
            }
        }
        "CharHairGeosets.dbc" => {
            let data = char_hair_geosets::CharHairGeosets::read(file_contents)?;
            let (table, insert, _select) = CharHairGeosets();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.race_id.id,
                row.sex_id,
                row.variation_id,
                row.geoset_id,
                row.showscalp,
                ])?;
            }
        }
        "CharHairTextures.dbc" => {
            let data = char_hair_textures::CharHairTextures::read(file_contents)?;
            let (table, insert, _select) = CharHairTextures();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.field_0_5_3_3368_001_race.id,
                row.field_0_5_3_3368_002_gender,
                row.field_0_5_3_3368_003,
                row.field_0_5_3_3368_004_mayberacemask,
                row.field_0_5_3_3368_005_the_x_in_hair_xy_blp,
                row.field_0_5_3_3368_006,
                row.field_0_5_3_3368_007,
                ])?;
            }
        }
        "CharSections.dbc" => {
            let data = char_sections::CharSections::read(file_contents)?;
            let (table, insert, _select) = CharSections();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.race_id.id,
                row.sex_id,
                row.base_section,
                row.texture_name[0],
                row.texture_name[1],
                row.texture_name[2],
                row.flags,
                row.variation_index,
                row.color_index,
                ])?;
            }
        }
        "CharStartOutfit.dbc" => {
            let data = char_start_outfit::CharStartOutfit::read(file_contents)?;
            let (table, insert, _select) = CharStartOutfit();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.race_id.id,
                row.class_id.id,
                row.sex_id,
                row.outfit_id,
                row.item_id[0],
                row.item_id[1],
                row.item_id[2],
                row.item_id[3],
                row.item_id[4],
                row.item_id[5],
                row.item_id[6],
                row.item_id[7],
                row.item_id[8],
                row.item_id[9],
                row.item_id[10],
                row.item_id[11],
                row.item_id[12],
                row.item_id[13],
                row.item_id[14],
                row.item_id[15],
                row.item_id[16],
                row.item_id[17],
                row.item_id[18],
                row.item_id[19],
                row.item_id[20],
                row.item_id[21],
                row.item_id[22],
                row.item_id[23],
                row.display_item_id[0],
                row.display_item_id[1],
                row.display_item_id[2],
                row.display_item_id[3],
                row.display_item_id[4],
                row.display_item_id[5],
                row.display_item_id[6],
                row.display_item_id[7],
                row.display_item_id[8],
                row.display_item_id[9],
                row.display_item_id[10],
                row.display_item_id[11],
                row.display_item_id[12],
                row.display_item_id[13],
                row.display_item_id[14],
                row.display_item_id[15],
                row.display_item_id[16],
                row.display_item_id[17],
                row.display_item_id[18],
                row.display_item_id[19],
                row.display_item_id[20],
                row.display_item_id[21],
                row.display_item_id[22],
                row.display_item_id[23],
                row.inventory_type[0],
                row.inventory_type[1],
                row.inventory_type[2],
                row.inventory_type[3],
                row.inventory_type[4],
                row.inventory_type[5],
                row.inventory_type[6],
                row.inventory_type[7],
                row.inventory_type[8],
                row.inventory_type[9],
                row.inventory_type[10],
                row.inventory_type[11],
                row.inventory_type[12],
                row.inventory_type[13],
                row.inventory_type[14],
                row.inventory_type[15],
                row.inventory_type[16],
                row.inventory_type[17],
                row.inventory_type[18],
                row.inventory_type[19],
                row.inventory_type[20],
                row.inventory_type[21],
                row.inventory_type[22],
                row.inventory_type[23],
                ])?;
            }
        }
        "CharTitles.dbc" => {
            let data = char_titles::CharTitles::read(file_contents)?;
            let (table, insert, _select) = CharTitles();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.condition_id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.name1_lang.en_gb,
                &row.name1_lang.ko_kr,
                &row.name1_lang.fr_fr,
                &row.name1_lang.de_de,
                &row.name1_lang.en_cn,
                &row.name1_lang.en_tw,
                &row.name1_lang.es_es,
                &row.name1_lang.es_mx,
                &row.name1_lang.ru_ru,
                &row.name1_lang.ja_jp,
                &row.name1_lang.pt_pt,
                &row.name1_lang.it_it,
                &row.name1_lang.unknown_12,
                &row.name1_lang.unknown_13,
                &row.name1_lang.unknown_14,
                &row.name1_lang.unknown_15,
                &row.name1_lang.flags,
                row.mask_id,
                ])?;
            }
        }
        "CharVariations.dbc" => {
            let data = char_variations::CharVariations::read(file_contents)?;
            let (table, insert, _select) = CharVariations();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.race_id.id,
                row.sex_id,
                row.texture_hold_layer[0],
                row.texture_hold_layer[1],
                row.texture_hold_layer[2],
                row.texture_hold_layer[3],
                ])?;
            }
        }
        "CharacterFacialHairStyles.dbc" => {
            let data = character_facial_hair_styles::CharacterFacialHairStyles::read(file_contents)?;
            let (table, insert, _select) = CharacterFacialHairStyles();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.race_id.id,
                row.sex_id,
                row.variation_id,
                row.geoset[0],
                row.geoset[1],
                row.geoset[2],
                row.geoset[3],
                row.geoset[4],
                ])?;
            }
        }
        "ChatChannels.dbc" => {
            let data = chat_channels::ChatChannels::read(file_contents)?;
            let (table, insert, _select) = ChatChannels();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.faction_group,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.shortcut_lang.en_gb,
                &row.shortcut_lang.ko_kr,
                &row.shortcut_lang.fr_fr,
                &row.shortcut_lang.de_de,
                &row.shortcut_lang.en_cn,
                &row.shortcut_lang.en_tw,
                &row.shortcut_lang.es_es,
                &row.shortcut_lang.es_mx,
                &row.shortcut_lang.ru_ru,
                &row.shortcut_lang.ja_jp,
                &row.shortcut_lang.pt_pt,
                &row.shortcut_lang.it_it,
                &row.shortcut_lang.unknown_12,
                &row.shortcut_lang.unknown_13,
                &row.shortcut_lang.unknown_14,
                &row.shortcut_lang.unknown_15,
                &row.shortcut_lang.flags,
                ])?;
            }
        }
        "ChatProfanity.dbc" => {
            let data = chat_profanity::ChatProfanity::read(file_contents)?;
            let (table, insert, _select) = ChatProfanity();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.text,
                row.language,
                ])?;
            }
        }
        "ChrClasses.dbc" => {
            let data = chr_classes::ChrClasses::read(file_contents)?;
            let (table, insert, _select) = ChrClasses();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.damage_bonus_stat,
                row.display_power,
                &row.pet_name_token,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.name_female_lang.en_gb,
                &row.name_female_lang.ko_kr,
                &row.name_female_lang.fr_fr,
                &row.name_female_lang.de_de,
                &row.name_female_lang.en_cn,
                &row.name_female_lang.en_tw,
                &row.name_female_lang.es_es,
                &row.name_female_lang.es_mx,
                &row.name_female_lang.ru_ru,
                &row.name_female_lang.ja_jp,
                &row.name_female_lang.pt_pt,
                &row.name_female_lang.it_it,
                &row.name_female_lang.unknown_12,
                &row.name_female_lang.unknown_13,
                &row.name_female_lang.unknown_14,
                &row.name_female_lang.unknown_15,
                &row.name_female_lang.flags,
                &row.name_male_lang.en_gb,
                &row.name_male_lang.ko_kr,
                &row.name_male_lang.fr_fr,
                &row.name_male_lang.de_de,
                &row.name_male_lang.en_cn,
                &row.name_male_lang.en_tw,
                &row.name_male_lang.es_es,
                &row.name_male_lang.es_mx,
                &row.name_male_lang.ru_ru,
                &row.name_male_lang.ja_jp,
                &row.name_male_lang.pt_pt,
                &row.name_male_lang.it_it,
                &row.name_male_lang.unknown_12,
                &row.name_male_lang.unknown_13,
                &row.name_male_lang.unknown_14,
                &row.name_male_lang.unknown_15,
                &row.name_male_lang.flags,
                &row.filename,
                row.spell_class_set,
                row.flags,
                row.cinematic_sequence_id.id,
                row.required_expansion,
                ])?;
            }
        }
        "ChrRaces.dbc" => {
            let data = chr_races::ChrRaces::read(file_contents)?;
            let (table, insert, _select) = ChrRaces();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.faction_id.id,
                row.exploration_sound_id.id,
                row.male_display_id.id,
                row.female_display_id.id,
                &row.client_prefix,
                row.base_language.id,
                row.creature_type.id,
                row.res_sickness_spell_id.id,
                row.splash_sound_id.id,
                &row.client_file_string,
                row.cinematic_sequence_id.id,
                row.alliance,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.name_female_lang.en_gb,
                &row.name_female_lang.ko_kr,
                &row.name_female_lang.fr_fr,
                &row.name_female_lang.de_de,
                &row.name_female_lang.en_cn,
                &row.name_female_lang.en_tw,
                &row.name_female_lang.es_es,
                &row.name_female_lang.es_mx,
                &row.name_female_lang.ru_ru,
                &row.name_female_lang.ja_jp,
                &row.name_female_lang.pt_pt,
                &row.name_female_lang.it_it,
                &row.name_female_lang.unknown_12,
                &row.name_female_lang.unknown_13,
                &row.name_female_lang.unknown_14,
                &row.name_female_lang.unknown_15,
                &row.name_female_lang.flags,
                &row.name_male_lang.en_gb,
                &row.name_male_lang.ko_kr,
                &row.name_male_lang.fr_fr,
                &row.name_male_lang.de_de,
                &row.name_male_lang.en_cn,
                &row.name_male_lang.en_tw,
                &row.name_male_lang.es_es,
                &row.name_male_lang.es_mx,
                &row.name_male_lang.ru_ru,
                &row.name_male_lang.ja_jp,
                &row.name_male_lang.pt_pt,
                &row.name_male_lang.it_it,
                &row.name_male_lang.unknown_12,
                &row.name_male_lang.unknown_13,
                &row.name_male_lang.unknown_14,
                &row.name_male_lang.unknown_15,
                &row.name_male_lang.flags,
                row.facial_hair_customization[0],
                row.facial_hair_customization[1],
                &row.hair_customization,
                row.required_expansion,
                ])?;
            }
        }
        "CinematicCamera.dbc" => {
            let data = cinematic_camera::CinematicCamera::read(file_contents)?;
            let (table, insert, _select) = CinematicCamera();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.model,
                row.sound_id.id,
                row.origin[0],
                row.origin[1],
                row.origin[2],
                row.origin_facing,
                ])?;
            }
        }
        "CinematicSequences.dbc" => {
            let data = cinematic_sequences::CinematicSequences::read(file_contents)?;
            let (table, insert, _select) = CinematicSequences();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_id.id,
                row.camera[0],
                row.camera[1],
                row.camera[2],
                row.camera[3],
                row.camera[4],
                row.camera[5],
                row.camera[6],
                row.camera[7],
                ])?;
            }
        }
        "CreatureDisplayInfo.dbc" => {
            let data = creature_display_info::CreatureDisplayInfo::read(file_contents)?;
            let (table, insert, _select) = CreatureDisplayInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.model_id.id,
                row.sound_id.id,
                row.extended_display_info_id.id,
                row.creature_model_scale,
                row.creature_model_alpha,
                row.texture_variation[0],
                row.texture_variation[1],
                row.texture_variation[2],
                &row.portrait_texture_name,
                row.size_class,
                row.blood_id.id,
                row.n_p_c_sound_id.id,
                row.particle_color_id.id,
                row.creature_geoset_data,
                row.object_effect_package_id.id,
                ])?;
            }
        }
        "CreatureDisplayInfoExtra.dbc" => {
            let data = creature_display_info_extra::CreatureDisplayInfoExtra::read(file_contents)?;
            let (table, insert, _select) = CreatureDisplayInfoExtra();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.display_race_id.id,
                row.display_sex_id,
                row.skin_id,
                row.face_id,
                row.hair_style_id,
                row.hair_color_id,
                row.facial_hair_id,
                row.n_p_c_item_display[0],
                row.n_p_c_item_display[1],
                row.n_p_c_item_display[2],
                row.n_p_c_item_display[3],
                row.n_p_c_item_display[4],
                row.n_p_c_item_display[5],
                row.n_p_c_item_display[6],
                row.n_p_c_item_display[7],
                row.n_p_c_item_display[8],
                row.n_p_c_item_display[9],
                row.n_p_c_item_display[10],
                row.flags,
                &row.bake_name,
                ])?;
            }
        }
        "CreatureFamily.dbc" => {
            let data = creature_family::CreatureFamily::read(file_contents)?;
            let (table, insert, _select) = CreatureFamily();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.min_scale,
                row.min_scale_level,
                row.max_scale,
                row.max_scale_level,
                row.skill_line[0],
                row.skill_line[1],
                row.pet_food_mask,
                row.pet_talent_type,
                row.category_enum_id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.icon_file,
                ])?;
            }
        }
        "CreatureModelData.dbc" => {
            let data = creature_model_data::CreatureModelData::read(file_contents)?;
            let (table, insert, _select) = CreatureModelData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                &row.model_name,
                row.size_class,
                row.model_scale,
                row.blood_id.id,
                row.footprint_texture_id.id,
                row.footprint_texture_length,
                row.footprint_texture_width,
                row.footprint_particle_scale,
                row.foley_material_id.id,
                row.footstep_shake_size,
                row.death_thud_shake_size,
                row.sound_id.id,
                row.collision_width,
                row.collision_height,
                row.mount_height,
                row.geo_box_min_x,
                row.geo_box_min_y,
                row.geo_box_min_z,
                row.geo_box_max_x,
                row.geo_box_max_y,
                row.geo_box_max_z,
                row.world_effect_scale,
                row.attached_effect_scale,
                row.missile_collision_radius,
                row.missile_collision_push,
                row.missile_collision_raise,
                ])?;
            }
        }
        "CreatureMovementInfo.dbc" => {
            let data = creature_movement_info::CreatureMovementInfo::read(file_contents)?;
            let (table, insert, _select) = CreatureMovementInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.smooth_facing_chase_rate,
                ])?;
            }
        }
        "CreatureSoundData.dbc" => {
            let data = creature_sound_data::CreatureSoundData::read(file_contents)?;
            let (table, insert, _select) = CreatureSoundData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_exertion_id.id,
                row.sound_exertion_critical_id.id,
                row.sound_injury_id.id,
                row.sound_injury_critical_id.id,
                row.sound_injury_crushing_blow_id,
                row.sound_death_id.id,
                row.sound_stun_id.id,
                row.sound_stand_id.id,
                row.sound_footstep_id.id,
                row.sound_aggro_id.id,
                row.sound_wing_flap_id.id,
                row.sound_wing_glide_id.id,
                row.sound_alert_id.id,
                row.sound_fidget[0],
                row.sound_fidget[1],
                row.sound_fidget[2],
                row.sound_fidget[3],
                row.sound_fidget[4],
                row.custom_attack[0],
                row.custom_attack[1],
                row.custom_attack[2],
                row.custom_attack[3],
                row.n_p_c_sound_id,
                row.loop_sound_id.id,
                row.creature_impact_type,
                row.sound_jump_start_id.id,
                row.sound_jump_end_id.id,
                row.sound_pet_attack_id.id,
                row.sound_pet_order_id.id,
                row.sound_pet_dismiss_id.id,
                row.fidget_delay_seconds_min,
                row.fidget_delay_seconds_max,
                row.birth_sound_id.id,
                row.spell_cast_directed_sound_id.id,
                row.submerge_sound_id.id,
                row.submerged_sound_id.id,
                row.creature_sound_data_id_pet.id,
                ])?;
            }
        }
        "CreatureSpellData.dbc" => {
            let data = creature_spell_data::CreatureSpellData::read(file_contents)?;
            let (table, insert, _select) = CreatureSpellData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.spells[0],
                row.spells[1],
                row.spells[2],
                row.spells[3],
                row.availability[0],
                row.availability[1],
                row.availability[2],
                row.availability[3],
                ])?;
            }
        }
        "CreatureType.dbc" => {
            let data = creature_type::CreatureType::read(file_contents)?;
            let (table, insert, _select) = CreatureType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.flags,
                ])?;
            }
        }
        "CurrencyCategory.dbc" => {
            let data = currency_category::CurrencyCategory::read(file_contents)?;
            let (table, insert, _select) = CurrencyCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "CurrencyTypes.dbc" => {
            let data = currency_types::CurrencyTypes::read(file_contents)?;
            let (table, insert, _select) = CurrencyTypes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.item_id.id,
                row.category_id.id,
                row.bit_index,
                ])?;
            }
        }
        "DanceMoves.dbc" => {
            let data = dance_moves::DanceMoves::read(file_contents)?;
            let (table, insert, _select) = DanceMoves();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ty,
                row.param,
                row.fallback,
                row.racemask,
                &row.internal_name,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.lock_id.id,
                ])?;
            }
        }
        "DeathThudLookups.dbc" => {
            let data = death_thud_lookups::DeathThudLookups::read(file_contents)?;
            let (table, insert, _select) = DeathThudLookups();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.size_class,
                row.terrain_type_sound_id.id,
                row.sound_entry_id.id,
                row.sound_entry_id_water.id,
                ])?;
            }
        }
        "DeclinedWord.dbc" => {
            let data = declined_word::DeclinedWord::read(file_contents)?;
            let (table, insert, _select) = DeclinedWord();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.word,
                ])?;
            }
        }
        "DeclinedWordCases.dbc" => {
            let data = declined_word_cases::DeclinedWordCases::read(file_contents)?;
            let (table, insert, _select) = DeclinedWordCases();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.declined_word_id.id,
                row.case_index,
                &row.declined_word,
                ])?;
            }
        }
        "DestructibleModelData.dbc" => {
            let data = destructible_model_data::DestructibleModelData::read(file_contents)?;
            let (table, insert, _select) = DestructibleModelData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.state0_impact_effect_doodad_set,
                row.state0_ambient_doodad_set,
                row.state1_w_m_o,
                row.state1_destruction_doodad_set,
                row.state1_impact_effect_doodad_set,
                row.state1_ambient_doodad_set,
                row.state2_w_m_o,
                row.state2_destruction_doodad_set,
                row.state2_impact_effect_doodad_set,
                row.state2_ambient_doodad_set,
                row.state3_w_m_o,
                row.state3_init_doodad_set,
                row.state3_ambient_doodad_set,
                row.eject_direction,
                row.repair_ground_fx,
                row.do_not_highlight,
                row.heal_effect,
                row.heal_effect_speed,
                ])?;
            }
        }
        "DungeonEncounter.dbc" => {
            let data = dungeon_encounter::DungeonEncounter::read(file_contents)?;
            let (table, insert, _select) = DungeonEncounter();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.difficulty,
                row.order_index,
                row.bit,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.spell_icon_id.id,
                ])?;
            }
        }
        "DungeonMap.dbc" => {
            let data = dungeon_map::DungeonMap::read(file_contents)?;
            let (table, insert, _select) = DungeonMap();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.floor_index,
                row.min_x,
                row.max_x,
                row.min_y,
                row.max_y,
                row.parent_world_map_id.id,
                ])?;
            }
        }
        "DungeonMapChunk.dbc" => {
            let data = dungeon_map_chunk::DungeonMapChunk::read(file_contents)?;
            let (table, insert, _select) = DungeonMapChunk();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.w_m_o_group_id.id,
                row.dungeon_map_id.id,
                row.min_z,
                ])?;
            }
        }
        "DurabilityCosts.dbc" => {
            let data = durability_costs::DurabilityCosts::read(file_contents)?;
            let (table, insert, _select) = DurabilityCosts();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.weapon_sub_class_cost[0],
                row.weapon_sub_class_cost[1],
                row.weapon_sub_class_cost[2],
                row.weapon_sub_class_cost[3],
                row.weapon_sub_class_cost[4],
                row.weapon_sub_class_cost[5],
                row.weapon_sub_class_cost[6],
                row.weapon_sub_class_cost[7],
                row.weapon_sub_class_cost[8],
                row.weapon_sub_class_cost[9],
                row.weapon_sub_class_cost[10],
                row.weapon_sub_class_cost[11],
                row.weapon_sub_class_cost[12],
                row.weapon_sub_class_cost[13],
                row.weapon_sub_class_cost[14],
                row.weapon_sub_class_cost[15],
                row.weapon_sub_class_cost[16],
                row.weapon_sub_class_cost[17],
                row.weapon_sub_class_cost[18],
                row.weapon_sub_class_cost[19],
                row.weapon_sub_class_cost[20],
                row.armor_sub_class_cost[0],
                row.armor_sub_class_cost[1],
                row.armor_sub_class_cost[2],
                row.armor_sub_class_cost[3],
                row.armor_sub_class_cost[4],
                row.armor_sub_class_cost[5],
                row.armor_sub_class_cost[6],
                row.armor_sub_class_cost[7],
                ])?;
            }
        }
        "DurabilityQuality.dbc" => {
            let data = durability_quality::DurabilityQuality::read(file_contents)?;
            let (table, insert, _select) = DurabilityQuality();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.data,
                ])?;
            }
        }
        "Emotes.dbc" => {
            let data = emotes::Emotes::read(file_contents)?;
            let (table, insert, _select) = Emotes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.emote_slash_command,
                row.anim_id.id,
                row.emote_flags,
                row.emote_spec_proc,
                row.emote_spec_proc_param,
                row.event_sound_id.id,
                ])?;
            }
        }
        "EmotesText.dbc" => {
            let data = emotes_text::EmotesText::read(file_contents)?;
            let (table, insert, _select) = EmotesText();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.emote_id.id,
                row.emote_text[0],
                row.emote_text[1],
                row.emote_text[2],
                row.emote_text[3],
                row.emote_text[4],
                row.emote_text[5],
                row.emote_text[6],
                row.emote_text[7],
                row.emote_text[8],
                row.emote_text[9],
                row.emote_text[10],
                row.emote_text[11],
                row.emote_text[12],
                row.emote_text[13],
                row.emote_text[14],
                row.emote_text[15],
                ])?;
            }
        }
        "EmotesTextData.dbc" => {
            let data = emotes_text_data::EmotesTextData::read(file_contents)?;
            let (table, insert, _select) = EmotesTextData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.text_lang.en_gb,
                &row.text_lang.ko_kr,
                &row.text_lang.fr_fr,
                &row.text_lang.de_de,
                &row.text_lang.en_cn,
                &row.text_lang.en_tw,
                &row.text_lang.es_es,
                &row.text_lang.es_mx,
                &row.text_lang.ru_ru,
                &row.text_lang.ja_jp,
                &row.text_lang.pt_pt,
                &row.text_lang.it_it,
                &row.text_lang.unknown_12,
                &row.text_lang.unknown_13,
                &row.text_lang.unknown_14,
                &row.text_lang.unknown_15,
                &row.text_lang.flags,
                ])?;
            }
        }
        "EmotesTextSound.dbc" => {
            let data = emotes_text_sound::EmotesTextSound::read(file_contents)?;
            let (table, insert, _select) = EmotesTextSound();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.emotes_text_id.id,
                row.race_id.id,
                row.sex_id,
                row.sound_id.id,
                ])?;
            }
        }
        "EnvironmentalDamage.dbc" => {
            let data = environmental_damage::EnvironmentalDamage::read(file_contents)?;
            let (table, insert, _select) = EnvironmentalDamage();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.enum_id,
                row.visualkit_id.id,
                ])?;
            }
        }
        "Exhaustion.dbc" => {
            let data = exhaustion::Exhaustion::read(file_contents)?;
            let (table, insert, _select) = Exhaustion();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.xp,
                row.factor,
                row.outdoor_hours,
                row.inn_hours,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.threshold,
                ])?;
            }
        }
        "Faction.dbc" => {
            let data = faction::Faction::read(file_contents)?;
            let (table, insert, _select) = Faction();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.reputation_index,
                row.reputation_race_mask[0],
                row.reputation_race_mask[1],
                row.reputation_race_mask[2],
                row.reputation_race_mask[3],
                row.reputation_class_mask[0],
                row.reputation_class_mask[1],
                row.reputation_class_mask[2],
                row.reputation_class_mask[3],
                row.reputation_base[0],
                row.reputation_base[1],
                row.reputation_base[2],
                row.reputation_base[3],
                row.reputation_flags[0],
                row.reputation_flags[1],
                row.reputation_flags[2],
                row.reputation_flags[3],
                row.parent_faction_id.id,
                row.parent_faction_mod[0],
                row.parent_faction_mod[1],
                row.parent_faction_cap[0],
                row.parent_faction_cap[1],
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                ])?;
            }
        }
        "FactionGroup.dbc" => {
            let data = faction_group::FactionGroup::read(file_contents)?;
            let (table, insert, _select) = FactionGroup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.mask_id,
                &row.internal_name,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "FactionTemplate.dbc" => {
            let data = faction_template::FactionTemplate::read(file_contents)?;
            let (table, insert, _select) = FactionTemplate();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.faction.id,
                row.flags,
                row.faction_group.id,
                row.friend_group,
                row.enemy_group,
                row.enemies[0],
                row.enemies[1],
                row.enemies[2],
                row.enemies[3],
                row.friend[0],
                row.friend[1],
                row.friend[2],
                row.friend[3],
                ])?;
            }
        }
        "FileData.dbc" => {
            let data = file_data::FileData::read(file_contents)?;
            let (table, insert, _select) = FileData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.filename,
                &row.filepath,
                ])?;
            }
        }
        "FootprintTextures.dbc" => {
            let data = footprint_textures::FootprintTextures::read(file_contents)?;
            let (table, insert, _select) = FootprintTextures();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.footstep_filename,
                ])?;
            }
        }
        "FootstepTerrainLookup.dbc" => {
            let data = footstep_terrain_lookup::FootstepTerrainLookup::read(file_contents)?;
            let (table, insert, _select) = FootstepTerrainLookup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.creature_footstep_id,
                row.terrain_sound_id,
                row.sound_id.id,
                row.sound_id_splash.id,
                ])?;
            }
        }
        "GMSurveyAnswers.dbc" => {
            let data = gm_survey_answers::GMSurveyAnswers::read(file_contents)?;
            let (table, insert, _select) = GMSurveyAnswers();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sort_index,
                row.g_m_survey_question_id.id,
                &row.answer_lang.en_gb,
                &row.answer_lang.ko_kr,
                &row.answer_lang.fr_fr,
                &row.answer_lang.de_de,
                &row.answer_lang.en_cn,
                &row.answer_lang.en_tw,
                &row.answer_lang.es_es,
                &row.answer_lang.es_mx,
                &row.answer_lang.ru_ru,
                &row.answer_lang.ja_jp,
                &row.answer_lang.pt_pt,
                &row.answer_lang.it_it,
                &row.answer_lang.unknown_12,
                &row.answer_lang.unknown_13,
                &row.answer_lang.unknown_14,
                &row.answer_lang.unknown_15,
                &row.answer_lang.flags,
                ])?;
            }
        }
        "GMSurveyCurrentSurvey.dbc" => {
            let data = gm_survey_current_survey::GMSurveyCurrentSurvey::read(file_contents)?;
            let (table, insert, _select) = GMSurveyCurrentSurvey();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.gm_survey_id.id,
                ])?;
            }
        }
        "GMSurveyQuestions.dbc" => {
            let data = gm_survey_questions::GMSurveyQuestions::read(file_contents)?;
            let (table, insert, _select) = GMSurveyQuestions();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.question_lang.en_gb,
                &row.question_lang.ko_kr,
                &row.question_lang.fr_fr,
                &row.question_lang.de_de,
                &row.question_lang.en_cn,
                &row.question_lang.en_tw,
                &row.question_lang.es_es,
                &row.question_lang.es_mx,
                &row.question_lang.ru_ru,
                &row.question_lang.ja_jp,
                &row.question_lang.pt_pt,
                &row.question_lang.it_it,
                &row.question_lang.unknown_12,
                &row.question_lang.unknown_13,
                &row.question_lang.unknown_14,
                &row.question_lang.unknown_15,
                &row.question_lang.flags,
                ])?;
            }
        }
        "GMSurveySurveys.dbc" => {
            let data = gm_survey_surveys::GMSurveySurveys::read(file_contents)?;
            let (table, insert, _select) = GMSurveySurveys();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.q[0],
                row.q[1],
                row.q[2],
                row.q[3],
                row.q[4],
                row.q[5],
                row.q[6],
                row.q[7],
                row.q[8],
                row.q[9],
                ])?;
            }
        }
        "GMTicketCategory.dbc" => {
            let data = gm_ticket_category::GMTicketCategory::read(file_contents)?;
            let (table, insert, _select) = GMTicketCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.category_lang.en_gb,
                &row.category_lang.ko_kr,
                &row.category_lang.fr_fr,
                &row.category_lang.de_de,
                &row.category_lang.en_cn,
                &row.category_lang.en_tw,
                &row.category_lang.es_es,
                &row.category_lang.es_mx,
                &row.category_lang.ru_ru,
                &row.category_lang.ja_jp,
                &row.category_lang.pt_pt,
                &row.category_lang.it_it,
                &row.category_lang.unknown_12,
                &row.category_lang.unknown_13,
                &row.category_lang.unknown_14,
                &row.category_lang.unknown_15,
                &row.category_lang.flags,
                ])?;
            }
        }
        "GameObjectArtKit.dbc" => {
            let data = game_object_art_kit::GameObjectArtKit::read(file_contents)?;
            let (table, insert, _select) = GameObjectArtKit();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.texture_variation[0],
                row.texture_variation[1],
                row.texture_variation[2],
                row.attach_model[0],
                row.attach_model[1],
                row.attach_model[2],
                row.attach_model[3],
                ])?;
            }
        }
        "GameObjectDisplayInfo.dbc" => {
            let data = game_object_display_info::GameObjectDisplayInfo::read(file_contents)?;
            let (table, insert, _select) = GameObjectDisplayInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.model_name,
                row.sound[0],
                row.sound[1],
                row.sound[2],
                row.sound[3],
                row.sound[4],
                row.sound[5],
                row.sound[6],
                row.sound[7],
                row.sound[8],
                row.sound[9],
                row.geo_box_min[0],
                row.geo_box_min[1],
                row.geo_box_min[2],
                row.geo_box_max[0],
                row.geo_box_max[1],
                row.geo_box_max[2],
                row.object_effect_package_id.id,
                ])?;
            }
        }
        "GameTables.dbc" => {
            let data = game_tables::GameTables::read(file_contents)?;
            let (table, insert, _select) = GameTables();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                &row.name,
                row.num_rows,
                row.num_columns,
                ])?;
            }
        }
        "GameTips.dbc" => {
            let data = game_tips::GameTips::read(file_contents)?;
            let (table, insert, _select) = GameTips();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.text_lang.en_gb,
                &row.text_lang.ko_kr,
                &row.text_lang.fr_fr,
                &row.text_lang.de_de,
                &row.text_lang.en_cn,
                &row.text_lang.en_tw,
                &row.text_lang.es_es,
                &row.text_lang.es_mx,
                &row.text_lang.ru_ru,
                &row.text_lang.ja_jp,
                &row.text_lang.pt_pt,
                &row.text_lang.it_it,
                &row.text_lang.unknown_12,
                &row.text_lang.unknown_13,
                &row.text_lang.unknown_14,
                &row.text_lang.unknown_15,
                &row.text_lang.flags,
                ])?;
            }
        }
        "GemProperties.dbc" => {
            let data = gem_properties::GemProperties::read(file_contents)?;
            let (table, insert, _select) = GemProperties();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.enchant_id.id,
                row.maxcount_inv,
                row.maxcount_item,
                row.ty,
                ])?;
            }
        }
        "GlyphProperties.dbc" => {
            let data = glyph_properties::GlyphProperties::read(file_contents)?;
            let (table, insert, _select) = GlyphProperties();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.spell_id.id,
                row.glyph_slot_flags,
                row.spell_icon_id.id,
                ])?;
            }
        }
        "GlyphSlot.dbc" => {
            let data = glyph_slot::GlyphSlot::read(file_contents)?;
            let (table, insert, _select) = GlyphSlot();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ty,
                row.tooltip,
                ])?;
            }
        }
        "GroundEffectDoodad.dbc" => {
            let data = ground_effect_doodad::GroundEffectDoodad::read(file_contents)?;
            let (table, insert, _select) = GroundEffectDoodad();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.doodadpath,
                row.flags,
                ])?;
            }
        }
        "GroundEffectTexture.dbc" => {
            let data = ground_effect_texture::GroundEffectTexture::read(file_contents)?;
            let (table, insert, _select) = GroundEffectTexture();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.doodad_id[0],
                row.doodad_id[1],
                row.doodad_id[2],
                row.doodad_id[3],
                row.doodad_weight[0],
                row.doodad_weight[1],
                row.doodad_weight[2],
                row.doodad_weight[3],
                row.density,
                row.sound,
                ])?;
            }
        }
        "HelmetGeosetVisData.dbc" => {
            let data = helmet_geoset_vis_data::HelmetGeosetVisData::read(file_contents)?;
            let (table, insert, _select) = HelmetGeosetVisData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.hide_geoset[0],
                row.hide_geoset[1],
                row.hide_geoset[2],
                row.hide_geoset[3],
                row.hide_geoset[4],
                row.hide_geoset[5],
                row.hide_geoset[6],
                ])?;
            }
        }
        "HolidayDescriptions.dbc" => {
            let data = holiday_descriptions::HolidayDescriptions::read(file_contents)?;
            let (table, insert, _select) = HolidayDescriptions();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                ])?;
            }
        }
        "HolidayNames.dbc" => {
            let data = holiday_names::HolidayNames::read(file_contents)?;
            let (table, insert, _select) = HolidayNames();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "Holidays.dbc" => {
            let data = holidays::Holidays::read(file_contents)?;
            let (table, insert, _select) = Holidays();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.duration[0],
                row.duration[1],
                row.duration[2],
                row.duration[3],
                row.duration[4],
                row.duration[5],
                row.duration[6],
                row.duration[7],
                row.duration[8],
                row.duration[9],
                row.date[0],
                row.date[1],
                row.date[2],
                row.date[3],
                row.date[4],
                row.date[5],
                row.date[6],
                row.date[7],
                row.date[8],
                row.date[9],
                row.date[10],
                row.date[11],
                row.date[12],
                row.date[13],
                row.date[14],
                row.date[15],
                row.date[16],
                row.date[17],
                row.date[18],
                row.date[19],
                row.date[20],
                row.date[21],
                row.date[22],
                row.date[23],
                row.date[24],
                row.date[25],
                row.region,
                row.looping,
                row.calendar_flags[0],
                row.calendar_flags[1],
                row.calendar_flags[2],
                row.calendar_flags[3],
                row.calendar_flags[4],
                row.calendar_flags[5],
                row.calendar_flags[6],
                row.calendar_flags[7],
                row.calendar_flags[8],
                row.calendar_flags[9],
                row.holiday_name_id.id,
                row.holiday_description_id.id,
                &row.texture_file_name,
                row.priority,
                row.calendar_filter_type,
                row.flags,
                ])?;
            }
        }
        "Item.dbc" => {
            let data = item::Item::read(file_contents)?;
            let (table, insert, _select) = Item();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.class_id,
                row.subclass_id,
                row.sound_override_subclass_id,
                row.material.id,
                row.display_info_id,
                row.inventory_type,
                row.sheathe_type,
                ])?;
            }
        }
        "ItemBagFamily.dbc" => {
            let data = item_bag_family::ItemBagFamily::read(file_contents)?;
            let (table, insert, _select) = ItemBagFamily();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ItemClass.dbc" => {
            let data = item_class::ItemClass::read(file_contents)?;
            let (table, insert, _select) = ItemClass();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.class_id,
                row.subclass_map_id,
                row.flags,
                &row.class_name_lang.en_gb,
                &row.class_name_lang.ko_kr,
                &row.class_name_lang.fr_fr,
                &row.class_name_lang.de_de,
                &row.class_name_lang.en_cn,
                &row.class_name_lang.en_tw,
                &row.class_name_lang.es_es,
                &row.class_name_lang.es_mx,
                &row.class_name_lang.ru_ru,
                &row.class_name_lang.ja_jp,
                &row.class_name_lang.pt_pt,
                &row.class_name_lang.it_it,
                &row.class_name_lang.unknown_12,
                &row.class_name_lang.unknown_13,
                &row.class_name_lang.unknown_14,
                &row.class_name_lang.unknown_15,
                &row.class_name_lang.flags,
                ])?;
            }
        }
        "ItemCondExtCosts.dbc" => {
            let data = item_cond_ext_costs::ItemCondExtCosts::read(file_contents)?;
            let (table, insert, _select) = ItemCondExtCosts();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.cond_extended_cost,
                row.item_extended_cost_entry.id,
                row.arena_season,
                ])?;
            }
        }
        "ItemDisplayInfo.dbc" => {
            let data = item_display_info::ItemDisplayInfo::read(file_contents)?;
            let (table, insert, _select) = ItemDisplayInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.model_name[0],
                row.model_name[1],
                row.model_texture[0],
                row.model_texture[1],
                row.inventory_icon[0],
                row.inventory_icon[1],
                row.geoset_group[0],
                row.geoset_group[1],
                row.geoset_group[2],
                row.flags,
                row.spell_visual_id.id,
                row.group_sound_index,
                row.helmet_geoset_vis_id[0],
                row.helmet_geoset_vis_id[1],
                row.texture[0],
                row.texture[1],
                row.texture[2],
                row.texture[3],
                row.texture[4],
                row.texture[5],
                row.texture[6],
                row.texture[7],
                row.item_visual,
                row.particle_color_id.id,
                ])?;
            }
        }
        "ItemExtendedCost.dbc" => {
            let data = item_extended_cost::ItemExtendedCost::read(file_contents)?;
            let (table, insert, _select) = ItemExtendedCost();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.honor_points,
                row.arena_points,
                row.arena_bracket,
                row.item_id[0],
                row.item_id[1],
                row.item_id[2],
                row.item_id[3],
                row.item_id[4],
                row.item_count[0],
                row.item_count[1],
                row.item_count[2],
                row.item_count[3],
                row.item_count[4],
                row.required_arena_rating,
                row.item_purchase_group.id,
                ])?;
            }
        }
        "ItemGroupSounds.dbc" => {
            let data = item_group_sounds::ItemGroupSounds::read(file_contents)?;
            let (table, insert, _select) = ItemGroupSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound[0],
                row.sound[1],
                row.sound[2],
                row.sound[3],
                ])?;
            }
        }
        "ItemLimitCategory.dbc" => {
            let data = item_limit_category::ItemLimitCategory::read(file_contents)?;
            let (table, insert, _select) = ItemLimitCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.quantity,
                row.flags,
                ])?;
            }
        }
        "ItemPetFood.dbc" => {
            let data = item_pet_food::ItemPetFood::read(file_contents)?;
            let (table, insert, _select) = ItemPetFood();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ItemPurchaseGroup.dbc" => {
            let data = item_purchase_group::ItemPurchaseGroup::read(file_contents)?;
            let (table, insert, _select) = ItemPurchaseGroup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.item_id[0],
                row.item_id[1],
                row.item_id[2],
                row.item_id[3],
                row.item_id[4],
                row.item_id[5],
                row.item_id[6],
                row.item_id[7],
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ItemRandomProperties.dbc" => {
            let data = item_random_properties::ItemRandomProperties::read(file_contents)?;
            let (table, insert, _select) = ItemRandomProperties();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.enchantment[0],
                row.enchantment[1],
                row.enchantment[2],
                row.enchantment[3],
                row.enchantment[4],
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ItemRandomSuffix.dbc" => {
            let data = item_random_suffix::ItemRandomSuffix::read(file_contents)?;
            let (table, insert, _select) = ItemRandomSuffix();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.internal_name,
                row.enchantment[0],
                row.enchantment[1],
                row.enchantment[2],
                row.enchantment[3],
                row.enchantment[4],
                row.allocation_pct[0],
                row.allocation_pct[1],
                row.allocation_pct[2],
                row.allocation_pct[3],
                row.allocation_pct[4],
                ])?;
            }
        }
        "ItemSet.dbc" => {
            let data = item_set::ItemSet::read(file_contents)?;
            let (table, insert, _select) = ItemSet();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.item_id[0],
                row.item_id[1],
                row.item_id[2],
                row.item_id[3],
                row.item_id[4],
                row.item_id[5],
                row.item_id[6],
                row.item_id[7],
                row.item_id[8],
                row.item_id[9],
                row.item_id[10],
                row.item_id[11],
                row.item_id[12],
                row.item_id[13],
                row.item_id[14],
                row.item_id[15],
                row.item_id[16],
                row.set_spell_id[0],
                row.set_spell_id[1],
                row.set_spell_id[2],
                row.set_spell_id[3],
                row.set_spell_id[4],
                row.set_spell_id[5],
                row.set_spell_id[6],
                row.set_spell_id[7],
                row.set_threshold[0],
                row.set_threshold[1],
                row.set_threshold[2],
                row.set_threshold[3],
                row.set_threshold[4],
                row.set_threshold[5],
                row.set_threshold[6],
                row.set_threshold[7],
                row.required_skill.id,
                row.required_skill_rank,
                ])?;
            }
        }
        "ItemSubClass.dbc" => {
            let data = item_sub_class::ItemSubClass::read(file_contents)?;
            let (table, insert, _select) = ItemSubClass();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.class_id,
                row.sub_class_id,
                row.prerequisite_proficiency,
                row.postrequisite_proficiency,
                row.flags,
                row.display_flags,
                row.weapon_parry_seq,
                row.weapon_ready_seq,
                row.weapon_attack_seq,
                row.weapon_swing_size,
                &row.display_name_lang.en_gb,
                &row.display_name_lang.ko_kr,
                &row.display_name_lang.fr_fr,
                &row.display_name_lang.de_de,
                &row.display_name_lang.en_cn,
                &row.display_name_lang.en_tw,
                &row.display_name_lang.es_es,
                &row.display_name_lang.es_mx,
                &row.display_name_lang.ru_ru,
                &row.display_name_lang.ja_jp,
                &row.display_name_lang.pt_pt,
                &row.display_name_lang.it_it,
                &row.display_name_lang.unknown_12,
                &row.display_name_lang.unknown_13,
                &row.display_name_lang.unknown_14,
                &row.display_name_lang.unknown_15,
                &row.display_name_lang.flags,
                &row.verbose_name_lang.en_gb,
                &row.verbose_name_lang.ko_kr,
                &row.verbose_name_lang.fr_fr,
                &row.verbose_name_lang.de_de,
                &row.verbose_name_lang.en_cn,
                &row.verbose_name_lang.en_tw,
                &row.verbose_name_lang.es_es,
                &row.verbose_name_lang.es_mx,
                &row.verbose_name_lang.ru_ru,
                &row.verbose_name_lang.ja_jp,
                &row.verbose_name_lang.pt_pt,
                &row.verbose_name_lang.it_it,
                &row.verbose_name_lang.unknown_12,
                &row.verbose_name_lang.unknown_13,
                &row.verbose_name_lang.unknown_14,
                &row.verbose_name_lang.unknown_15,
                &row.verbose_name_lang.flags,
                ])?;
            }
        }
        "ItemSubClassMask.dbc" => {
            let data = item_sub_class_mask::ItemSubClassMask::read(file_contents)?;
            let (table, insert, _select) = ItemSubClassMask();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.class_id,
                row.mask,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ItemVisualEffects.dbc" => {
            let data = item_visual_effects::ItemVisualEffects::read(file_contents)?;
            let (table, insert, _select) = ItemVisualEffects();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.model,
                ])?;
            }
        }
        "ItemVisuals.dbc" => {
            let data = item_visuals::ItemVisuals::read(file_contents)?;
            let (table, insert, _select) = ItemVisuals();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.slot[0],
                row.slot[1],
                row.slot[2],
                row.slot[3],
                row.slot[4],
                ])?;
            }
        }
        "LFGDungeonExpansion.dbc" => {
            let data = lfg_dungeon_expansion::LFGDungeonExpansion::read(file_contents)?;
            let (table, insert, _select) = LFGDungeonExpansion();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.lfg_id,
                row.expansion_level,
                row.random_id,
                row.hard_level_min,
                row.hard_level_max,
                row.target_level_min,
                row.target_level_max,
                ])?;
            }
        }
        "LFGDungeonGroup.dbc" => {
            let data = lfg_dungeon_group::LFGDungeonGroup::read(file_contents)?;
            let (table, insert, _select) = LFGDungeonGroup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.order_index,
                row.parent_group_id,
                row.type_id,
                ])?;
            }
        }
        "LFGDungeons.dbc" => {
            let data = lfg_dungeons::LFGDungeons::read(file_contents)?;
            let (table, insert, _select) = LFGDungeons();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.min_level,
                row.max_level,
                row.target_level,
                row.target_level_min,
                row.target_level_max,
                row.map_id.id,
                row.difficulty,
                row.flags,
                row.type_id,
                row.faction.id,
                &row.texture_filename,
                row.expansion_level,
                row.order_index,
                row.group_id,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                ])?;
            }
        }
        "LanguageWords.dbc" => {
            let data = language_words::LanguageWords::read(file_contents)?;
            let (table, insert, _select) = LanguageWords();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.language_id.id,
                &row.word,
                ])?;
            }
        }
        "Languages.dbc" => {
            let data = languages::Languages::read(file_contents)?;
            let (table, insert, _select) = Languages();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "Light.dbc" => {
            let data = light::Light::read(file_contents)?;
            let (table, insert, _select) = Light();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.continent_id.id,
                row.game_coords[0],
                row.game_coords[1],
                row.game_coords[2],
                row.game_falloff_start,
                row.game_falloff_end,
                row.light_params_id[0],
                row.light_params_id[1],
                row.light_params_id[2],
                row.light_params_id[3],
                row.light_params_id[4],
                row.light_params_id[5],
                row.light_params_id[6],
                row.light_params_id[7],
                ])?;
            }
        }
        "LightFloatBand.dbc" => {
            let data = light_float_band::LightFloatBand::read(file_contents)?;
            let (table, insert, _select) = LightFloatBand();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.num,
                row.time[0],
                row.time[1],
                row.time[2],
                row.time[3],
                row.time[4],
                row.time[5],
                row.time[6],
                row.time[7],
                row.time[8],
                row.time[9],
                row.time[10],
                row.time[11],
                row.time[12],
                row.time[13],
                row.time[14],
                row.time[15],
                row.data[0],
                row.data[1],
                row.data[2],
                row.data[3],
                row.data[4],
                row.data[5],
                row.data[6],
                row.data[7],
                row.data[8],
                row.data[9],
                row.data[10],
                row.data[11],
                row.data[12],
                row.data[13],
                row.data[14],
                row.data[15],
                ])?;
            }
        }
        "LightIntBand.dbc" => {
            let data = light_int_band::LightIntBand::read(file_contents)?;
            let (table, insert, _select) = LightIntBand();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.num,
                row.time[0],
                row.time[1],
                row.time[2],
                row.time[3],
                row.time[4],
                row.time[5],
                row.time[6],
                row.time[7],
                row.time[8],
                row.time[9],
                row.time[10],
                row.time[11],
                row.time[12],
                row.time[13],
                row.time[14],
                row.time[15],
                row.data[0],
                row.data[1],
                row.data[2],
                row.data[3],
                row.data[4],
                row.data[5],
                row.data[6],
                row.data[7],
                row.data[8],
                row.data[9],
                row.data[10],
                row.data[11],
                row.data[12],
                row.data[13],
                row.data[14],
                row.data[15],
                ])?;
            }
        }
        "LightParams.dbc" => {
            let data = light_params::LightParams::read(file_contents)?;
            let (table, insert, _select) = LightParams();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.highlight_sky,
                row.light_skybox_id.id,
                row.glow,
                row.water_shallow_alpha,
                row.water_deep_alpha,
                row.ocean_shallow_alpha,
                row.ocean_deep_alpha,
                row.flags,
                ])?;
            }
        }
        "LightSkybox.dbc" => {
            let data = light_skybox::LightSkybox::read(file_contents)?;
            let (table, insert, _select) = LightSkybox();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.flags,
                ])?;
            }
        }
        "LiquidMaterial.dbc" => {
            let data = liquid_material::LiquidMaterial::read(file_contents)?;
            let (table, insert, _select) = LiquidMaterial();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.l_v_f,
                row.flags,
                ])?;
            }
        }
        "LiquidType.dbc" => {
            let data = liquid_type::LiquidType::read(file_contents)?;
            let (table, insert, _select) = LiquidType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.flags,
                row.sound_bank,
                row.sound_id.id,
                row.spell_id.id,
                row.max_darken_depth,
                row.fog_darken_intensity,
                row.amb_darken_intensity,
                row.dir_darken_intensity,
                row.light_id.id,
                row.particle_scale,
                row.particle_movement,
                row.particle_tex_slots,
                row.material_id.id,
                row.texture[0],
                row.texture[1],
                row.texture[2],
                row.texture[3],
                row.texture[4],
                row.texture[5],
                row.color[0],
                row.color[1],
                row.float[0],
                row.float[1],
                row.float[2],
                row.float[3],
                row.float[4],
                row.float[5],
                row.float[6],
                row.float[7],
                row.float[8],
                row.float[9],
                row.float[10],
                row.float[11],
                row.float[12],
                row.float[13],
                row.float[14],
                row.float[15],
                row.float[16],
                row.float[17],
                row.int[0],
                row.int[1],
                row.int[2],
                row.int[3],
                ])?;
            }
        }
        "LoadingScreenTaxiSplines.dbc" => {
            let data = loading_screen_taxi_splines::LoadingScreenTaxiSplines::read(file_contents)?;
            let (table, insert, _select) = LoadingScreenTaxiSplines();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.path_id.id,
                row.locx[0],
                row.locx[1],
                row.locx[2],
                row.locx[3],
                row.locx[4],
                row.locx[5],
                row.locx[6],
                row.locx[7],
                row.locy[0],
                row.locy[1],
                row.locy[2],
                row.locy[3],
                row.locy[4],
                row.locy[5],
                row.locy[6],
                row.locy[7],
                row.leg_index,
                ])?;
            }
        }
        "LoadingScreens.dbc" => {
            let data = loading_screens::LoadingScreens::read(file_contents)?;
            let (table, insert, _select) = LoadingScreens();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                &row.file_name,
                row.has_wide_screen,
                ])?;
            }
        }
        "Lock.dbc" => {
            let data = lock::Lock::read(file_contents)?;
            let (table, insert, _select) = Lock();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ty[0],
                row.ty[1],
                row.ty[2],
                row.ty[3],
                row.ty[4],
                row.ty[5],
                row.ty[6],
                row.ty[7],
                row.index[0],
                row.index[1],
                row.index[2],
                row.index[3],
                row.index[4],
                row.index[5],
                row.index[6],
                row.index[7],
                row.skill[0],
                row.skill[1],
                row.skill[2],
                row.skill[3],
                row.skill[4],
                row.skill[5],
                row.skill[6],
                row.skill[7],
                row.action[0],
                row.action[1],
                row.action[2],
                row.action[3],
                row.action[4],
                row.action[5],
                row.action[6],
                row.action[7],
                ])?;
            }
        }
        "LockType.dbc" => {
            let data = lock_type::LockType::read(file_contents)?;
            let (table, insert, _select) = LockType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.resource_name_lang.en_gb,
                &row.resource_name_lang.ko_kr,
                &row.resource_name_lang.fr_fr,
                &row.resource_name_lang.de_de,
                &row.resource_name_lang.en_cn,
                &row.resource_name_lang.en_tw,
                &row.resource_name_lang.es_es,
                &row.resource_name_lang.es_mx,
                &row.resource_name_lang.ru_ru,
                &row.resource_name_lang.ja_jp,
                &row.resource_name_lang.pt_pt,
                &row.resource_name_lang.it_it,
                &row.resource_name_lang.unknown_12,
                &row.resource_name_lang.unknown_13,
                &row.resource_name_lang.unknown_14,
                &row.resource_name_lang.unknown_15,
                &row.resource_name_lang.flags,
                &row.verb_lang.en_gb,
                &row.verb_lang.ko_kr,
                &row.verb_lang.fr_fr,
                &row.verb_lang.de_de,
                &row.verb_lang.en_cn,
                &row.verb_lang.en_tw,
                &row.verb_lang.es_es,
                &row.verb_lang.es_mx,
                &row.verb_lang.ru_ru,
                &row.verb_lang.ja_jp,
                &row.verb_lang.pt_pt,
                &row.verb_lang.it_it,
                &row.verb_lang.unknown_12,
                &row.verb_lang.unknown_13,
                &row.verb_lang.unknown_14,
                &row.verb_lang.unknown_15,
                &row.verb_lang.flags,
                &row.cursor_name,
                ])?;
            }
        }
        "MailTemplate.dbc" => {
            let data = mail_template::MailTemplate::read(file_contents)?;
            let (table, insert, _select) = MailTemplate();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.subject_lang.en_gb,
                &row.subject_lang.ko_kr,
                &row.subject_lang.fr_fr,
                &row.subject_lang.de_de,
                &row.subject_lang.en_cn,
                &row.subject_lang.en_tw,
                &row.subject_lang.es_es,
                &row.subject_lang.es_mx,
                &row.subject_lang.ru_ru,
                &row.subject_lang.ja_jp,
                &row.subject_lang.pt_pt,
                &row.subject_lang.it_it,
                &row.subject_lang.unknown_12,
                &row.subject_lang.unknown_13,
                &row.subject_lang.unknown_14,
                &row.subject_lang.unknown_15,
                &row.subject_lang.flags,
                &row.body_lang.en_gb,
                &row.body_lang.ko_kr,
                &row.body_lang.fr_fr,
                &row.body_lang.de_de,
                &row.body_lang.en_cn,
                &row.body_lang.en_tw,
                &row.body_lang.es_es,
                &row.body_lang.es_mx,
                &row.body_lang.ru_ru,
                &row.body_lang.ja_jp,
                &row.body_lang.pt_pt,
                &row.body_lang.it_it,
                &row.body_lang.unknown_12,
                &row.body_lang.unknown_13,
                &row.body_lang.unknown_14,
                &row.body_lang.unknown_15,
                &row.body_lang.flags,
                ])?;
            }
        }
        "Map.dbc" => {
            let data = map::Map::read(file_contents)?;
            let (table, insert, _select) = Map();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.directory,
                row.instance_type,
                row.flags,
                row.p_v_p,
                &row.map_name_lang.en_gb,
                &row.map_name_lang.ko_kr,
                &row.map_name_lang.fr_fr,
                &row.map_name_lang.de_de,
                &row.map_name_lang.en_cn,
                &row.map_name_lang.en_tw,
                &row.map_name_lang.es_es,
                &row.map_name_lang.es_mx,
                &row.map_name_lang.ru_ru,
                &row.map_name_lang.ja_jp,
                &row.map_name_lang.pt_pt,
                &row.map_name_lang.it_it,
                &row.map_name_lang.unknown_12,
                &row.map_name_lang.unknown_13,
                &row.map_name_lang.unknown_14,
                &row.map_name_lang.unknown_15,
                &row.map_name_lang.flags,
                row.area_table_id.id,
                &row.map_description0_lang.en_gb,
                &row.map_description0_lang.ko_kr,
                &row.map_description0_lang.fr_fr,
                &row.map_description0_lang.de_de,
                &row.map_description0_lang.en_cn,
                &row.map_description0_lang.en_tw,
                &row.map_description0_lang.es_es,
                &row.map_description0_lang.es_mx,
                &row.map_description0_lang.ru_ru,
                &row.map_description0_lang.ja_jp,
                &row.map_description0_lang.pt_pt,
                &row.map_description0_lang.it_it,
                &row.map_description0_lang.unknown_12,
                &row.map_description0_lang.unknown_13,
                &row.map_description0_lang.unknown_14,
                &row.map_description0_lang.unknown_15,
                &row.map_description0_lang.flags,
                &row.map_description1_lang.en_gb,
                &row.map_description1_lang.ko_kr,
                &row.map_description1_lang.fr_fr,
                &row.map_description1_lang.de_de,
                &row.map_description1_lang.en_cn,
                &row.map_description1_lang.en_tw,
                &row.map_description1_lang.es_es,
                &row.map_description1_lang.es_mx,
                &row.map_description1_lang.ru_ru,
                &row.map_description1_lang.ja_jp,
                &row.map_description1_lang.pt_pt,
                &row.map_description1_lang.it_it,
                &row.map_description1_lang.unknown_12,
                &row.map_description1_lang.unknown_13,
                &row.map_description1_lang.unknown_14,
                &row.map_description1_lang.unknown_15,
                &row.map_description1_lang.flags,
                row.loading_screen_id.id,
                row.minimap_icon_scale,
                row.corpse_map_id.id,
                row.corpse[0],
                row.corpse[1],
                row.time_of_day_override,
                row.expansion_id,
                row.raid_offset,
                row.max_players,
                ])?;
            }
        }
        "MapDifficulty.dbc" => {
            let data = map_difficulty::MapDifficulty::read(file_contents)?;
            let (table, insert, _select) = MapDifficulty();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.difficulty,
                &row.message_lang.en_gb,
                &row.message_lang.ko_kr,
                &row.message_lang.fr_fr,
                &row.message_lang.de_de,
                &row.message_lang.en_cn,
                &row.message_lang.en_tw,
                &row.message_lang.es_es,
                &row.message_lang.es_mx,
                &row.message_lang.ru_ru,
                &row.message_lang.ja_jp,
                &row.message_lang.pt_pt,
                &row.message_lang.it_it,
                &row.message_lang.unknown_12,
                &row.message_lang.unknown_13,
                &row.message_lang.unknown_14,
                &row.message_lang.unknown_15,
                &row.message_lang.flags,
                row.raid_duration,
                row.max_players,
                &row.difficultystring,
                ])?;
            }
        }
        "Material.dbc" => {
            let data = material::Material::read(file_contents)?;
            let (table, insert, _select) = Material();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.foley_sound_id,
                row.sheathe_sound_id,
                row.unsheathe_sound_id,
                ])?;
            }
        }
        "Movie.dbc" => {
            let data = movie::Movie::read(file_contents)?;
            let (table, insert, _select) = Movie();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.filename,
                row.volume,
                ])?;
            }
        }
        "MovieFileData.dbc" => {
            let data = movie_file_data::MovieFileData::read(file_contents)?;
            let (table, insert, _select) = MovieFileData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.file_data_id.id,
                row.resolution,
                ])?;
            }
        }
        "MovieVariation.dbc" => {
            let data = movie_variation::MovieVariation::read(file_contents)?;
            let (table, insert, _select) = MovieVariation();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.movie_id.id,
                row.file_data_id.id,
                ])?;
            }
        }
        "NPCSounds.dbc" => {
            let data = npc_sounds::NPCSounds::read(file_contents)?;
            let (table, insert, _select) = NPCSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_id[0],
                row.sound_id[1],
                row.sound_id[2],
                row.sound_id[3],
                ])?;
            }
        }
        "NameGen.dbc" => {
            let data = name_gen::NameGen::read(file_contents)?;
            let (table, insert, _select) = NameGen();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.race_id.id,
                row.sex,
                ])?;
            }
        }
        "NamesProfanity.dbc" => {
            let data = names_profanity::NamesProfanity::read(file_contents)?;
            let (table, insert, _select) = NamesProfanity();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.language,
                ])?;
            }
        }
        "NamesReserved.dbc" => {
            let data = names_reserved::NamesReserved::read(file_contents)?;
            let (table, insert, _select) = NamesReserved();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.language,
                ])?;
            }
        }
        "ObjectEffect.dbc" => {
            let data = object_effect::ObjectEffect::read(file_contents)?;
            let (table, insert, _select) = ObjectEffect();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.object_effect_group_id.id,
                row.trigger_type,
                row.event_type,
                row.effect_rec_type,
                row.effect_rec_id,
                row.attachment,
                row.offset[0],
                row.offset[1],
                row.offset[2],
                row.object_effect_modifier_id.id,
                ])?;
            }
        }
        "ObjectEffectGroup.dbc" => {
            let data = object_effect_group::ObjectEffectGroup::read(file_contents)?;
            let (table, insert, _select) = ObjectEffectGroup();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                ])?;
            }
        }
        "ObjectEffectModifier.dbc" => {
            let data = object_effect_modifier::ObjectEffectModifier::read(file_contents)?;
            let (table, insert, _select) = ObjectEffectModifier();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.input_type,
                row.map_type,
                row.output_type,
                row.param[0],
                row.param[1],
                row.param[2],
                row.param[3],
                ])?;
            }
        }
        "ObjectEffectPackage.dbc" => {
            let data = object_effect_package::ObjectEffectPackage::read(file_contents)?;
            let (table, insert, _select) = ObjectEffectPackage();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                ])?;
            }
        }
        "ObjectEffectPackageElem.dbc" => {
            let data = object_effect_package_elem::ObjectEffectPackageElem::read(file_contents)?;
            let (table, insert, _select) = ObjectEffectPackageElem();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.object_effect_package_id.id,
                row.object_effect_group_id.id,
                row.state_type,
                ])?;
            }
        }
        "OverrideSpellData.dbc" => {
            let data = override_spell_data::OverrideSpellData::read(file_contents)?;
            let (table, insert, _select) = OverrideSpellData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.spells[0],
                row.spells[1],
                row.spells[2],
                row.spells[3],
                row.spells[4],
                row.spells[5],
                row.spells[6],
                row.spells[7],
                row.spells[8],
                row.spells[9],
                row.flags,
                ])?;
            }
        }
        "Package.dbc" => {
            let data = package::Package::read(file_contents)?;
            let (table, insert, _select) = Package();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.icon,
                row.cost,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "PageTextMaterial.dbc" => {
            let data = page_text_material::PageTextMaterial::read(file_contents)?;
            let (table, insert, _select) = PageTextMaterial();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                ])?;
            }
        }
        "PaperDollItemFrame.dbc" => {
            let data = paper_doll_item_frame::PaperDollItemFrame::read(file_contents)?;
            let (table, insert, _select) = PaperDollItemFrame();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                &row.item_button_name,
                &row.slot_icon,
                row.slot_number,
                ])?;
            }
        }
        "ParticleColor.dbc" => {
            let data = particle_color::ParticleColor::read(file_contents)?;
            let (table, insert, _select) = ParticleColor();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.start[0],
                row.start[1],
                row.start[2],
                row.m_id[0],
                row.m_id[1],
                row.m_id[2],
                row.end[0],
                row.end[1],
                row.end[2],
                ])?;
            }
        }
        "PetPersonality.dbc" => {
            let data = pet_personality::PetPersonality::read(file_contents)?;
            let (table, insert, _select) = PetPersonality();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.happiness_threshold[0],
                row.happiness_threshold[1],
                row.happiness_threshold[2],
                row.happiness_damage[0],
                row.happiness_damage[1],
                row.happiness_damage[2],
                ])?;
            }
        }
        "PetitionType.dbc" => {
            let data = petition_type::PetitionType::read(file_contents)?;
            let (table, insert, _select) = PetitionType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.ty,
                ])?;
            }
        }
        "PowerDisplay.dbc" => {
            let data = power_display::PowerDisplay::read(file_contents)?;
            let (table, insert, _select) = PowerDisplay();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.actual_type,
                &row.global_string_base_tag,
                row.red,
                row.green,
                row.blue,
                ])?;
            }
        }
        "PvpDifficulty.dbc" => {
            let data = pvp_difficulty::PvpDifficulty::read(file_contents)?;
            let (table, insert, _select) = PvpDifficulty();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.range_index,
                row.min_level,
                row.max_level,
                row.difficulty,
                ])?;
            }
        }
        "QuestFactionReward.dbc" => {
            let data = quest_faction_reward::QuestFactionReward::read(file_contents)?;
            let (table, insert, _select) = QuestFactionReward();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.difficulty[0],
                row.difficulty[1],
                row.difficulty[2],
                row.difficulty[3],
                row.difficulty[4],
                row.difficulty[5],
                row.difficulty[6],
                row.difficulty[7],
                row.difficulty[8],
                row.difficulty[9],
                ])?;
            }
        }
        "QuestInfo.dbc" => {
            let data = quest_info::QuestInfo::read(file_contents)?;
            let (table, insert, _select) = QuestInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.info_name_lang.en_gb,
                &row.info_name_lang.ko_kr,
                &row.info_name_lang.fr_fr,
                &row.info_name_lang.de_de,
                &row.info_name_lang.en_cn,
                &row.info_name_lang.en_tw,
                &row.info_name_lang.es_es,
                &row.info_name_lang.es_mx,
                &row.info_name_lang.ru_ru,
                &row.info_name_lang.ja_jp,
                &row.info_name_lang.pt_pt,
                &row.info_name_lang.it_it,
                &row.info_name_lang.unknown_12,
                &row.info_name_lang.unknown_13,
                &row.info_name_lang.unknown_14,
                &row.info_name_lang.unknown_15,
                &row.info_name_lang.flags,
                ])?;
            }
        }
        "QuestSort.dbc" => {
            let data = quest_sort::QuestSort::read(file_contents)?;
            let (table, insert, _select) = QuestSort();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.sort_name_lang.en_gb,
                &row.sort_name_lang.ko_kr,
                &row.sort_name_lang.fr_fr,
                &row.sort_name_lang.de_de,
                &row.sort_name_lang.en_cn,
                &row.sort_name_lang.en_tw,
                &row.sort_name_lang.es_es,
                &row.sort_name_lang.es_mx,
                &row.sort_name_lang.ru_ru,
                &row.sort_name_lang.ja_jp,
                &row.sort_name_lang.pt_pt,
                &row.sort_name_lang.it_it,
                &row.sort_name_lang.unknown_12,
                &row.sort_name_lang.unknown_13,
                &row.sort_name_lang.unknown_14,
                &row.sort_name_lang.unknown_15,
                &row.sort_name_lang.flags,
                ])?;
            }
        }
        "QuestXP.dbc" => {
            let data = quest_xp::QuestXP::read(file_contents)?;
            let (table, insert, _select) = QuestXP();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.difficulty[0],
                row.difficulty[1],
                row.difficulty[2],
                row.difficulty[3],
                row.difficulty[4],
                row.difficulty[5],
                row.difficulty[6],
                row.difficulty[7],
                row.difficulty[8],
                row.difficulty[9],
                ])?;
            }
        }
        "RandPropPoints.dbc" => {
            let data = rand_prop_points::RandPropPoints::read(file_contents)?;
            let (table, insert, _select) = RandPropPoints();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.epic[0],
                row.epic[1],
                row.epic[2],
                row.epic[3],
                row.epic[4],
                row.superior[0],
                row.superior[1],
                row.superior[2],
                row.superior[3],
                row.superior[4],
                row.good[0],
                row.good[1],
                row.good[2],
                row.good[3],
                row.good[4],
                ])?;
            }
        }
        "Resistances.dbc" => {
            let data = resistances::Resistances::read(file_contents)?;
            let (table, insert, _select) = Resistances();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.fizzle_sound_id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "ScalingStatDistribution.dbc" => {
            let data = scaling_stat_distribution::ScalingStatDistribution::read(file_contents)?;
            let (table, insert, _select) = ScalingStatDistribution();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.stat_id[0],
                row.stat_id[1],
                row.stat_id[2],
                row.stat_id[3],
                row.stat_id[4],
                row.stat_id[5],
                row.stat_id[6],
                row.stat_id[7],
                row.stat_id[8],
                row.stat_id[9],
                row.bonus[0],
                row.bonus[1],
                row.bonus[2],
                row.bonus[3],
                row.bonus[4],
                row.bonus[5],
                row.bonus[6],
                row.bonus[7],
                row.bonus[8],
                row.bonus[9],
                row.maxlevel,
                ])?;
            }
        }
        "ScalingStatValues.dbc" => {
            let data = scaling_stat_values::ScalingStatValues::read(file_contents)?;
            let (table, insert, _select) = ScalingStatValues();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.charlevel,
                row.shoulder_budget,
                row.trinket_budget,
                row.weapon_budget1_h,
                row.ranged_budget,
                row.cloth_shoulder_armor,
                row.leather_shoulder_armor,
                row.mail_shoulder_armor,
                row.plate_shoulder_armor,
                row.weapon_d_p_s1_h,
                row.weapon_d_p_s2_h,
                row.spellcaster_d_p_s1_h,
                row.spellcaster_d_p_s2_h,
                row.ranged_d_p_s,
                row.wand_d_p_s,
                row.spell_power,
                row.primary_budget,
                row.tertiary_budget,
                row.cloth_cloak_armor,
                row.cloth_chest_armor,
                row.leather_chest_armor,
                row.mail_chest_armor,
                row.plate_chest_armor,
                ])?;
            }
        }
        "ScreenEffect.dbc" => {
            let data = screen_effect::ScreenEffect::read(file_contents)?;
            let (table, insert, _select) = ScreenEffect();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.effect,
                row.param[0],
                row.param[1],
                row.param[2],
                row.param[3],
                row.light_params_id.id,
                row.sound_ambience_id.id,
                row.zone_music_id.id,
                ])?;
            }
        }
        "ServerMessages.dbc" => {
            let data = server_messages::ServerMessages::read(file_contents)?;
            let (table, insert, _select) = ServerMessages();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.text_lang.en_gb,
                &row.text_lang.ko_kr,
                &row.text_lang.fr_fr,
                &row.text_lang.de_de,
                &row.text_lang.en_cn,
                &row.text_lang.en_tw,
                &row.text_lang.es_es,
                &row.text_lang.es_mx,
                &row.text_lang.ru_ru,
                &row.text_lang.ja_jp,
                &row.text_lang.pt_pt,
                &row.text_lang.it_it,
                &row.text_lang.unknown_12,
                &row.text_lang.unknown_13,
                &row.text_lang.unknown_14,
                &row.text_lang.unknown_15,
                &row.text_lang.flags,
                ])?;
            }
        }
        "SheatheSoundLookups.dbc" => {
            let data = sheathe_sound_lookups::SheatheSoundLookups::read(file_contents)?;
            let (table, insert, _select) = SheatheSoundLookups();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.class_id,
                row.subclass_id,
                row.material.id,
                row.check_material,
                row.sheathe_sound,
                row.unsheathe_sound,
                ])?;
            }
        }
        "SkillCostsData.dbc" => {
            let data = skill_costs_data::SkillCostsData::read(file_contents)?;
            let (table, insert, _select) = SkillCostsData();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.skill_costs_id,
                row.cost[0],
                row.cost[1],
                row.cost[2],
                ])?;
            }
        }
        "SkillLine.dbc" => {
            let data = skill_line::SkillLine::read(file_contents)?;
            let (table, insert, _select) = SkillLine();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.category_id.id,
                row.skill_costs_id,
                &row.display_name_lang.en_gb,
                &row.display_name_lang.ko_kr,
                &row.display_name_lang.fr_fr,
                &row.display_name_lang.de_de,
                &row.display_name_lang.en_cn,
                &row.display_name_lang.en_tw,
                &row.display_name_lang.es_es,
                &row.display_name_lang.es_mx,
                &row.display_name_lang.ru_ru,
                &row.display_name_lang.ja_jp,
                &row.display_name_lang.pt_pt,
                &row.display_name_lang.it_it,
                &row.display_name_lang.unknown_12,
                &row.display_name_lang.unknown_13,
                &row.display_name_lang.unknown_14,
                &row.display_name_lang.unknown_15,
                &row.display_name_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                row.spell_icon_id.id,
                &row.alternate_verb_lang.en_gb,
                &row.alternate_verb_lang.ko_kr,
                &row.alternate_verb_lang.fr_fr,
                &row.alternate_verb_lang.de_de,
                &row.alternate_verb_lang.en_cn,
                &row.alternate_verb_lang.en_tw,
                &row.alternate_verb_lang.es_es,
                &row.alternate_verb_lang.es_mx,
                &row.alternate_verb_lang.ru_ru,
                &row.alternate_verb_lang.ja_jp,
                &row.alternate_verb_lang.pt_pt,
                &row.alternate_verb_lang.it_it,
                &row.alternate_verb_lang.unknown_12,
                &row.alternate_verb_lang.unknown_13,
                &row.alternate_verb_lang.unknown_14,
                &row.alternate_verb_lang.unknown_15,
                &row.alternate_verb_lang.flags,
                row.can_link,
                ])?;
            }
        }
        "SkillLineAbility.dbc" => {
            let data = skill_line_ability::SkillLineAbility::read(file_contents)?;
            let (table, insert, _select) = SkillLineAbility();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.skill_line.id,
                row.spell.id,
                row.race_mask,
                row.class_mask,
                row.exclude_race,
                row.exclude_class,
                row.min_skill_line_rank,
                row.superceded_by_spell.id,
                row.acquire_method,
                row.trivial_skill_line_rank_high,
                row.trivial_skill_line_rank_low,
                row.character_points[0],
                row.character_points[1],
                ])?;
            }
        }
        "SkillLineCategory.dbc" => {
            let data = skill_line_category::SkillLineCategory::read(file_contents)?;
            let (table, insert, _select) = SkillLineCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.sort_index,
                ])?;
            }
        }
        "SkillRaceClassInfo.dbc" => {
            let data = skill_race_class_info::SkillRaceClassInfo::read(file_contents)?;
            let (table, insert, _select) = SkillRaceClassInfo();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.skill_id.id,
                row.race_mask,
                row.class_mask,
                row.flags,
                row.min_level,
                row.skill_tier_id.id,
                row.skill_cost_index,
                ])?;
            }
        }
        "SkillTiers.dbc" => {
            let data = skill_tiers::SkillTiers::read(file_contents)?;
            let (table, insert, _select) = SkillTiers();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.cost[0],
                row.cost[1],
                row.cost[2],
                row.cost[3],
                row.cost[4],
                row.cost[5],
                row.cost[6],
                row.cost[7],
                row.cost[8],
                row.cost[9],
                row.cost[10],
                row.cost[11],
                row.cost[12],
                row.cost[13],
                row.cost[14],
                row.cost[15],
                row.value[0],
                row.value[1],
                row.value[2],
                row.value[3],
                row.value[4],
                row.value[5],
                row.value[6],
                row.value[7],
                row.value[8],
                row.value[9],
                row.value[10],
                row.value[11],
                row.value[12],
                row.value[13],
                row.value[14],
                row.value[15],
                ])?;
            }
        }
        "SoundAmbience.dbc" => {
            let data = sound_ambience::SoundAmbience::read(file_contents)?;
            let (table, insert, _select) = SoundAmbience();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ambience_id[0],
                row.ambience_id[1],
                ])?;
            }
        }
        "SoundEmitters.dbc" => {
            let data = sound_emitters::SoundEmitters::read(file_contents)?;
            let (table, insert, _select) = SoundEmitters();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.position[0],
                row.position[1],
                row.position[2],
                row.direction[0],
                row.direction[1],
                row.direction[2],
                row.sound_entry_advanced_id.id,
                row.map_id.id,
                &row.name,
                ])?;
            }
        }
        "SoundEntries.dbc" => {
            let data = sound_entries::SoundEntries::read(file_contents)?;
            let (table, insert, _select) = SoundEntries();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_type,
                &row.name,
                row.file[0],
                row.file[1],
                row.file[2],
                row.file[3],
                row.file[4],
                row.file[5],
                row.file[6],
                row.file[7],
                row.file[8],
                row.file[9],
                row.freq[0],
                row.freq[1],
                row.freq[2],
                row.freq[3],
                row.freq[4],
                row.freq[5],
                row.freq[6],
                row.freq[7],
                row.freq[8],
                row.freq[9],
                &row.directory_base,
                row.volume_float,
                row.flags,
                row.min_distance,
                row.distance_cutoff,
                row.e_a_x_def,
                row.sound_entries_advanced_id.id,
                ])?;
            }
        }
        "SoundEntriesAdvanced.dbc" => {
            let data = sound_entries_advanced::SoundEntriesAdvanced::read(file_contents)?;
            let (table, insert, _select) = SoundEntriesAdvanced();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_entry_id.id,
                row.inner_radius2_d,
                row.time_a,
                row.time_b,
                row.time_c,
                row.time_d,
                row.random_offset_range,
                row.usage,
                row.time_interval_min,
                row.time_interval_max,
                row.volume_slider_category,
                row.duck_to_s_f_x,
                row.duck_to_music,
                row.duck_to_ambience,
                row.inner_radius_of_influence,
                row.outer_radius_of_influence,
                row.time_to_duck,
                row.time_to_unduck,
                row.inside_angle,
                row.outside_angle,
                row.outside_volume,
                row.outer_radius2_d,
                &row.name,
                ])?;
            }
        }
        "SoundFilter.dbc" => {
            let data = sound_filter::SoundFilter::read(file_contents)?;
            let (table, insert, _select) = SoundFilter();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                ])?;
            }
        }
        "SoundFilterElem.dbc" => {
            let data = sound_filter_elem::SoundFilterElem::read(file_contents)?;
            let (table, insert, _select) = SoundFilterElem();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_filter_id.id,
                row.order_index,
                row.filter_type,
                row.params[0],
                row.params[1],
                row.params[2],
                row.params[3],
                row.params[4],
                row.params[5],
                row.params[6],
                row.params[7],
                row.params[8],
                ])?;
            }
        }
        "SoundProviderPreferences.dbc" => {
            let data = sound_provider_preferences::SoundProviderPreferences::read(file_contents)?;
            let (table, insert, _select) = SoundProviderPreferences();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.description,
                row.flags,
                row.e_a_x_environment_selection,
                row.e_a_x_decay_time,
                row.e_a_x2_environment_size,
                row.e_a_x2_environment_diffusion,
                row.e_a_x2_room,
                row.e_a_x2_room_h_f,
                row.e_a_x2_decay_h_f_ratio,
                row.e_a_x2_reflections,
                row.e_a_x2_reflections_delay,
                row.e_a_x2_reverb,
                row.e_a_x2_reverb_delay,
                row.e_a_x2_room_rolloff,
                row.e_a_x2_air_absorption,
                row.e_a_x3_room_l_f,
                row.e_a_x3_decay_l_f_ratio,
                row.e_a_x3_echo_time,
                row.e_a_x3_echo_depth,
                row.e_a_x3_modulation_time,
                row.e_a_x3_modulation_depth,
                row.e_a_x3_h_f_reference,
                row.e_a_x3_l_f_reference,
                ])?;
            }
        }
        "SoundSamplePreferences.dbc" => {
            let data = sound_sample_preferences::SoundSamplePreferences::read(file_contents)?;
            let (table, insert, _select) = SoundSamplePreferences();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.field_0_6_0_3592_001,
                row.field_0_6_0_3592_002,
                row.e_a_x2_sample_room,
                row.field_0_6_0_3592_004,
                row.field_0_6_0_3592_005,
                row.field_0_6_0_3592_006,
                row.field_0_6_0_3592_007,
                row.e_a_x2_sample_occlusion_l_f_ratio,
                row.e_a_x2_sample_occlusion_room_ratio,
                row.field_0_6_0_3592_010,
                row.e_a_x1_effect_level,
                row.field_0_6_0_3592_012,
                row.field_0_6_0_3592_013,
                row.e_a_x3_sample_exclusion,
                row.field_0_6_0_3592_015,
                row.field_0_6_0_3592_016,
                ])?;
            }
        }
        "SoundWaterType.dbc" => {
            let data = sound_water_type::SoundWaterType::read(file_contents)?;
            let (table, insert, _select) = SoundWaterType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_type,
                row.sound_subtype,
                row.sound_id.id,
                ])?;
            }
        }
        "SpamMessages.dbc" => {
            let data = spam_messages::SpamMessages::read(file_contents)?;
            let (table, insert, _select) = SpamMessages();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.text,
                ])?;
            }
        }
        "Spell.dbc" => {
            let data = spell::Spell::read(file_contents)?;
            let (table, insert, _select) = Spell();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.category.id,
                row.dispel_type.id,
                row.mechanic.id,
                row.attributes,
                row.attributes_ex,
                row.attributes_ex_b,
                row.attributes_ex_c,
                row.attributes_ex_d,
                row.attributes_ex_e,
                row.attributes_ex_f,
                row.attributes_ex_g,
                row.shapeshift_mask[0],
                row.shapeshift_mask[1],
                row.shapeshift_exclude[0],
                row.shapeshift_exclude[1],
                row.targets,
                row.target_creature_type,
                row.requires_spell_focus.id,
                row.facing_caster_flags,
                row.caster_aura_state,
                row.target_aura_state,
                row.exclude_caster_aura_state,
                row.exclude_target_aura_state,
                row.caster_aura_spell,
                row.target_aura_spell,
                row.exclude_caster_aura_spell,
                row.exclude_target_aura_spell,
                row.casting_time_index.id,
                row.recovery_time,
                row.category_recovery_time,
                row.interrupt_flags,
                row.aura_interrupt_flags,
                row.channel_interrupt_flags,
                row.proc_type_mask,
                row.proc_chance,
                row.proc_charges,
                row.max_level,
                row.base_level,
                row.spell_level,
                row.duration_index.id,
                row.power_type,
                row.mana_cost,
                row.mana_cost_per_level,
                row.mana_per_second,
                row.mana_per_second_per_level,
                row.range_index,
                row.speed,
                row.modal_next_spell,
                row.cumulative_aura,
                row.totem[0],
                row.totem[1],
                row.reagent[0],
                row.reagent[1],
                row.reagent[2],
                row.reagent[3],
                row.reagent[4],
                row.reagent[5],
                row.reagent[6],
                row.reagent[7],
                row.reagent_count[0],
                row.reagent_count[1],
                row.reagent_count[2],
                row.reagent_count[3],
                row.reagent_count[4],
                row.reagent_count[5],
                row.reagent_count[6],
                row.reagent_count[7],
                row.equipped_item_class,
                row.equipped_item_subclass,
                row.equipped_item_inv_types,
                row.effect[0],
                row.effect[1],
                row.effect[2],
                row.effect_die_sides[0],
                row.effect_die_sides[1],
                row.effect_die_sides[2],
                row.effect_real_points_per_level[0],
                row.effect_real_points_per_level[1],
                row.effect_real_points_per_level[2],
                row.effect_base_points[0],
                row.effect_base_points[1],
                row.effect_base_points[2],
                row.effect_mechanic[0],
                row.effect_mechanic[1],
                row.effect_mechanic[2],
                row.implicit_target_a[0],
                row.implicit_target_a[1],
                row.implicit_target_a[2],
                row.implicit_target_b[0],
                row.implicit_target_b[1],
                row.implicit_target_b[2],
                row.effect_radius_index[0],
                row.effect_radius_index[1],
                row.effect_radius_index[2],
                row.effect_aura[0].as_int(),
                row.effect_aura[1].as_int(),
                row.effect_aura[2].as_int(),
                row.effect_aura_period[0],
                row.effect_aura_period[1],
                row.effect_aura_period[2],
                row.effect_amplitude[0],
                row.effect_amplitude[1],
                row.effect_amplitude[2],
                row.effect_chain_targets[0],
                row.effect_chain_targets[1],
                row.effect_chain_targets[2],
                row.effect_item_type[0],
                row.effect_item_type[1],
                row.effect_item_type[2],
                row.effect_misc_value[0],
                row.effect_misc_value[1],
                row.effect_misc_value[2],
                row.effect_misc_value_b[0],
                row.effect_misc_value_b[1],
                row.effect_misc_value_b[2],
                row.effect_trigger_spell[0],
                row.effect_trigger_spell[1],
                row.effect_trigger_spell[2],
                row.effect_points_per_combo[0],
                row.effect_points_per_combo[1],
                row.effect_points_per_combo[2],
                row.effect_spell_class_mask_a[0],
                row.effect_spell_class_mask_a[1],
                row.effect_spell_class_mask_a[2],
                row.effect_spell_class_mask_b[0],
                row.effect_spell_class_mask_b[1],
                row.effect_spell_class_mask_b[2],
                row.effect_spell_class_mask_c[0],
                row.effect_spell_class_mask_c[1],
                row.effect_spell_class_mask_c[2],
                row.spell_visual_id[0],
                row.spell_visual_id[1],
                row.spell_icon_id.id,
                row.active_icon_id.id,
                row.spell_priority,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                &row.name_subtext_lang.en_gb,
                &row.name_subtext_lang.ko_kr,
                &row.name_subtext_lang.fr_fr,
                &row.name_subtext_lang.de_de,
                &row.name_subtext_lang.en_cn,
                &row.name_subtext_lang.en_tw,
                &row.name_subtext_lang.es_es,
                &row.name_subtext_lang.es_mx,
                &row.name_subtext_lang.ru_ru,
                &row.name_subtext_lang.ja_jp,
                &row.name_subtext_lang.pt_pt,
                &row.name_subtext_lang.it_it,
                &row.name_subtext_lang.unknown_12,
                &row.name_subtext_lang.unknown_13,
                &row.name_subtext_lang.unknown_14,
                &row.name_subtext_lang.unknown_15,
                &row.name_subtext_lang.flags,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                &row.aura_description_lang.en_gb,
                &row.aura_description_lang.ko_kr,
                &row.aura_description_lang.fr_fr,
                &row.aura_description_lang.de_de,
                &row.aura_description_lang.en_cn,
                &row.aura_description_lang.en_tw,
                &row.aura_description_lang.es_es,
                &row.aura_description_lang.es_mx,
                &row.aura_description_lang.ru_ru,
                &row.aura_description_lang.ja_jp,
                &row.aura_description_lang.pt_pt,
                &row.aura_description_lang.it_it,
                &row.aura_description_lang.unknown_12,
                &row.aura_description_lang.unknown_13,
                &row.aura_description_lang.unknown_14,
                &row.aura_description_lang.unknown_15,
                &row.aura_description_lang.flags,
                row.mana_cost_pct,
                row.start_recovery_category,
                row.start_recovery_time,
                row.max_target_level,
                row.spell_class_set,
                row.spell_class_mask[0],
                row.spell_class_mask[1],
                row.spell_class_mask[2],
                row.max_targets,
                row.defense_type,
                row.prevention_type,
                row.stance_bar_order,
                row.effect_chain_amplitude[0],
                row.effect_chain_amplitude[1],
                row.effect_chain_amplitude[2],
                row.min_faction_id.id,
                row.min_reputation,
                row.required_aura_vision,
                row.required_totem_category_id[0],
                row.required_totem_category_id[1],
                row.required_areas_id.id,
                row.school_mask,
                row.rune_cost_id.id,
                row.spell_missile_id.id,
                row.power_display_id.id,
                row.effect_bonus_coefficient[0],
                row.effect_bonus_coefficient[1],
                row.effect_bonus_coefficient[2],
                row.description_variables_id.id,
                row.difficulty,
                ])?;
            }
        }
        "SpellCastTimes.dbc" => {
            let data = spell_cast_times::SpellCastTimes::read(file_contents)?;
            let (table, insert, _select) = SpellCastTimes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.base,
                row.per_level,
                row.minimum,
                ])?;
            }
        }
        "SpellCategory.dbc" => {
            let data = spell_category::SpellCategory::read(file_contents)?;
            let (table, insert, _select) = SpellCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                ])?;
            }
        }
        "SpellChainEffects.dbc" => {
            let data = spell_chain_effects::SpellChainEffects::read(file_contents)?;
            let (table, insert, _select) = SpellChainEffects();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.avg_seg_len,
                row.width,
                row.noise_scale,
                row.tex_coord_scale,
                row.seg_duration,
                row.seg_delay,
                &row.texture,
                row.flags,
                row.joint_count,
                row.joint_offset_radius,
                row.joints_per_minor_joint,
                row.minor_joints_per_major_joint,
                row.minor_joint_scale,
                row.major_joint_scale,
                row.joint_move_speed,
                row.joint_smoothness,
                row.min_duration_between_joint_jumps,
                row.max_duration_between_joint_jumps,
                row.wave_height,
                row.wave_freq,
                row.wave_speed,
                row.min_wave_angle,
                row.max_wave_angle,
                row.min_wave_spin,
                row.max_wave_spin,
                row.arc_height,
                row.min_arc_angle,
                row.max_arc_angle,
                row.min_arc_spin,
                row.max_arc_spin,
                row.delay_between_effects,
                row.min_flicker_on_duration,
                row.max_flicker_on_duration,
                row.min_flicker_off_duration,
                row.max_flicker_off_duration,
                row.pulse_speed,
                row.pulse_on_length,
                row.pulse_fade_length,
                row.alpha,
                row.red,
                row.green,
                row.blue,
                row.blend_mode,
                &row.combo,
                row.render_layer,
                row.texture_length,
                row.wave_phase,
                ])?;
            }
        }
        "SpellDescriptionVariables.dbc" => {
            let data = spell_description_variables::SpellDescriptionVariables::read(file_contents)?;
            let (table, insert, _select) = SpellDescriptionVariables();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.variables,
                ])?;
            }
        }
        "SpellDifficulty.dbc" => {
            let data = spell_difficulty::SpellDifficulty::read(file_contents)?;
            let (table, insert, _select) = SpellDifficulty();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.difficulty_spell_id[0],
                row.difficulty_spell_id[1],
                row.difficulty_spell_id[2],
                row.difficulty_spell_id[3],
                ])?;
            }
        }
        "SpellDispelType.dbc" => {
            let data = spell_dispel_type::SpellDispelType::read(file_contents)?;
            let (table, insert, _select) = SpellDispelType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.mask,
                row.immunity_possible,
                &row.internal_name,
                ])?;
            }
        }
        "SpellDuration.dbc" => {
            let data = spell_duration::SpellDuration::read(file_contents)?;
            let (table, insert, _select) = SpellDuration();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.duration,
                row.duration_per_level,
                row.max_duration,
                ])?;
            }
        }
        "SpellEffectCameraShakes.dbc" => {
            let data = spell_effect_camera_shakes::SpellEffectCameraShakes::read(file_contents)?;
            let (table, insert, _select) = SpellEffectCameraShakes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.camera_shake[0],
                row.camera_shake[1],
                row.camera_shake[2],
                ])?;
            }
        }
        "SpellFocusObject.dbc" => {
            let data = spell_focus_object::SpellFocusObject::read(file_contents)?;
            let (table, insert, _select) = SpellFocusObject();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                ])?;
            }
        }
        "SpellIcon.dbc" => {
            let data = spell_icon::SpellIcon::read(file_contents)?;
            let (table, insert, _select) = SpellIcon();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.texture_filename,
                ])?;
            }
        }
        "SpellItemEnchantment.dbc" => {
            let data = spell_item_enchantment::SpellItemEnchantment::read(file_contents)?;
            let (table, insert, _select) = SpellItemEnchantment();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.charges,
                row.effect[0],
                row.effect[1],
                row.effect[2],
                row.effect_points_min[0],
                row.effect_points_min[1],
                row.effect_points_min[2],
                row.effect_points_max[0],
                row.effect_points_max[1],
                row.effect_points_max[2],
                row.effect_arg[0],
                row.effect_arg[1],
                row.effect_arg[2],
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.item_visual.id,
                row.flags,
                row.src_item_id,
                row.condition_id.id,
                row.required_skill_id.id,
                row.required_skill_rank,
                row.min_level,
                ])?;
            }
        }
        "SpellItemEnchantmentCondition.dbc" => {
            let data = spell_item_enchantment_condition::SpellItemEnchantmentCondition::read(file_contents)?;
            let (table, insert, _select) = SpellItemEnchantmentCondition();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.lt_operand_type[0],
                row.lt_operand_type[1],
                row.lt_operand_type[2],
                row.lt_operand_type[3],
                row.lt_operand_type[4],
                row.lt_operand[0],
                row.lt_operand[1],
                row.lt_operand[2],
                row.lt_operand[3],
                row.lt_operand[4],
                row.operator[0],
                row.operator[1],
                row.operator[2],
                row.operator[3],
                row.operator[4],
                row.rt_operand_type[0],
                row.rt_operand_type[1],
                row.rt_operand_type[2],
                row.rt_operand_type[3],
                row.rt_operand_type[4],
                row.rt_operand[0],
                row.rt_operand[1],
                row.rt_operand[2],
                row.rt_operand[3],
                row.rt_operand[4],
                row.logic[0],
                row.logic[1],
                row.logic[2],
                row.logic[3],
                row.logic[4],
                ])?;
            }
        }
        "SpellMechanic.dbc" => {
            let data = spell_mechanic::SpellMechanic::read(file_contents)?;
            let (table, insert, _select) = SpellMechanic();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.state_name_lang.en_gb,
                &row.state_name_lang.ko_kr,
                &row.state_name_lang.fr_fr,
                &row.state_name_lang.de_de,
                &row.state_name_lang.en_cn,
                &row.state_name_lang.en_tw,
                &row.state_name_lang.es_es,
                &row.state_name_lang.es_mx,
                &row.state_name_lang.ru_ru,
                &row.state_name_lang.ja_jp,
                &row.state_name_lang.pt_pt,
                &row.state_name_lang.it_it,
                &row.state_name_lang.unknown_12,
                &row.state_name_lang.unknown_13,
                &row.state_name_lang.unknown_14,
                &row.state_name_lang.unknown_15,
                &row.state_name_lang.flags,
                ])?;
            }
        }
        "SpellMissile.dbc" => {
            let data = spell_missile::SpellMissile::read(file_contents)?;
            let (table, insert, _select) = SpellMissile();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.default_pitch_min,
                row.default_pitch_max,
                row.default_speed_min,
                row.default_speed_max,
                row.randomize_facing_min,
                row.randomize_facing_max,
                row.randomize_pitch_min,
                row.randomize_pitch_max,
                row.randomize_speed_min,
                row.randomize_speed_max,
                row.gravity,
                row.max_duration,
                row.collision_radius,
                ])?;
            }
        }
        "SpellMissileMotion.dbc" => {
            let data = spell_missile_motion::SpellMissileMotion::read(file_contents)?;
            let (table, insert, _select) = SpellMissileMotion();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                &row.script_body,
                row.flags,
                row.missile_count,
                ])?;
            }
        }
        "SpellRadius.dbc" => {
            let data = spell_radius::SpellRadius::read(file_contents)?;
            let (table, insert, _select) = SpellRadius();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.radius,
                row.radius_per_level,
                row.radius_max,
                ])?;
            }
        }
        "SpellRange.dbc" => {
            let data = spell_range::SpellRange::read(file_contents)?;
            let (table, insert, _select) = SpellRange();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.range_min[0],
                row.range_min[1],
                row.range_max[0],
                row.range_max[1],
                row.flags,
                &row.display_name_lang.en_gb,
                &row.display_name_lang.ko_kr,
                &row.display_name_lang.fr_fr,
                &row.display_name_lang.de_de,
                &row.display_name_lang.en_cn,
                &row.display_name_lang.en_tw,
                &row.display_name_lang.es_es,
                &row.display_name_lang.es_mx,
                &row.display_name_lang.ru_ru,
                &row.display_name_lang.ja_jp,
                &row.display_name_lang.pt_pt,
                &row.display_name_lang.it_it,
                &row.display_name_lang.unknown_12,
                &row.display_name_lang.unknown_13,
                &row.display_name_lang.unknown_14,
                &row.display_name_lang.unknown_15,
                &row.display_name_lang.flags,
                &row.display_name_short_lang.en_gb,
                &row.display_name_short_lang.ko_kr,
                &row.display_name_short_lang.fr_fr,
                &row.display_name_short_lang.de_de,
                &row.display_name_short_lang.en_cn,
                &row.display_name_short_lang.en_tw,
                &row.display_name_short_lang.es_es,
                &row.display_name_short_lang.es_mx,
                &row.display_name_short_lang.ru_ru,
                &row.display_name_short_lang.ja_jp,
                &row.display_name_short_lang.pt_pt,
                &row.display_name_short_lang.it_it,
                &row.display_name_short_lang.unknown_12,
                &row.display_name_short_lang.unknown_13,
                &row.display_name_short_lang.unknown_14,
                &row.display_name_short_lang.unknown_15,
                &row.display_name_short_lang.flags,
                ])?;
            }
        }
        "SpellRuneCost.dbc" => {
            let data = spell_rune_cost::SpellRuneCost::read(file_contents)?;
            let (table, insert, _select) = SpellRuneCost();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.blood,
                row.unholy,
                row.frost,
                row.runic_power,
                ])?;
            }
        }
        "SpellShapeshiftForm.dbc" => {
            let data = spell_shapeshift_form::SpellShapeshiftForm::read(file_contents)?;
            let (table, insert, _select) = SpellShapeshiftForm();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.bonus_action_bar,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.flags,
                row.creature_type.id,
                row.attack_icon_id.id,
                row.combat_round_time,
                row.creature_display_id[0],
                row.creature_display_id[1],
                row.creature_display_id[2],
                row.creature_display_id[3],
                row.preset_spell_id[0],
                row.preset_spell_id[1],
                row.preset_spell_id[2],
                row.preset_spell_id[3],
                row.preset_spell_id[4],
                row.preset_spell_id[5],
                row.preset_spell_id[6],
                row.preset_spell_id[7],
                ])?;
            }
        }
        "SpellVisual.dbc" => {
            let data = spell_visual::SpellVisual::read(file_contents)?;
            let (table, insert, _select) = SpellVisual();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.precast_kit,
                row.cast_kit,
                row.impact_kit,
                row.state_kit,
                row.state_done_kit,
                row.channel_kit,
                row.has_missile,
                row.missile_model,
                row.missile_path_type,
                row.missile_destination_attachment,
                row.missile_sound,
                row.anim_event_sound_id.id,
                row.flags,
                row.caster_impact_kit,
                row.target_impact_kit,
                row.missile_attachment,
                row.missile_follow_ground_height,
                row.missile_follow_ground_drop_speed,
                row.missile_follow_ground_approach,
                row.missile_follow_ground_flags,
                row.missile_motion,
                row.missile_targeting_kit.id,
                row.instant_area_kit,
                row.impact_area_kit,
                row.persistent_area_kit,
                row.missile_cast_offset[0],
                row.missile_cast_offset[1],
                row.missile_cast_offset[2],
                row.missile_impact_offset[0],
                row.missile_impact_offset[1],
                row.missile_impact_offset[2],
                ])?;
            }
        }
        "SpellVisualEffectName.dbc" => {
            let data = spell_visual_effect_name::SpellVisualEffectName::read(file_contents)?;
            let (table, insert, _select) = SpellVisualEffectName();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                &row.file_name,
                row.area_effect_size,
                row.scale,
                row.min_allowed_scale,
                row.max_allowed_scale,
                ])?;
            }
        }
        "SpellVisualKit.dbc" => {
            let data = spell_visual_kit::SpellVisualKit::read(file_contents)?;
            let (table, insert, _select) = SpellVisualKit();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.start_anim_id.id,
                row.anim_id.id,
                row.head_effect,
                row.chest_effect,
                row.base_effect,
                row.left_hand_effect,
                row.right_hand_effect,
                row.breath_effect,
                row.left_weapon_effect,
                row.right_weapon_effect,
                row.special_effect[0],
                row.special_effect[1],
                row.special_effect[2],
                row.world_effect,
                row.sound_id.id,
                row.shake_id.id,
                row.char_proc[0],
                row.char_proc[1],
                row.char_proc[2],
                row.char_proc[3],
                row.char_param_zero[0],
                row.char_param_zero[1],
                row.char_param_zero[2],
                row.char_param_zero[3],
                row.char_param_one[0],
                row.char_param_one[1],
                row.char_param_one[2],
                row.char_param_one[3],
                row.char_param_two[0],
                row.char_param_two[1],
                row.char_param_two[2],
                row.char_param_two[3],
                row.char_param_three[0],
                row.char_param_three[1],
                row.char_param_three[2],
                row.char_param_three[3],
                row.flags,
                ])?;
            }
        }
        "SpellVisualKitAreaModel.dbc" => {
            let data = spell_visual_kit_area_model::SpellVisualKitAreaModel::read(file_contents)?;
            let (table, insert, _select) = SpellVisualKitAreaModel();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.enum_id,
                ])?;
            }
        }
        "SpellVisualKitModelAttach.dbc" => {
            let data = spell_visual_kit_model_attach::SpellVisualKitModelAttach::read(file_contents)?;
            let (table, insert, _select) = SpellVisualKitModelAttach();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.parent_spell_visual_kit_id.id,
                row.spell_visual_effect_name_id.id,
                row.attachment_id,
                row.offset[0],
                row.offset[1],
                row.offset[2],
                row.yaw,
                row.pitch,
                row.roll,
                ])?;
            }
        }
        "SpellVisualPrecastTransitions.dbc" => {
            let data = spell_visual_precast_transitions::SpellVisualPrecastTransitions::read(file_contents)?;
            let (table, insert, _select) = SpellVisualPrecastTransitions();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.precast_load_anim_name,
                &row.precast_hold_anim_name,
                ])?;
            }
        }
        "StableSlotPrices.dbc" => {
            let data = stable_slot_prices::StableSlotPrices::read(file_contents)?;
            let (table, insert, _select) = StableSlotPrices();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.cost,
                ])?;
            }
        }
        "Startup_Strings.dbc" => {
            let data = startup_strings::Startup_Strings::read(file_contents)?;
            let (table, insert, _select) = Startup_Strings();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                &row.message_lang.en_gb,
                &row.message_lang.ko_kr,
                &row.message_lang.fr_fr,
                &row.message_lang.de_de,
                &row.message_lang.en_cn,
                &row.message_lang.en_tw,
                &row.message_lang.es_es,
                &row.message_lang.es_mx,
                &row.message_lang.ru_ru,
                &row.message_lang.ja_jp,
                &row.message_lang.pt_pt,
                &row.message_lang.it_it,
                &row.message_lang.unknown_12,
                &row.message_lang.unknown_13,
                &row.message_lang.unknown_14,
                &row.message_lang.unknown_15,
                &row.message_lang.flags,
                ])?;
            }
        }
        "Stationery.dbc" => {
            let data = stationery::Stationery::read(file_contents)?;
            let (table, insert, _select) = Stationery();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.item_id.id,
                &row.texture,
                row.flags,
                ])?;
            }
        }
        "StringLookups.dbc" => {
            let data = string_lookups::StringLookups::read(file_contents)?;
            let (table, insert, _select) = StringLookups();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.string,
                ])?;
            }
        }
        "SummonProperties.dbc" => {
            let data = summon_properties::SummonProperties::read(file_contents)?;
            let (table, insert, _select) = SummonProperties();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.control,
                row.faction.id,
                row.title,
                row.slot,
                row.flags,
                ])?;
            }
        }
        "Talent.dbc" => {
            let data = talent::Talent::read(file_contents)?;
            let (table, insert, _select) = Talent();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.tab_id,
                row.tier_id,
                row.column_index,
                row.spell_rank[0],
                row.spell_rank[1],
                row.spell_rank[2],
                row.spell_rank[3],
                row.spell_rank[4],
                row.spell_rank[5],
                row.spell_rank[6],
                row.spell_rank[7],
                row.spell_rank[8],
                row.prereq_talent[0],
                row.prereq_talent[1],
                row.prereq_talent[2],
                row.prereq_rank[0],
                row.prereq_rank[1],
                row.prereq_rank[2],
                row.flags,
                row.required_spell_id.id,
                row.category_mask[0],
                row.category_mask[1],
                ])?;
            }
        }
        "TalentTab.dbc" => {
            let data = talent_tab::TalentTab::read(file_contents)?;
            let (table, insert, _select) = TalentTab();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.spell_icon_id.id,
                row.race_mask,
                row.class_mask,
                row.category_enum_id,
                row.order_index,
                &row.background_file,
                ])?;
            }
        }
        "TaxiNodes.dbc" => {
            let data = taxi_nodes::TaxiNodes::read(file_contents)?;
            let (table, insert, _select) = TaxiNodes();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.continent_id.id,
                row.pos[0],
                row.pos[1],
                row.pos[2],
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.mount_creature_id[0],
                row.mount_creature_id[1],
                ])?;
            }
        }
        "TaxiPath.dbc" => {
            let data = taxi_path::TaxiPath::read(file_contents)?;
            let (table, insert, _select) = TaxiPath();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.from_taxi_node.id,
                row.to_taxi_node.id,
                row.cost,
                ])?;
            }
        }
        "TaxiPathNode.dbc" => {
            let data = taxi_path_node::TaxiPathNode::read(file_contents)?;
            let (table, insert, _select) = TaxiPathNode();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.path_id.id,
                row.node_index,
                row.continent_id.id,
                row.loc[0],
                row.loc[1],
                row.loc[2],
                row.flags,
                row.delay,
                row.arrival_event_id,
                row.departure_event_id,
                ])?;
            }
        }
        "TeamContributionPoints.dbc" => {
            let data = team_contribution_points::TeamContributionPoints::read(file_contents)?;
            let (table, insert, _select) = TeamContributionPoints();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.data,
                ])?;
            }
        }
        "TerrainType.dbc" => {
            let data = terrain_type::TerrainType::read(file_contents)?;
            let (table, insert, _select) = TerrainType();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.terrain_id,
                &row.terrain_desc,
                row.footstep_spray_run,
                row.footstep_spray_walk,
                row.sound_id,
                row.flags,
                ])?;
            }
        }
        "TerrainTypeSounds.dbc" => {
            let data = terrain_type_sounds::TerrainTypeSounds::read(file_contents)?;
            let (table, insert, _select) = TerrainTypeSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                ])?;
            }
        }
        "TotemCategory.dbc" => {
            let data = totem_category::TotemCategory::read(file_contents)?;
            let (table, insert, _select) = TotemCategory();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name_lang.en_gb,
                &row.name_lang.ko_kr,
                &row.name_lang.fr_fr,
                &row.name_lang.de_de,
                &row.name_lang.en_cn,
                &row.name_lang.en_tw,
                &row.name_lang.es_es,
                &row.name_lang.es_mx,
                &row.name_lang.ru_ru,
                &row.name_lang.ja_jp,
                &row.name_lang.pt_pt,
                &row.name_lang.it_it,
                &row.name_lang.unknown_12,
                &row.name_lang.unknown_13,
                &row.name_lang.unknown_14,
                &row.name_lang.unknown_15,
                &row.name_lang.flags,
                row.totem_category_type,
                row.totem_category_mask,
                ])?;
            }
        }
        "TransportAnimation.dbc" => {
            let data = transport_animation::TransportAnimation::read(file_contents)?;
            let (table, insert, _select) = TransportAnimation();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.transport_id,
                row.time_index,
                row.pos[0],
                row.pos[1],
                row.pos[2],
                row.sequence_id,
                ])?;
            }
        }
        "TransportPhysics.dbc" => {
            let data = transport_physics::TransportPhysics::read(file_contents)?;
            let (table, insert, _select) = TransportPhysics();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.wave_amp,
                row.wave_time_scale,
                row.roll_amp,
                row.roll_time_scale,
                row.pitch_amp,
                row.pitch_time_scale,
                row.max_bank,
                row.max_bank_turn_speed,
                row.speed_damp_thresh,
                row.speed_damp,
                ])?;
            }
        }
        "TransportRotation.dbc" => {
            let data = transport_rotation::TransportRotation::read(file_contents)?;
            let (table, insert, _select) = TransportRotation();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.game_objects_id,
                row.time_index,
                row.rot[0],
                row.rot[1],
                row.rot[2],
                row.rot[3],
                ])?;
            }
        }
        "UISoundLookups.dbc" => {
            let data = ui_sound_lookups::UISoundLookups::read(file_contents)?;
            let (table, insert, _select) = UISoundLookups();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.sound_id.id,
                &row.sound_name,
                ])?;
            }
        }
        "UnitBlood.dbc" => {
            let data = unit_blood::UnitBlood::read(file_contents)?;
            let (table, insert, _select) = UnitBlood();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.combat_blood_spurt_front[0],
                row.combat_blood_spurt_front[1],
                row.combat_blood_spurt_back[0],
                row.combat_blood_spurt_back[1],
                row.ground_blood[0],
                row.ground_blood[1],
                row.ground_blood[2],
                row.ground_blood[3],
                row.ground_blood[4],
                ])?;
            }
        }
        "UnitBloodLevels.dbc" => {
            let data = unit_blood_levels::UnitBloodLevels::read(file_contents)?;
            let (table, insert, _select) = UnitBloodLevels();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.violencelevel[0],
                row.violencelevel[1],
                row.violencelevel[2],
                ])?;
            }
        }
        "Vehicle.dbc" => {
            let data = vehicle::Vehicle::read(file_contents)?;
            let (table, insert, _select) = Vehicle();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.flags,
                row.turn_speed,
                row.pitch_speed,
                row.pitch_min,
                row.pitch_max,
                row.seat_id[0],
                row.seat_id[1],
                row.seat_id[2],
                row.seat_id[3],
                row.seat_id[4],
                row.seat_id[5],
                row.seat_id[6],
                row.seat_id[7],
                row.mouse_look_offset_pitch,
                row.camera_fade_dist_scalar_min,
                row.camera_fade_dist_scalar_max,
                row.camera_pitch_offset,
                row.facing_limit_right,
                row.facing_limit_left,
                row.mssl_trgt_turn_lingering,
                row.mssl_trgt_pitch_lingering,
                row.mssl_trgt_mouse_lingering,
                row.mssl_trgt_end_opacity,
                row.mssl_trgt_arc_speed,
                row.mssl_trgt_arc_repeat,
                row.mssl_trgt_arc_width,
                row.mssl_trgt_impact_radius[0],
                row.mssl_trgt_impact_radius[1],
                &row.mssl_trgt_arc_texture,
                &row.mssl_trgt_impact_texture,
                row.mssl_trgt_impact_model[0],
                row.mssl_trgt_impact_model[1],
                row.camera_yaw_offset,
                row.ui_locomotion_type,
                row.mssl_trgt_impact_tex_radius,
                row.vehicle_u_i_indicator_id.id,
                row.power_display_id[0],
                row.power_display_id[1],
                row.power_display_id[2],
                ])?;
            }
        }
        "VehicleSeat.dbc" => {
            let data = vehicle_seat::VehicleSeat::read(file_contents)?;
            let (table, insert, _select) = VehicleSeat();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.field_3_3_5_12213_001,
                row.attachment_id,
                row.attachment_offset[0],
                row.attachment_offset[1],
                row.attachment_offset[2],
                row.field_3_3_5_12213_004,
                row.enter_speed,
                row.enter_gravity,
                row.enter_min_duration,
                row.enter_max_duration,
                row.enter_min_arc_height,
                row.enter_max_arc_height,
                row.enter_anim_start,
                row.enter_anim_loop,
                row.ride_anim_start,
                row.ride_anim_loop,
                row.ride_upper_anim_start,
                row.ride_upper_anim_loop,
                row.field_3_3_5_12213_017,
                row.exit_speed,
                row.exit_gravity,
                row.exit_min_duration,
                row.exit_max_duration,
                row.exit_min_arc_height,
                row.exit_max_arc_height,
                row.exit_anim_start,
                row.exit_anim_loop,
                row.exit_anim_end,
                row.field_3_3_5_12213_027,
                row.passenger_pitch,
                row.field_3_3_5_12213_029,
                row.passenger_attachment_id,
                row.vehicle_enter_anim,
                row.vehicle_exit_anim,
                row.vehicle_ride_anim_loop,
                row.field_3_3_5_12213_034,
                row.vehicle_exit_anim_bone,
                row.vehicle_enter_anim_bone,
                row.field_3_3_5_12213_037,
                row.field_3_3_5_12213_038,
                row.vehicle_ability_display,
                row.enter_u_i_sound_id.id,
                row.field_3_3_5_12213_041,
                row.ui_skin,
                row.field_3_3_5_12213_043,
                row.field_3_3_5_12213_044,
                row.field_3_3_5_12213_045,
                row.field_3_3_5_12213_046,
                row.field_3_3_5_12213_047,
                row.field_3_3_5_12213_048,
                row.field_3_3_5_12213_049,
                row.field_3_3_5_12213_050,
                row.field_3_3_5_12213_051,
                row.field_3_3_5_12213_052,
                row.field_3_3_5_12213_053,
                row.field_3_3_5_12213_054,
                row.field_3_3_5_12213_055,
                ])?;
            }
        }
        "VehicleUIIndSeat.dbc" => {
            let data = vehicle_ui_ind_seat::VehicleUIIndSeat::read(file_contents)?;
            let (table, insert, _select) = VehicleUIIndSeat();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.vehicle_u_i_indicator_id.id,
                row.virtual_seat_index,
                row.x_pos,
                row.y_pos,
                ])?;
            }
        }
        "VehicleUIIndicator.dbc" => {
            let data = vehicle_ui_indicator::VehicleUIIndicator::read(file_contents)?;
            let (table, insert, _select) = VehicleUIIndicator();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.background_texture,
                ])?;
            }
        }
        "VideoHardware.dbc" => {
            let data = video_hardware::VideoHardware::read(file_contents)?;
            let (table, insert, _select) = VideoHardware();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.vendor_id,
                row.device_id,
                row.farclip_idx,
                row.terrain_l_o_d_dist_idx,
                row.terrain_shadow_l_o_d,
                row.detail_doodad_density_idx,
                row.detail_doodad_alpha,
                row.animating_doodad_idx,
                row.trilinear,
                row.num_lights,
                row.specularity,
                row.water_l_o_d_idx,
                row.particle_density_idx,
                row.unit_draw_dist_idx,
                row.small_cull_dist_idx,
                row.resolution_idx,
                row.base_mip_level,
                &row.ogl_overrides,
                &row.d3d_overrides,
                row.fix_lag,
                row.multisample,
                row.atlasdisable,
                ])?;
            }
        }
        "VocalUISounds.dbc" => {
            let data = vocal_ui_sounds::VocalUISounds::read(file_contents)?;
            let (table, insert, _select) = VocalUISounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.vocal_u_i_enum,
                row.race_id.id,
                row.normal_sound_id[0],
                row.normal_sound_id[1],
                row.pissed_sound_id[0],
                row.pissed_sound_id[1],
                ])?;
            }
        }
        "WMOAreaTable.dbc" => {
            let data = wmo_area_table::WMOAreaTable::read(file_contents)?;
            let (table, insert, _select) = WMOAreaTable();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.w_m_o_id,
                row.name_set_id,
                row.w_m_o_group_id,
                row.sound_provider_pref.id,
                row.sound_provider_pref_underwater.id,
                row.ambience_id.id,
                row.zone_music.id,
                row.intro_sound.id,
                row.flags,
                row.area_table_id.id,
                &row.area_name_lang.en_gb,
                &row.area_name_lang.ko_kr,
                &row.area_name_lang.fr_fr,
                &row.area_name_lang.de_de,
                &row.area_name_lang.en_cn,
                &row.area_name_lang.en_tw,
                &row.area_name_lang.es_es,
                &row.area_name_lang.es_mx,
                &row.area_name_lang.ru_ru,
                &row.area_name_lang.ja_jp,
                &row.area_name_lang.pt_pt,
                &row.area_name_lang.it_it,
                &row.area_name_lang.unknown_12,
                &row.area_name_lang.unknown_13,
                &row.area_name_lang.unknown_14,
                &row.area_name_lang.unknown_15,
                &row.area_name_lang.flags,
                ])?;
            }
        }
        "WeaponImpactSounds.dbc" => {
            let data = weapon_impact_sounds::WeaponImpactSounds::read(file_contents)?;
            let (table, insert, _select) = WeaponImpactSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.weapon_sub_class_id,
                row.parry_sound_type,
                row.impact_sound_id[0],
                row.impact_sound_id[1],
                row.impact_sound_id[2],
                row.impact_sound_id[3],
                row.impact_sound_id[4],
                row.impact_sound_id[5],
                row.impact_sound_id[6],
                row.impact_sound_id[7],
                row.impact_sound_id[8],
                row.impact_sound_id[9],
                row.crit_impact_sound_id[0],
                row.crit_impact_sound_id[1],
                row.crit_impact_sound_id[2],
                row.crit_impact_sound_id[3],
                row.crit_impact_sound_id[4],
                row.crit_impact_sound_id[5],
                row.crit_impact_sound_id[6],
                row.crit_impact_sound_id[7],
                row.crit_impact_sound_id[8],
                row.crit_impact_sound_id[9],
                ])?;
            }
        }
        "WeaponSwingSounds2.dbc" => {
            let data = weapon_swing_sounds2::WeaponSwingSounds2::read(file_contents)?;
            let (table, insert, _select) = WeaponSwingSounds2();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.swing_type,
                row.crit,
                row.sound_id.id,
                ])?;
            }
        }
        "Weather.dbc" => {
            let data = weather::Weather::read(file_contents)?;
            let (table, insert, _select) = Weather();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.ambience_id.id,
                row.effect_type,
                row.transition_sky_box,
                row.effect_color[0],
                row.effect_color[1],
                row.effect_color[2],
                &row.effect_texture,
                ])?;
            }
        }
        "WorldChunkSounds.dbc" => {
            let data = world_chunk_sounds::WorldChunkSounds::read(file_contents)?;
            let (table, insert, _select) = WorldChunkSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.chunk_x,
                row.chunk_y,
                row.subchunk_x,
                row.subchunk_y,
                row.zone_intro_music_id,
                row.zone_music_id.id,
                row.sound_ambience_id.id,
                row.sound_provider_preferences_id.id,
                ])?;
            }
        }
        "WorldMapArea.dbc" => {
            let data = world_map_area::WorldMapArea::read(file_contents)?;
            let (table, insert, _select) = WorldMapArea();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.area_id.id,
                &row.area_name,
                row.loc_left,
                row.loc_right,
                row.loc_top,
                row.loc_bottom,
                row.display_map_id.id,
                row.default_dungeon_floor,
                row.parent_world_map_id.id,
                ])?;
            }
        }
        "WorldMapContinent.dbc" => {
            let data = world_map_continent::WorldMapContinent::read(file_contents)?;
            let (table, insert, _select) = WorldMapContinent();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.left_boundary,
                row.right_boundary,
                row.top_boundary,
                row.bottom_boundary,
                row.continent_offset[0],
                row.continent_offset[1],
                row.scale,
                row.taxi_min[0],
                row.taxi_min[1],
                row.taxi_max[0],
                row.taxi_max[1],
                row.world_map_id.id,
                ])?;
            }
        }
        "WorldMapOverlay.dbc" => {
            let data = world_map_overlay::WorldMapOverlay::read(file_contents)?;
            let (table, insert, _select) = WorldMapOverlay();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_area_id.id,
                row.area_id[0],
                row.area_id[1],
                row.area_id[2],
                row.area_id[3],
                row.map_point_x,
                row.map_point_y,
                &row.texture_name,
                row.texture_width,
                row.texture_height,
                row.offset_x,
                row.offset_y,
                row.hit_rect_top,
                row.hit_rect_left,
                row.hit_rect_bottom,
                row.hit_rect_right,
                ])?;
            }
        }
        "WorldMapTransforms.dbc" => {
            let data = world_map_transforms::WorldMapTransforms::read(file_contents)?;
            let (table, insert, _select) = WorldMapTransforms();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.region_min[0],
                row.region_min[1],
                row.region_max[0],
                row.region_max[1],
                row.new_map_id.id,
                row.region_offset[0],
                row.region_offset[1],
                row.new_dungeon_map_id.id,
                ])?;
            }
        }
        "WorldSafeLocs.dbc" => {
            let data = world_safe_locs::WorldSafeLocs::read(file_contents)?;
            let (table, insert, _select) = WorldSafeLocs();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.continent.id,
                row.loc[0],
                row.loc[1],
                row.loc[2],
                &row.area_name_lang.en_gb,
                &row.area_name_lang.ko_kr,
                &row.area_name_lang.fr_fr,
                &row.area_name_lang.de_de,
                &row.area_name_lang.en_cn,
                &row.area_name_lang.en_tw,
                &row.area_name_lang.es_es,
                &row.area_name_lang.es_mx,
                &row.area_name_lang.ru_ru,
                &row.area_name_lang.ja_jp,
                &row.area_name_lang.pt_pt,
                &row.area_name_lang.it_it,
                &row.area_name_lang.unknown_12,
                &row.area_name_lang.unknown_13,
                &row.area_name_lang.unknown_14,
                &row.area_name_lang.unknown_15,
                &row.area_name_lang.flags,
                ])?;
            }
        }
        "WorldStateUI.dbc" => {
            let data = world_state_ui::WorldStateUI::read(file_contents)?;
            let (table, insert, _select) = WorldStateUI();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.map_id.id,
                row.area_id.id,
                row.phase_shift,
                &row.icon,
                &row.string_lang.en_gb,
                &row.string_lang.ko_kr,
                &row.string_lang.fr_fr,
                &row.string_lang.de_de,
                &row.string_lang.en_cn,
                &row.string_lang.en_tw,
                &row.string_lang.es_es,
                &row.string_lang.es_mx,
                &row.string_lang.ru_ru,
                &row.string_lang.ja_jp,
                &row.string_lang.pt_pt,
                &row.string_lang.it_it,
                &row.string_lang.unknown_12,
                &row.string_lang.unknown_13,
                &row.string_lang.unknown_14,
                &row.string_lang.unknown_15,
                &row.string_lang.flags,
                &row.tooltip_lang.en_gb,
                &row.tooltip_lang.ko_kr,
                &row.tooltip_lang.fr_fr,
                &row.tooltip_lang.de_de,
                &row.tooltip_lang.en_cn,
                &row.tooltip_lang.en_tw,
                &row.tooltip_lang.es_es,
                &row.tooltip_lang.es_mx,
                &row.tooltip_lang.ru_ru,
                &row.tooltip_lang.ja_jp,
                &row.tooltip_lang.pt_pt,
                &row.tooltip_lang.it_it,
                &row.tooltip_lang.unknown_12,
                &row.tooltip_lang.unknown_13,
                &row.tooltip_lang.unknown_14,
                &row.tooltip_lang.unknown_15,
                &row.tooltip_lang.flags,
                row.state_variable,
                row.ty,
                &row.dynamic_icon,
                &row.dynamic_tooltip_lang.en_gb,
                &row.dynamic_tooltip_lang.ko_kr,
                &row.dynamic_tooltip_lang.fr_fr,
                &row.dynamic_tooltip_lang.de_de,
                &row.dynamic_tooltip_lang.en_cn,
                &row.dynamic_tooltip_lang.en_tw,
                &row.dynamic_tooltip_lang.es_es,
                &row.dynamic_tooltip_lang.es_mx,
                &row.dynamic_tooltip_lang.ru_ru,
                &row.dynamic_tooltip_lang.ja_jp,
                &row.dynamic_tooltip_lang.pt_pt,
                &row.dynamic_tooltip_lang.it_it,
                &row.dynamic_tooltip_lang.unknown_12,
                &row.dynamic_tooltip_lang.unknown_13,
                &row.dynamic_tooltip_lang.unknown_14,
                &row.dynamic_tooltip_lang.unknown_15,
                &row.dynamic_tooltip_lang.flags,
                &row.extended_u_i,
                row.extended_u_i_state_variable[0],
                row.extended_u_i_state_variable[1],
                row.extended_u_i_state_variable[2],
                ])?;
            }
        }
        "WorldStateZoneSounds.dbc" => {
            let data = world_state_zone_sounds::WorldStateZoneSounds::read(file_contents)?;
            let (table, insert, _select) = WorldStateZoneSounds();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.world_state_id,
                row.world_state_value,
                row.area_id.id,
                row.w_m_o_area_id.id,
                row.zone_intro_music_id.id,
                row.zone_music_id.id,
                row.sound_ambience_id.id,
                row.sound_provider_preferences_id.id,
                ])?;
            }
        }
        "WowError_Strings.dbc" => {
            let data = wow_error_strings::WowError_Strings::read(file_contents)?;
            let (table, insert, _select) = WowError_Strings();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                &row.description_lang.en_gb,
                &row.description_lang.ko_kr,
                &row.description_lang.fr_fr,
                &row.description_lang.de_de,
                &row.description_lang.en_cn,
                &row.description_lang.en_tw,
                &row.description_lang.es_es,
                &row.description_lang.es_mx,
                &row.description_lang.ru_ru,
                &row.description_lang.ja_jp,
                &row.description_lang.pt_pt,
                &row.description_lang.it_it,
                &row.description_lang.unknown_12,
                &row.description_lang.unknown_13,
                &row.description_lang.unknown_14,
                &row.description_lang.unknown_15,
                &row.description_lang.flags,
                ])?;
            }
        }
        "ZoneIntroMusicTable.dbc" => {
            let data = zone_intro_music_table::ZoneIntroMusicTable::read(file_contents)?;
            let (table, insert, _select) = ZoneIntroMusicTable();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.name,
                row.sound_id.id,
                row.priority,
                row.min_delay_minutes,
                ])?;
            }
        }
        "ZoneMusic.dbc" => {
            let data = zone_music::ZoneMusic::read(file_contents)?;
            let (table, insert, _select) = ZoneMusic();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                &row.set_name,
                row.silence_interval_min[0],
                row.silence_interval_min[1],
                row.silence_interval_max[0],
                row.silence_interval_max[1],
                row.sounds[0],
                row.sounds[1],
                ])?;
            }
        }
        "gtBarberShopCostBase.dbc" => {
            let data = gt_barber_shop_cost_base::gtBarberShopCostBase::read(file_contents)?;
            let (table, insert, _select) = gtBarberShopCostBase();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtChanceToMeleeCrit.dbc" => {
            let data = gt_chance_to_melee_crit::gtChanceToMeleeCrit::read(file_contents)?;
            let (table, insert, _select) = gtChanceToMeleeCrit();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtChanceToMeleeCritBase.dbc" => {
            let data = gt_chance_to_melee_crit_base::gtChanceToMeleeCritBase::read(file_contents)?;
            let (table, insert, _select) = gtChanceToMeleeCritBase();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtChanceToSpellCrit.dbc" => {
            let data = gt_chance_to_spell_crit::gtChanceToSpellCrit::read(file_contents)?;
            let (table, insert, _select) = gtChanceToSpellCrit();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtChanceToSpellCritBase.dbc" => {
            let data = gt_chance_to_spell_crit_base::gtChanceToSpellCritBase::read(file_contents)?;
            let (table, insert, _select) = gtChanceToSpellCritBase();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtCombatRatings.dbc" => {
            let data = gt_combat_ratings::gtCombatRatings::read(file_contents)?;
            let (table, insert, _select) = gtCombatRatings();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtNPCManaCostScaler.dbc" => {
            let data = gt_npc_mana_cost_scaler::gtNPCManaCostScaler::read(file_contents)?;
            let (table, insert, _select) = gtNPCManaCostScaler();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtOCTClassCombatRatingScalar.dbc" => {
            let data = gt_oct_class_combat_rating_scalar::gtOCTClassCombatRatingScalar::read(file_contents)?;
            let (table, insert, _select) = gtOCTClassCombatRatingScalar();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.id.id,
                row.data,
                ])?;
            }
        }
        "gtOCTRegenHP.dbc" => {
            let data = gt_oct_regen_hp::gtOCTRegenHP::read(file_contents)?;
            let (table, insert, _select) = gtOCTRegenHP();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtOCTRegenMP.dbc" => {
            let data = gt_oct_regen_mp::gtOCTRegenMP::read(file_contents)?;
            let (table, insert, _select) = gtOCTRegenMP();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtRegenHPPerSpt.dbc" => {
            let data = gt_regen_hp_per_spt::gtRegenHPPerSpt::read(file_contents)?;
            let (table, insert, _select) = gtRegenHPPerSpt();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        "gtRegenMPPerSpt.dbc" => {
            let data = gt_regen_mp_per_spt::gtRegenMPPerSpt::read(file_contents)?;
            let (table, insert, _select) = gtRegenMPPerSpt();
            tx.execute(table, ())?;

            for row in data.rows() {
                tx.execute(insert, params![
                row.data,
                ])?;
            }
        }
        v => return Err(SqliteError::FilenameNotFound { name: v.to_string() }),
    }

    tx.commit()?;

    Ok(())
}
#[allow(non_snake_case)]
pub(crate) fn Achievement() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Achievement (
        id INTEGER PRIMARY KEY NOT NULL,
        faction INTEGER  NOT NULL,
        instance_id INTEGER  NOT NULL,
        supercedes INTEGER  NOT NULL,
        title_lang_en_gb TEXT NOT NULL,
        title_lang_ko_kr TEXT NOT NULL,
        title_lang_fr_fr TEXT NOT NULL,
        title_lang_de_de TEXT NOT NULL,
        title_lang_en_cn TEXT NOT NULL,
        title_lang_en_tw TEXT NOT NULL,
        title_lang_es_es TEXT NOT NULL,
        title_lang_es_mx TEXT NOT NULL,
        title_lang_ru_ru TEXT NOT NULL,
        title_lang_ja_jp TEXT NOT NULL,
        title_lang_pt_pt TEXT NOT NULL,
        title_lang_it_it TEXT NOT NULL,
        title_lang_unknown_12 TEXT NOT NULL,
        title_lang_unknown_13 TEXT NOT NULL,
        title_lang_unknown_14 TEXT NOT NULL,
        title_lang_unknown_15 TEXT NOT NULL,
        title_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        category INTEGER  NOT NULL,
        points INTEGER  NOT NULL,
        ui_order INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        icon_id INTEGER  NOT NULL,
        reward_lang_en_gb TEXT NOT NULL,
        reward_lang_ko_kr TEXT NOT NULL,
        reward_lang_fr_fr TEXT NOT NULL,
        reward_lang_de_de TEXT NOT NULL,
        reward_lang_en_cn TEXT NOT NULL,
        reward_lang_en_tw TEXT NOT NULL,
        reward_lang_es_es TEXT NOT NULL,
        reward_lang_es_mx TEXT NOT NULL,
        reward_lang_ru_ru TEXT NOT NULL,
        reward_lang_ja_jp TEXT NOT NULL,
        reward_lang_pt_pt TEXT NOT NULL,
        reward_lang_it_it TEXT NOT NULL,
        reward_lang_unknown_12 TEXT NOT NULL,
        reward_lang_unknown_13 TEXT NOT NULL,
        reward_lang_unknown_14 TEXT NOT NULL,
        reward_lang_unknown_15 TEXT NOT NULL,
        reward_lang_flags INTEGER NOT NULL,
        minimum_criteria INTEGER  NOT NULL,
        shares_criteria INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Achievement (
        id,
        faction,
        instance_id,
        supercedes,
        title_lang_en_gb,
        title_lang_ko_kr,
        title_lang_fr_fr,
        title_lang_de_de,
        title_lang_en_cn,
        title_lang_en_tw,
        title_lang_es_es,
        title_lang_es_mx,
        title_lang_ru_ru,
        title_lang_ja_jp,
        title_lang_pt_pt,
        title_lang_it_it,
        title_lang_unknown_12,
        title_lang_unknown_13,
        title_lang_unknown_14,
        title_lang_unknown_15,
        title_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        category,
        points,
        ui_order,
        flags,
        icon_id,
        reward_lang_en_gb,
        reward_lang_ko_kr,
        reward_lang_fr_fr,
        reward_lang_de_de,
        reward_lang_en_cn,
        reward_lang_en_tw,
        reward_lang_es_es,
        reward_lang_es_mx,
        reward_lang_ru_ru,
        reward_lang_ja_jp,
        reward_lang_pt_pt,
        reward_lang_it_it,
        reward_lang_unknown_12,
        reward_lang_unknown_13,
        reward_lang_unknown_14,
        reward_lang_unknown_15,
        reward_lang_flags,
        minimum_criteria,
        shares_criteria
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62
    );"
    ,
    "SELECT
        id,
        faction,
        instance_id,
        supercedes,
        title_lang_en_gb,
        title_lang_ko_kr,
        title_lang_fr_fr,
        title_lang_de_de,
        title_lang_en_cn,
        title_lang_en_tw,
        title_lang_es_es,
        title_lang_es_mx,
        title_lang_ru_ru,
        title_lang_ja_jp,
        title_lang_pt_pt,
        title_lang_it_it,
        title_lang_unknown_12,
        title_lang_unknown_13,
        title_lang_unknown_14,
        title_lang_unknown_15,
        title_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        category,
        points,
        ui_order,
        flags,
        icon_id,
        reward_lang_en_gb,
        reward_lang_ko_kr,
        reward_lang_fr_fr,
        reward_lang_de_de,
        reward_lang_en_cn,
        reward_lang_en_tw,
        reward_lang_es_es,
        reward_lang_es_mx,
        reward_lang_ru_ru,
        reward_lang_ja_jp,
        reward_lang_pt_pt,
        reward_lang_it_it,
        reward_lang_unknown_12,
        reward_lang_unknown_13,
        reward_lang_unknown_14,
        reward_lang_unknown_15,
        reward_lang_flags,
        minimum_criteria,
        shares_criteria
    FROM `Achievement`;"
    )
}


pub(crate) fn achievement_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<achievement::Achievement, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(achievement::AchievementRow {
            id: row.get::<_, i32>(0)?.into(),
            faction: row.get::<_, i32>(1)?.into(),
            instance_id: row.get::<_, i32>(2)?.into(),
            supercedes: row.get::<_, i32>(3)?.into(),
            title_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(4)?.into(),
                ko_kr: row.get::<_, String>(5)?.into(),
                fr_fr: row.get::<_, String>(6)?.into(),
                de_de: row.get::<_, String>(7)?.into(),
                en_cn: row.get::<_, String>(8)?.into(),
                en_tw: row.get::<_, String>(9)?.into(),
                es_es: row.get::<_, String>(10)?.into(),
                es_mx: row.get::<_, String>(11)?.into(),
                ru_ru: row.get::<_, String>(12)?.into(),
                ja_jp: row.get::<_, String>(13)?.into(),
                pt_pt: row.get::<_, String>(14)?.into(),
                it_it: row.get::<_, String>(15)?.into(),
                unknown_12: row.get::<_, String>(16)?.into(),
                unknown_13: row.get::<_, String>(17)?.into(),
                unknown_14: row.get::<_, String>(18)?.into(),
                unknown_15: row.get::<_, String>(19)?.into(),
                flags: row.get::<_, u32>(20)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(21)?.into(),
                ko_kr: row.get::<_, String>(22)?.into(),
                fr_fr: row.get::<_, String>(23)?.into(),
                de_de: row.get::<_, String>(24)?.into(),
                en_cn: row.get::<_, String>(25)?.into(),
                en_tw: row.get::<_, String>(26)?.into(),
                es_es: row.get::<_, String>(27)?.into(),
                es_mx: row.get::<_, String>(28)?.into(),
                ru_ru: row.get::<_, String>(29)?.into(),
                ja_jp: row.get::<_, String>(30)?.into(),
                pt_pt: row.get::<_, String>(31)?.into(),
                it_it: row.get::<_, String>(32)?.into(),
                unknown_12: row.get::<_, String>(33)?.into(),
                unknown_13: row.get::<_, String>(34)?.into(),
                unknown_14: row.get::<_, String>(35)?.into(),
                unknown_15: row.get::<_, String>(36)?.into(),
                flags: row.get::<_, u32>(37)?.into(),
            },
            category: row.get::<_, i32>(38)?.into(),
            points: row.get::<_, i32>(39)?.into(),
            ui_order: row.get::<_, i32>(40)?.into(),
            flags: row.get::<_, i32>(41)?.into(),
            icon_id: row.get::<_, i32>(42)?.into(),
            reward_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(43)?.into(),
                ko_kr: row.get::<_, String>(44)?.into(),
                fr_fr: row.get::<_, String>(45)?.into(),
                de_de: row.get::<_, String>(46)?.into(),
                en_cn: row.get::<_, String>(47)?.into(),
                en_tw: row.get::<_, String>(48)?.into(),
                es_es: row.get::<_, String>(49)?.into(),
                es_mx: row.get::<_, String>(50)?.into(),
                ru_ru: row.get::<_, String>(51)?.into(),
                ja_jp: row.get::<_, String>(52)?.into(),
                pt_pt: row.get::<_, String>(53)?.into(),
                it_it: row.get::<_, String>(54)?.into(),
                unknown_12: row.get::<_, String>(55)?.into(),
                unknown_13: row.get::<_, String>(56)?.into(),
                unknown_14: row.get::<_, String>(57)?.into(),
                unknown_15: row.get::<_, String>(58)?.into(),
                flags: row.get::<_, u32>(59)?.into(),
            },
            minimum_criteria: row.get::<_, i32>(60)?.into(),
            shares_criteria: row.get::<_, i32>(61)?.into(),
        });
    }
    Ok(achievement::Achievement { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Achievement_Category() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Achievement_Category (
        id INTEGER PRIMARY KEY NOT NULL,
        parent INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        ui_order INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Achievement_Category (
        id,
        parent,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        ui_order
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        parent,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        ui_order
    FROM `Achievement_Category`;"
    )
}


pub(crate) fn achievement_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<achievement_category::Achievement_Category, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(achievement_category::Achievement_CategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            parent: row.get::<_, i32>(1)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
            ui_order: row.get::<_, i32>(19)?.into(),
        });
    }
    Ok(achievement_category::Achievement_Category { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Achievement_Criteria() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Achievement_Criteria (
        id INTEGER PRIMARY KEY NOT NULL,
        achievement_id INTEGER  NOT NULL,
        ty INTEGER  NOT NULL,
        asset_id INTEGER  NOT NULL,
        quantity INTEGER  NOT NULL,
        start_event INTEGER  NOT NULL,
        start_asset INTEGER  NOT NULL,
        fail_event INTEGER  NOT NULL,
        fail_asset INTEGER  NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        flags INTEGER  NOT NULL,
        timer_start_event INTEGER  NOT NULL,
        timer_asset_id INTEGER  NOT NULL,
        timer_time INTEGER  NOT NULL,
        ui_order INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Achievement_Criteria (
        id,
        achievement_id,
        ty,
        asset_id,
        quantity,
        start_event,
        start_asset,
        fail_event,
        fail_asset,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        flags,
        timer_start_event,
        timer_asset_id,
        timer_time,
        ui_order
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31
    );"
    ,
    "SELECT
        id,
        achievement_id,
        ty,
        asset_id,
        quantity,
        start_event,
        start_asset,
        fail_event,
        fail_asset,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        flags,
        timer_start_event,
        timer_asset_id,
        timer_time,
        ui_order
    FROM `Achievement_Criteria`;"
    )
}


pub(crate) fn achievement_criteria_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<achievement_criteria::Achievement_Criteria, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(achievement_criteria::Achievement_CriteriaRow {
            id: row.get::<_, i32>(0)?.into(),
            achievement_id: row.get::<_, i32>(1)?.into(),
            ty: row.get::<_, i32>(2)?.into(),
            asset_id: row.get::<_, i32>(3)?.into(),
            quantity: row.get::<_, i32>(4)?.into(),
            start_event: row.get::<_, i32>(5)?.into(),
            start_asset: row.get::<_, i32>(6)?.into(),
            fail_event: row.get::<_, i32>(7)?.into(),
            fail_asset: row.get::<_, i32>(8)?.into(),
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(9)?.into(),
                ko_kr: row.get::<_, String>(10)?.into(),
                fr_fr: row.get::<_, String>(11)?.into(),
                de_de: row.get::<_, String>(12)?.into(),
                en_cn: row.get::<_, String>(13)?.into(),
                en_tw: row.get::<_, String>(14)?.into(),
                es_es: row.get::<_, String>(15)?.into(),
                es_mx: row.get::<_, String>(16)?.into(),
                ru_ru: row.get::<_, String>(17)?.into(),
                ja_jp: row.get::<_, String>(18)?.into(),
                pt_pt: row.get::<_, String>(19)?.into(),
                it_it: row.get::<_, String>(20)?.into(),
                unknown_12: row.get::<_, String>(21)?.into(),
                unknown_13: row.get::<_, String>(22)?.into(),
                unknown_14: row.get::<_, String>(23)?.into(),
                unknown_15: row.get::<_, String>(24)?.into(),
                flags: row.get::<_, u32>(25)?.into(),
            },
            flags: row.get::<_, i32>(26)?.into(),
            timer_start_event: row.get::<_, i32>(27)?.into(),
            timer_asset_id: row.get::<_, i32>(28)?.into(),
            timer_time: row.get::<_, i32>(29)?.into(),
            ui_order: row.get::<_, i32>(30)?.into(),
        });
    }
    Ok(achievement_criteria::Achievement_Criteria { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AnimationData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AnimationData (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        weaponflags INTEGER  NOT NULL,
        bodyflags INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        fallback INTEGER  NOT NULL,
        behavior_id INTEGER  NOT NULL,
        behavior_tier INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO AnimationData (
        id,
        name,
        weaponflags,
        bodyflags,
        flags,
        fallback,
        behavior_id,
        behavior_tier
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        name,
        weaponflags,
        bodyflags,
        flags,
        fallback,
        behavior_id,
        behavior_tier
    FROM `AnimationData`;"
    )
}


pub(crate) fn animation_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<animation_data::AnimationData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(animation_data::AnimationDataRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            weaponflags: row.get::<_, i32>(2)?.into(),
            bodyflags: row.get::<_, i32>(3)?.into(),
            flags: row.get::<_, i32>(4)?.into(),
            fallback: row.get::<_, i32>(5)?.into(),
            behavior_id: row.get::<_, i32>(6)?.into(),
            behavior_tier: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(animation_data::AnimationData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AreaGroup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AreaGroup (
        id INTEGER PRIMARY KEY NOT NULL,
        area_id_0 INTEGER NOT NULL,
        area_id_1 INTEGER NOT NULL,
        area_id_2 INTEGER NOT NULL,
        area_id_3 INTEGER NOT NULL,
        area_id_4 INTEGER NOT NULL,
        area_id_5 INTEGER NOT NULL,
        next_area_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO AreaGroup (
        id,
        area_id_0,
        area_id_1,
        area_id_2,
        area_id_3,
        area_id_4,
        area_id_5,
        next_area_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        area_id_0,
        area_id_1,
        area_id_2,
        area_id_3,
        area_id_4,
        area_id_5,
        next_area_id
    FROM `AreaGroup`;"
    )
}


pub(crate) fn area_group_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<area_group::AreaGroup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(area_group::AreaGroupRow {
            id: row.get::<_, i32>(0)?.into(),
            area_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
            next_area_id: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(area_group::AreaGroup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AreaPOI() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AreaPOI (
        id INTEGER PRIMARY KEY NOT NULL,
        importance INTEGER  NOT NULL,
        icon_0 INTEGER NOT NULL,
        icon_1 INTEGER NOT NULL,
        icon_2 INTEGER NOT NULL,
        icon_3 INTEGER NOT NULL,
        icon_4 INTEGER NOT NULL,
        icon_5 INTEGER NOT NULL,
        icon_6 INTEGER NOT NULL,
        icon_7 INTEGER NOT NULL,
        icon_8 INTEGER NOT NULL,
        faction_id INTEGER  NOT NULL,
        pos_0 REAL NOT NULL,
        pos_1 REAL NOT NULL,
        pos_2 REAL NOT NULL,
        continent_id INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        area_id INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        world_state_id INTEGER  NOT NULL,
        world_map_link INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO AreaPOI (
        id,
        importance,
        icon_0,
        icon_1,
        icon_2,
        icon_3,
        icon_4,
        icon_5,
        icon_6,
        icon_7,
        icon_8,
        faction_id,
        pos_0,
        pos_1,
        pos_2,
        continent_id,
        flags,
        area_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        world_state_id,
        world_map_link
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54
    );"
    ,
    "SELECT
        id,
        importance,
        icon_0,
        icon_1,
        icon_2,
        icon_3,
        icon_4,
        icon_5,
        icon_6,
        icon_7,
        icon_8,
        faction_id,
        pos_0,
        pos_1,
        pos_2,
        continent_id,
        flags,
        area_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        world_state_id,
        world_map_link
    FROM `AreaPOI`;"
    )
}


pub(crate) fn area_poi_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<area_poi::AreaPOI, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(area_poi::AreaPOIRow {
            id: row.get::<_, i32>(0)?.into(),
            importance: row.get::<_, i32>(1)?.into(),
            icon: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            faction_id: row.get::<_, i32>(11)?.into(),
            pos: [row.get::<_, f32>(12)?.into(), row.get::<_, f32>(13)?.into(), row.get::<_, f32>(14)?.into(),             ],
            continent_id: row.get::<_, i32>(15)?.into(),
            flags: row.get::<_, i32>(16)?.into(),
            area_id: row.get::<_, i32>(17)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(18)?.into(),
                ko_kr: row.get::<_, String>(19)?.into(),
                fr_fr: row.get::<_, String>(20)?.into(),
                de_de: row.get::<_, String>(21)?.into(),
                en_cn: row.get::<_, String>(22)?.into(),
                en_tw: row.get::<_, String>(23)?.into(),
                es_es: row.get::<_, String>(24)?.into(),
                es_mx: row.get::<_, String>(25)?.into(),
                ru_ru: row.get::<_, String>(26)?.into(),
                ja_jp: row.get::<_, String>(27)?.into(),
                pt_pt: row.get::<_, String>(28)?.into(),
                it_it: row.get::<_, String>(29)?.into(),
                unknown_12: row.get::<_, String>(30)?.into(),
                unknown_13: row.get::<_, String>(31)?.into(),
                unknown_14: row.get::<_, String>(32)?.into(),
                unknown_15: row.get::<_, String>(33)?.into(),
                flags: row.get::<_, u32>(34)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(35)?.into(),
                ko_kr: row.get::<_, String>(36)?.into(),
                fr_fr: row.get::<_, String>(37)?.into(),
                de_de: row.get::<_, String>(38)?.into(),
                en_cn: row.get::<_, String>(39)?.into(),
                en_tw: row.get::<_, String>(40)?.into(),
                es_es: row.get::<_, String>(41)?.into(),
                es_mx: row.get::<_, String>(42)?.into(),
                ru_ru: row.get::<_, String>(43)?.into(),
                ja_jp: row.get::<_, String>(44)?.into(),
                pt_pt: row.get::<_, String>(45)?.into(),
                it_it: row.get::<_, String>(46)?.into(),
                unknown_12: row.get::<_, String>(47)?.into(),
                unknown_13: row.get::<_, String>(48)?.into(),
                unknown_14: row.get::<_, String>(49)?.into(),
                unknown_15: row.get::<_, String>(50)?.into(),
                flags: row.get::<_, u32>(51)?.into(),
            },
            world_state_id: row.get::<_, i32>(52)?.into(),
            world_map_link: row.get::<_, i32>(53)?.into(),
        });
    }
    Ok(area_poi::AreaPOI { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AreaTable() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AreaTable (
        id INTEGER PRIMARY KEY NOT NULL,
        continent_id INTEGER  NOT NULL,
        parent_area_id INTEGER  NOT NULL,
        area_bit INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        sound_provider_pref INTEGER  NOT NULL,
        sound_provider_pref_underwater INTEGER  NOT NULL,
        ambience_id INTEGER  NOT NULL,
        zone_music INTEGER  NOT NULL,
        intro_sound INTEGER  NOT NULL,
        exploration_level INTEGER  NOT NULL,
        area_name_lang_en_gb TEXT NOT NULL,
        area_name_lang_ko_kr TEXT NOT NULL,
        area_name_lang_fr_fr TEXT NOT NULL,
        area_name_lang_de_de TEXT NOT NULL,
        area_name_lang_en_cn TEXT NOT NULL,
        area_name_lang_en_tw TEXT NOT NULL,
        area_name_lang_es_es TEXT NOT NULL,
        area_name_lang_es_mx TEXT NOT NULL,
        area_name_lang_ru_ru TEXT NOT NULL,
        area_name_lang_ja_jp TEXT NOT NULL,
        area_name_lang_pt_pt TEXT NOT NULL,
        area_name_lang_it_it TEXT NOT NULL,
        area_name_lang_unknown_12 TEXT NOT NULL,
        area_name_lang_unknown_13 TEXT NOT NULL,
        area_name_lang_unknown_14 TEXT NOT NULL,
        area_name_lang_unknown_15 TEXT NOT NULL,
        area_name_lang_flags INTEGER NOT NULL,
        faction_group_mask INTEGER  NOT NULL,
        liquid_type_id_0 INTEGER NOT NULL,
        liquid_type_id_1 INTEGER NOT NULL,
        liquid_type_id_2 INTEGER NOT NULL,
        liquid_type_id_3 INTEGER NOT NULL,
        min_elevation REAL  NOT NULL,
        ambient_multiplier REAL  NOT NULL,
        light_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO AreaTable (
        id,
        continent_id,
        parent_area_id,
        area_bit,
        flags,
        sound_provider_pref,
        sound_provider_pref_underwater,
        ambience_id,
        zone_music,
        intro_sound,
        exploration_level,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags,
        faction_group_mask,
        liquid_type_id_0,
        liquid_type_id_1,
        liquid_type_id_2,
        liquid_type_id_3,
        min_elevation,
        ambient_multiplier,
        light_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36
    );"
    ,
    "SELECT
        id,
        continent_id,
        parent_area_id,
        area_bit,
        flags,
        sound_provider_pref,
        sound_provider_pref_underwater,
        ambience_id,
        zone_music,
        intro_sound,
        exploration_level,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags,
        faction_group_mask,
        liquid_type_id_0,
        liquid_type_id_1,
        liquid_type_id_2,
        liquid_type_id_3,
        min_elevation,
        ambient_multiplier,
        light_id
    FROM `AreaTable`;"
    )
}


pub(crate) fn area_table_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<area_table::AreaTable, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(area_table::AreaTableRow {
            id: row.get::<_, i32>(0)?.into(),
            continent_id: row.get::<_, i32>(1)?.into(),
            parent_area_id: row.get::<_, i32>(2)?.into(),
            area_bit: row.get::<_, i32>(3)?.into(),
            flags: row.get::<_, i32>(4)?.into(),
            sound_provider_pref: row.get::<_, i32>(5)?.into(),
            sound_provider_pref_underwater: row.get::<_, i32>(6)?.into(),
            ambience_id: row.get::<_, i32>(7)?.into(),
            zone_music: row.get::<_, i32>(8)?.into(),
            intro_sound: row.get::<_, i32>(9)?.into(),
            exploration_level: row.get::<_, i32>(10)?.into(),
            area_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(11)?.into(),
                ko_kr: row.get::<_, String>(12)?.into(),
                fr_fr: row.get::<_, String>(13)?.into(),
                de_de: row.get::<_, String>(14)?.into(),
                en_cn: row.get::<_, String>(15)?.into(),
                en_tw: row.get::<_, String>(16)?.into(),
                es_es: row.get::<_, String>(17)?.into(),
                es_mx: row.get::<_, String>(18)?.into(),
                ru_ru: row.get::<_, String>(19)?.into(),
                ja_jp: row.get::<_, String>(20)?.into(),
                pt_pt: row.get::<_, String>(21)?.into(),
                it_it: row.get::<_, String>(22)?.into(),
                unknown_12: row.get::<_, String>(23)?.into(),
                unknown_13: row.get::<_, String>(24)?.into(),
                unknown_14: row.get::<_, String>(25)?.into(),
                unknown_15: row.get::<_, String>(26)?.into(),
                flags: row.get::<_, u32>(27)?.into(),
            },
            faction_group_mask: row.get::<_, i32>(28)?.into(),
            liquid_type_id: [row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(),             ],
            min_elevation: row.get::<_, f32>(33)?.into(),
            ambient_multiplier: row.get::<_, f32>(34)?.into(),
            light_id: row.get::<_, i32>(35)?.into(),
        });
    }
    Ok(area_table::AreaTable { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AreaTrigger() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AreaTrigger (
        id INTEGER PRIMARY KEY NOT NULL,
        continent_id INTEGER  NOT NULL,
        pos_0 REAL NOT NULL,
        pos_1 REAL NOT NULL,
        pos_2 REAL NOT NULL,
        radius REAL  NOT NULL,
        box_length REAL  NOT NULL,
        box_width REAL  NOT NULL,
        box_height REAL  NOT NULL,
        box_yaw REAL  NOT NULL
    );"
    ,
    "INSERT INTO AreaTrigger (
        id,
        continent_id,
        pos_0,
        pos_1,
        pos_2,
        radius,
        box_length,
        box_width,
        box_height,
        box_yaw
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        continent_id,
        pos_0,
        pos_1,
        pos_2,
        radius,
        box_length,
        box_width,
        box_height,
        box_yaw
    FROM `AreaTrigger`;"
    )
}


pub(crate) fn area_trigger_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<area_trigger::AreaTrigger, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(area_trigger::AreaTriggerRow {
            id: row.get::<_, i32>(0)?.into(),
            continent_id: row.get::<_, i32>(1)?.into(),
            pos: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(),             ],
            radius: row.get::<_, f32>(5)?.into(),
            box_length: row.get::<_, f32>(6)?.into(),
            box_width: row.get::<_, f32>(7)?.into(),
            box_height: row.get::<_, f32>(8)?.into(),
            box_yaw: row.get::<_, f32>(9)?.into(),
        });
    }
    Ok(area_trigger::AreaTrigger { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AttackAnimKits() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AttackAnimKits (
        id INTEGER PRIMARY KEY NOT NULL,
        item_subclass_id INTEGER  NOT NULL,
        anim_type_id INTEGER  NOT NULL,
        anim_frequency INTEGER  NOT NULL,
        which_hand INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO AttackAnimKits (
        id,
        item_subclass_id,
        anim_type_id,
        anim_frequency,
        which_hand
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        item_subclass_id,
        anim_type_id,
        anim_frequency,
        which_hand
    FROM `AttackAnimKits`;"
    )
}


pub(crate) fn attack_anim_kits_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<attack_anim_kits::AttackAnimKits, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(attack_anim_kits::AttackAnimKitsRow {
            id: row.get::<_, i32>(0)?.into(),
            item_subclass_id: row.get::<_, i32>(1)?.into(),
            anim_type_id: row.get::<_, i32>(2)?.into(),
            anim_frequency: row.get::<_, i32>(3)?.into(),
            which_hand: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(attack_anim_kits::AttackAnimKits { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AttackAnimTypes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AttackAnimTypes (
        anim_id INTEGER  NOT NULL,
        anim_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO AttackAnimTypes (
        anim_id,
        anim_name
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        anim_id,
        anim_name
    FROM `AttackAnimTypes`;"
    )
}


pub(crate) fn attack_anim_types_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<attack_anim_types::AttackAnimTypes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(attack_anim_types::AttackAnimTypesRow {
            anim_id: row.get::<_, i32>(0)?.into(),
            anim_name: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(attack_anim_types::AttackAnimTypes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn AuctionHouse() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS AuctionHouse (
        id INTEGER PRIMARY KEY NOT NULL,
        faction_id INTEGER  NOT NULL,
        deposit_rate INTEGER  NOT NULL,
        consignment_rate INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO AuctionHouse (
        id,
        faction_id,
        deposit_rate,
        consignment_rate,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21
    );"
    ,
    "SELECT
        id,
        faction_id,
        deposit_rate,
        consignment_rate,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `AuctionHouse`;"
    )
}


pub(crate) fn auction_house_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<auction_house::AuctionHouse, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(auction_house::AuctionHouseRow {
            id: row.get::<_, i32>(0)?.into(),
            faction_id: row.get::<_, i32>(1)?.into(),
            deposit_rate: row.get::<_, i32>(2)?.into(),
            consignment_rate: row.get::<_, i32>(3)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(4)?.into(),
                ko_kr: row.get::<_, String>(5)?.into(),
                fr_fr: row.get::<_, String>(6)?.into(),
                de_de: row.get::<_, String>(7)?.into(),
                en_cn: row.get::<_, String>(8)?.into(),
                en_tw: row.get::<_, String>(9)?.into(),
                es_es: row.get::<_, String>(10)?.into(),
                es_mx: row.get::<_, String>(11)?.into(),
                ru_ru: row.get::<_, String>(12)?.into(),
                ja_jp: row.get::<_, String>(13)?.into(),
                pt_pt: row.get::<_, String>(14)?.into(),
                it_it: row.get::<_, String>(15)?.into(),
                unknown_12: row.get::<_, String>(16)?.into(),
                unknown_13: row.get::<_, String>(17)?.into(),
                unknown_14: row.get::<_, String>(18)?.into(),
                unknown_15: row.get::<_, String>(19)?.into(),
                flags: row.get::<_, u32>(20)?.into(),
            },
        });
    }
    Ok(auction_house::AuctionHouse { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn BankBagSlotPrices() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS BankBagSlotPrices (
        id INTEGER PRIMARY KEY NOT NULL,
        cost INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO BankBagSlotPrices (
        id,
        cost
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        cost
    FROM `BankBagSlotPrices`;"
    )
}


pub(crate) fn bank_bag_slot_prices_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<bank_bag_slot_prices::BankBagSlotPrices, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(bank_bag_slot_prices::BankBagSlotPricesRow {
            id: row.get::<_, i32>(0)?.into(),
            cost: row.get::<_, i32>(1)?.into(),
        });
    }
    Ok(bank_bag_slot_prices::BankBagSlotPrices { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn BannedAddOns() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS BannedAddOns (
        id INTEGER PRIMARY KEY NOT NULL,
        name_m_d5_0 INTEGER NOT NULL,
        name_m_d5_1 INTEGER NOT NULL,
        name_m_d5_2 INTEGER NOT NULL,
        name_m_d5_3 INTEGER NOT NULL,
        version_m_d5_0 INTEGER NOT NULL,
        version_m_d5_1 INTEGER NOT NULL,
        version_m_d5_2 INTEGER NOT NULL,
        version_m_d5_3 INTEGER NOT NULL,
        last_modified INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO BannedAddOns (
        id,
        name_m_d5_0,
        name_m_d5_1,
        name_m_d5_2,
        name_m_d5_3,
        version_m_d5_0,
        version_m_d5_1,
        version_m_d5_2,
        version_m_d5_3,
        last_modified,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        name_m_d5_0,
        name_m_d5_1,
        name_m_d5_2,
        name_m_d5_3,
        version_m_d5_0,
        version_m_d5_1,
        version_m_d5_2,
        version_m_d5_3,
        last_modified,
        flags
    FROM `BannedAddOns`;"
    )
}


pub(crate) fn banned_add_ons_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<banned_add_ons::BannedAddOns, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(banned_add_ons::BannedAddOnsRow {
            id: row.get::<_, i32>(0)?.into(),
            name_m_d5: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            version_m_d5: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            last_modified: row.get::<_, i32>(9)?.into(),
            flags: row.get::<_, i32>(10)?.into(),
        });
    }
    Ok(banned_add_ons::BannedAddOns { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn BarberShopStyle() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS BarberShopStyle (
        id INTEGER PRIMARY KEY NOT NULL,
        ty INTEGER  NOT NULL,
        display_name_lang_en_gb TEXT NOT NULL,
        display_name_lang_ko_kr TEXT NOT NULL,
        display_name_lang_fr_fr TEXT NOT NULL,
        display_name_lang_de_de TEXT NOT NULL,
        display_name_lang_en_cn TEXT NOT NULL,
        display_name_lang_en_tw TEXT NOT NULL,
        display_name_lang_es_es TEXT NOT NULL,
        display_name_lang_es_mx TEXT NOT NULL,
        display_name_lang_ru_ru TEXT NOT NULL,
        display_name_lang_ja_jp TEXT NOT NULL,
        display_name_lang_pt_pt TEXT NOT NULL,
        display_name_lang_it_it TEXT NOT NULL,
        display_name_lang_unknown_12 TEXT NOT NULL,
        display_name_lang_unknown_13 TEXT NOT NULL,
        display_name_lang_unknown_14 TEXT NOT NULL,
        display_name_lang_unknown_15 TEXT NOT NULL,
        display_name_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        cost_modifier REAL  NOT NULL,
        race INTEGER  NOT NULL,
        sex INTEGER  NOT NULL,
        data INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO BarberShopStyle (
        id,
        ty,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        cost_modifier,
        race,
        sex,
        data
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40
    );"
    ,
    "SELECT
        id,
        ty,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        cost_modifier,
        race,
        sex,
        data
    FROM `BarberShopStyle`;"
    )
}


pub(crate) fn barber_shop_style_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<barber_shop_style::BarberShopStyle, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(barber_shop_style::BarberShopStyleRow {
            id: row.get::<_, i32>(0)?.into(),
            ty: row.get::<_, i32>(1)?.into(),
            display_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(19)?.into(),
                ko_kr: row.get::<_, String>(20)?.into(),
                fr_fr: row.get::<_, String>(21)?.into(),
                de_de: row.get::<_, String>(22)?.into(),
                en_cn: row.get::<_, String>(23)?.into(),
                en_tw: row.get::<_, String>(24)?.into(),
                es_es: row.get::<_, String>(25)?.into(),
                es_mx: row.get::<_, String>(26)?.into(),
                ru_ru: row.get::<_, String>(27)?.into(),
                ja_jp: row.get::<_, String>(28)?.into(),
                pt_pt: row.get::<_, String>(29)?.into(),
                it_it: row.get::<_, String>(30)?.into(),
                unknown_12: row.get::<_, String>(31)?.into(),
                unknown_13: row.get::<_, String>(32)?.into(),
                unknown_14: row.get::<_, String>(33)?.into(),
                unknown_15: row.get::<_, String>(34)?.into(),
                flags: row.get::<_, u32>(35)?.into(),
            },
            cost_modifier: row.get::<_, f32>(36)?.into(),
            race: row.get::<_, i32>(37)?.into(),
            sex: row.get::<_, i32>(38)?.into(),
            data: row.get::<_, i32>(39)?.into(),
        });
    }
    Ok(barber_shop_style::BarberShopStyle { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn BattlemasterList() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS BattlemasterList (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id_0 INTEGER NOT NULL,
        map_id_1 INTEGER NOT NULL,
        map_id_2 INTEGER NOT NULL,
        map_id_3 INTEGER NOT NULL,
        map_id_4 INTEGER NOT NULL,
        map_id_5 INTEGER NOT NULL,
        map_id_6 INTEGER NOT NULL,
        map_id_7 INTEGER NOT NULL,
        instance_type INTEGER  NOT NULL,
        groups_allowed INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        max_group_size INTEGER  NOT NULL,
        holiday_world_state INTEGER  NOT NULL,
        min_level INTEGER  NOT NULL,
        max_level INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO BattlemasterList (
        id,
        map_id_0,
        map_id_1,
        map_id_2,
        map_id_3,
        map_id_4,
        map_id_5,
        map_id_6,
        map_id_7,
        instance_type,
        groups_allowed,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        max_group_size,
        holiday_world_state,
        min_level,
        max_level
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32
    );"
    ,
    "SELECT
        id,
        map_id_0,
        map_id_1,
        map_id_2,
        map_id_3,
        map_id_4,
        map_id_5,
        map_id_6,
        map_id_7,
        instance_type,
        groups_allowed,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        max_group_size,
        holiday_world_state,
        min_level,
        max_level
    FROM `BattlemasterList`;"
    )
}


pub(crate) fn battlemaster_list_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<battlemaster_list::BattlemasterList, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(battlemaster_list::BattlemasterListRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            instance_type: row.get::<_, i32>(9)?.into(),
            groups_allowed: row.get::<_, i32>(10)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(11)?.into(),
                ko_kr: row.get::<_, String>(12)?.into(),
                fr_fr: row.get::<_, String>(13)?.into(),
                de_de: row.get::<_, String>(14)?.into(),
                en_cn: row.get::<_, String>(15)?.into(),
                en_tw: row.get::<_, String>(16)?.into(),
                es_es: row.get::<_, String>(17)?.into(),
                es_mx: row.get::<_, String>(18)?.into(),
                ru_ru: row.get::<_, String>(19)?.into(),
                ja_jp: row.get::<_, String>(20)?.into(),
                pt_pt: row.get::<_, String>(21)?.into(),
                it_it: row.get::<_, String>(22)?.into(),
                unknown_12: row.get::<_, String>(23)?.into(),
                unknown_13: row.get::<_, String>(24)?.into(),
                unknown_14: row.get::<_, String>(25)?.into(),
                unknown_15: row.get::<_, String>(26)?.into(),
                flags: row.get::<_, u32>(27)?.into(),
            },
            max_group_size: row.get::<_, i32>(28)?.into(),
            holiday_world_state: row.get::<_, i32>(29)?.into(),
            min_level: row.get::<_, i32>(30)?.into(),
            max_level: row.get::<_, i32>(31)?.into(),
        });
    }
    Ok(battlemaster_list::BattlemasterList { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CameraShakes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CameraShakes (
        id INTEGER PRIMARY KEY NOT NULL,
        shake_type INTEGER  NOT NULL,
        direction INTEGER  NOT NULL,
        amplitude REAL  NOT NULL,
        frequency REAL  NOT NULL,
        duration REAL  NOT NULL,
        phase REAL  NOT NULL,
        coefficient REAL  NOT NULL
    );"
    ,
    "INSERT INTO CameraShakes (
        id,
        shake_type,
        direction,
        amplitude,
        frequency,
        duration,
        phase,
        coefficient
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        shake_type,
        direction,
        amplitude,
        frequency,
        duration,
        phase,
        coefficient
    FROM `CameraShakes`;"
    )
}


pub(crate) fn camera_shakes_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<camera_shakes::CameraShakes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(camera_shakes::CameraShakesRow {
            id: row.get::<_, i32>(0)?.into(),
            shake_type: row.get::<_, i32>(1)?.into(),
            direction: row.get::<_, i32>(2)?.into(),
            amplitude: row.get::<_, f32>(3)?.into(),
            frequency: row.get::<_, f32>(4)?.into(),
            duration: row.get::<_, f32>(5)?.into(),
            phase: row.get::<_, f32>(6)?.into(),
            coefficient: row.get::<_, f32>(7)?.into(),
        });
    }
    Ok(camera_shakes::CameraShakes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Cfg_Categories() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Cfg_Categories (
        id INTEGER PRIMARY KEY NOT NULL,
        locale_mask INTEGER  NOT NULL,
        create_charset_mask INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Cfg_Categories (
        id,
        locale_mask,
        create_charset_mask,
        flags,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21
    );"
    ,
    "SELECT
        id,
        locale_mask,
        create_charset_mask,
        flags,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `Cfg_Categories`;"
    )
}


pub(crate) fn cfg_categories_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<cfg_categories::Cfg_Categories, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(cfg_categories::Cfg_CategoriesRow {
            id: row.get::<_, i32>(0)?.into(),
            locale_mask: row.get::<_, i32>(1)?.into(),
            create_charset_mask: row.get::<_, i32>(2)?.into(),
            flags: row.get::<_, i32>(3)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(4)?.into(),
                ko_kr: row.get::<_, String>(5)?.into(),
                fr_fr: row.get::<_, String>(6)?.into(),
                de_de: row.get::<_, String>(7)?.into(),
                en_cn: row.get::<_, String>(8)?.into(),
                en_tw: row.get::<_, String>(9)?.into(),
                es_es: row.get::<_, String>(10)?.into(),
                es_mx: row.get::<_, String>(11)?.into(),
                ru_ru: row.get::<_, String>(12)?.into(),
                ja_jp: row.get::<_, String>(13)?.into(),
                pt_pt: row.get::<_, String>(14)?.into(),
                it_it: row.get::<_, String>(15)?.into(),
                unknown_12: row.get::<_, String>(16)?.into(),
                unknown_13: row.get::<_, String>(17)?.into(),
                unknown_14: row.get::<_, String>(18)?.into(),
                unknown_15: row.get::<_, String>(19)?.into(),
                flags: row.get::<_, u32>(20)?.into(),
            },
        });
    }
    Ok(cfg_categories::Cfg_Categories { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Cfg_Configs() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Cfg_Configs (
        id INTEGER PRIMARY KEY NOT NULL,
        realm_type INTEGER  NOT NULL,
        player_killing_allowed INTEGER  NOT NULL,
        roleplaying INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Cfg_Configs (
        id,
        realm_type,
        player_killing_allowed,
        roleplaying
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        realm_type,
        player_killing_allowed,
        roleplaying
    FROM `Cfg_Configs`;"
    )
}


pub(crate) fn cfg_configs_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<cfg_configs::Cfg_Configs, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(cfg_configs::Cfg_ConfigsRow {
            id: row.get::<_, i32>(0)?.into(),
            realm_type: row.get::<_, i32>(1)?.into(),
            player_killing_allowed: row.get::<_, i32>(2)?.into(),
            roleplaying: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(cfg_configs::Cfg_Configs { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharBaseInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharBaseInfo (
        race_id INTEGER  NOT NULL,
        class_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CharBaseInfo (
        race_id,
        class_id
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        race_id,
        class_id
    FROM `CharBaseInfo`;"
    )
}


pub(crate) fn char_base_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_base_info::CharBaseInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_base_info::CharBaseInfoRow {
            race_id: row.get::<_, i8>(0)?.into(),
            class_id: row.get::<_, i8>(1)?.into(),
        });
    }
    Ok(char_base_info::CharBaseInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharHairGeosets() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharHairGeosets (
        id INTEGER PRIMARY KEY NOT NULL,
        race_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        variation_id INTEGER  NOT NULL,
        geoset_id INTEGER  NOT NULL,
        showscalp INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CharHairGeosets (
        id,
        race_id,
        sex_id,
        variation_id,
        geoset_id,
        showscalp
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        id,
        race_id,
        sex_id,
        variation_id,
        geoset_id,
        showscalp
    FROM `CharHairGeosets`;"
    )
}


pub(crate) fn char_hair_geosets_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_hair_geosets::CharHairGeosets, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_hair_geosets::CharHairGeosetsRow {
            id: row.get::<_, i32>(0)?.into(),
            race_id: row.get::<_, i32>(1)?.into(),
            sex_id: row.get::<_, i32>(2)?.into(),
            variation_id: row.get::<_, i32>(3)?.into(),
            geoset_id: row.get::<_, i32>(4)?.into(),
            showscalp: row.get::<_, i32>(5)?.into(),
        });
    }
    Ok(char_hair_geosets::CharHairGeosets { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharHairTextures() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharHairTextures (
        id INTEGER PRIMARY KEY NOT NULL,
        field_0_5_3_3368_001_race INTEGER  NOT NULL,
        field_0_5_3_3368_002_gender INTEGER  NOT NULL,
        field_0_5_3_3368_003 INTEGER  NOT NULL,
        field_0_5_3_3368_004_mayberacemask INTEGER  NOT NULL,
        field_0_5_3_3368_005_the_x_in_hair_xy_blp INTEGER  NOT NULL,
        field_0_5_3_3368_006 INTEGER  NOT NULL,
        field_0_5_3_3368_007 INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CharHairTextures (
        id,
        field_0_5_3_3368_001_race,
        field_0_5_3_3368_002_gender,
        field_0_5_3_3368_003,
        field_0_5_3_3368_004_mayberacemask,
        field_0_5_3_3368_005_the_x_in_hair_xy_blp,
        field_0_5_3_3368_006,
        field_0_5_3_3368_007
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        field_0_5_3_3368_001_race,
        field_0_5_3_3368_002_gender,
        field_0_5_3_3368_003,
        field_0_5_3_3368_004_mayberacemask,
        field_0_5_3_3368_005_the_x_in_hair_xy_blp,
        field_0_5_3_3368_006,
        field_0_5_3_3368_007
    FROM `CharHairTextures`;"
    )
}


pub(crate) fn char_hair_textures_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_hair_textures::CharHairTextures, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_hair_textures::CharHairTexturesRow {
            id: row.get::<_, i32>(0)?.into(),
            field_0_5_3_3368_001_race: row.get::<_, i32>(1)?.into(),
            field_0_5_3_3368_002_gender: row.get::<_, i32>(2)?.into(),
            field_0_5_3_3368_003: row.get::<_, i32>(3)?.into(),
            field_0_5_3_3368_004_mayberacemask: row.get::<_, i32>(4)?.into(),
            field_0_5_3_3368_005_the_x_in_hair_xy_blp: row.get::<_, i32>(5)?.into(),
            field_0_5_3_3368_006: row.get::<_, i32>(6)?.into(),
            field_0_5_3_3368_007: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(char_hair_textures::CharHairTextures { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharSections() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharSections (
        id INTEGER PRIMARY KEY NOT NULL,
        race_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        base_section INTEGER  NOT NULL,
        texture_name_0 TEXT NOT NULL,
        texture_name_1 TEXT NOT NULL,
        texture_name_2 TEXT NOT NULL,
        flags INTEGER  NOT NULL,
        variation_index INTEGER  NOT NULL,
        color_index INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CharSections (
        id,
        race_id,
        sex_id,
        base_section,
        texture_name_0,
        texture_name_1,
        texture_name_2,
        flags,
        variation_index,
        color_index
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        race_id,
        sex_id,
        base_section,
        texture_name_0,
        texture_name_1,
        texture_name_2,
        flags,
        variation_index,
        color_index
    FROM `CharSections`;"
    )
}


pub(crate) fn char_sections_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_sections::CharSections, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_sections::CharSectionsRow {
            id: row.get::<_, i32>(0)?.into(),
            race_id: row.get::<_, i32>(1)?.into(),
            sex_id: row.get::<_, i32>(2)?.into(),
            base_section: row.get::<_, i32>(3)?.into(),
            texture_name: [row.get::<_, String>(4)?.into(), row.get::<_, String>(5)?.into(), row.get::<_, String>(6)?.into(),             ],
            flags: row.get::<_, i32>(7)?.into(),
            variation_index: row.get::<_, i32>(8)?.into(),
            color_index: row.get::<_, i32>(9)?.into(),
        });
    }
    Ok(char_sections::CharSections { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharStartOutfit() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharStartOutfit (
        id INTEGER PRIMARY KEY NOT NULL,
        race_id INTEGER  NOT NULL,
        class_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        outfit_id INTEGER  NOT NULL,
        item_id_0 INTEGER NOT NULL,
        item_id_1 INTEGER NOT NULL,
        item_id_2 INTEGER NOT NULL,
        item_id_3 INTEGER NOT NULL,
        item_id_4 INTEGER NOT NULL,
        item_id_5 INTEGER NOT NULL,
        item_id_6 INTEGER NOT NULL,
        item_id_7 INTEGER NOT NULL,
        item_id_8 INTEGER NOT NULL,
        item_id_9 INTEGER NOT NULL,
        item_id_10 INTEGER NOT NULL,
        item_id_11 INTEGER NOT NULL,
        item_id_12 INTEGER NOT NULL,
        item_id_13 INTEGER NOT NULL,
        item_id_14 INTEGER NOT NULL,
        item_id_15 INTEGER NOT NULL,
        item_id_16 INTEGER NOT NULL,
        item_id_17 INTEGER NOT NULL,
        item_id_18 INTEGER NOT NULL,
        item_id_19 INTEGER NOT NULL,
        item_id_20 INTEGER NOT NULL,
        item_id_21 INTEGER NOT NULL,
        item_id_22 INTEGER NOT NULL,
        item_id_23 INTEGER NOT NULL,
        display_item_id_0 INTEGER NOT NULL,
        display_item_id_1 INTEGER NOT NULL,
        display_item_id_2 INTEGER NOT NULL,
        display_item_id_3 INTEGER NOT NULL,
        display_item_id_4 INTEGER NOT NULL,
        display_item_id_5 INTEGER NOT NULL,
        display_item_id_6 INTEGER NOT NULL,
        display_item_id_7 INTEGER NOT NULL,
        display_item_id_8 INTEGER NOT NULL,
        display_item_id_9 INTEGER NOT NULL,
        display_item_id_10 INTEGER NOT NULL,
        display_item_id_11 INTEGER NOT NULL,
        display_item_id_12 INTEGER NOT NULL,
        display_item_id_13 INTEGER NOT NULL,
        display_item_id_14 INTEGER NOT NULL,
        display_item_id_15 INTEGER NOT NULL,
        display_item_id_16 INTEGER NOT NULL,
        display_item_id_17 INTEGER NOT NULL,
        display_item_id_18 INTEGER NOT NULL,
        display_item_id_19 INTEGER NOT NULL,
        display_item_id_20 INTEGER NOT NULL,
        display_item_id_21 INTEGER NOT NULL,
        display_item_id_22 INTEGER NOT NULL,
        display_item_id_23 INTEGER NOT NULL,
        inventory_type_0 INTEGER NOT NULL,
        inventory_type_1 INTEGER NOT NULL,
        inventory_type_2 INTEGER NOT NULL,
        inventory_type_3 INTEGER NOT NULL,
        inventory_type_4 INTEGER NOT NULL,
        inventory_type_5 INTEGER NOT NULL,
        inventory_type_6 INTEGER NOT NULL,
        inventory_type_7 INTEGER NOT NULL,
        inventory_type_8 INTEGER NOT NULL,
        inventory_type_9 INTEGER NOT NULL,
        inventory_type_10 INTEGER NOT NULL,
        inventory_type_11 INTEGER NOT NULL,
        inventory_type_12 INTEGER NOT NULL,
        inventory_type_13 INTEGER NOT NULL,
        inventory_type_14 INTEGER NOT NULL,
        inventory_type_15 INTEGER NOT NULL,
        inventory_type_16 INTEGER NOT NULL,
        inventory_type_17 INTEGER NOT NULL,
        inventory_type_18 INTEGER NOT NULL,
        inventory_type_19 INTEGER NOT NULL,
        inventory_type_20 INTEGER NOT NULL,
        inventory_type_21 INTEGER NOT NULL,
        inventory_type_22 INTEGER NOT NULL,
        inventory_type_23 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CharStartOutfit (
        id,
        race_id,
        class_id,
        sex_id,
        outfit_id,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        item_id_8,
        item_id_9,
        item_id_10,
        item_id_11,
        item_id_12,
        item_id_13,
        item_id_14,
        item_id_15,
        item_id_16,
        item_id_17,
        item_id_18,
        item_id_19,
        item_id_20,
        item_id_21,
        item_id_22,
        item_id_23,
        display_item_id_0,
        display_item_id_1,
        display_item_id_2,
        display_item_id_3,
        display_item_id_4,
        display_item_id_5,
        display_item_id_6,
        display_item_id_7,
        display_item_id_8,
        display_item_id_9,
        display_item_id_10,
        display_item_id_11,
        display_item_id_12,
        display_item_id_13,
        display_item_id_14,
        display_item_id_15,
        display_item_id_16,
        display_item_id_17,
        display_item_id_18,
        display_item_id_19,
        display_item_id_20,
        display_item_id_21,
        display_item_id_22,
        display_item_id_23,
        inventory_type_0,
        inventory_type_1,
        inventory_type_2,
        inventory_type_3,
        inventory_type_4,
        inventory_type_5,
        inventory_type_6,
        inventory_type_7,
        inventory_type_8,
        inventory_type_9,
        inventory_type_10,
        inventory_type_11,
        inventory_type_12,
        inventory_type_13,
        inventory_type_14,
        inventory_type_15,
        inventory_type_16,
        inventory_type_17,
        inventory_type_18,
        inventory_type_19,
        inventory_type_20,
        inventory_type_21,
        inventory_type_22,
        inventory_type_23
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62,
        ?63,
        ?64,
        ?65,
        ?66,
        ?67,
        ?68,
        ?69,
        ?70,
        ?71,
        ?72,
        ?73,
        ?74,
        ?75,
        ?76,
        ?77
    );"
    ,
    "SELECT
        id,
        race_id,
        class_id,
        sex_id,
        outfit_id,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        item_id_8,
        item_id_9,
        item_id_10,
        item_id_11,
        item_id_12,
        item_id_13,
        item_id_14,
        item_id_15,
        item_id_16,
        item_id_17,
        item_id_18,
        item_id_19,
        item_id_20,
        item_id_21,
        item_id_22,
        item_id_23,
        display_item_id_0,
        display_item_id_1,
        display_item_id_2,
        display_item_id_3,
        display_item_id_4,
        display_item_id_5,
        display_item_id_6,
        display_item_id_7,
        display_item_id_8,
        display_item_id_9,
        display_item_id_10,
        display_item_id_11,
        display_item_id_12,
        display_item_id_13,
        display_item_id_14,
        display_item_id_15,
        display_item_id_16,
        display_item_id_17,
        display_item_id_18,
        display_item_id_19,
        display_item_id_20,
        display_item_id_21,
        display_item_id_22,
        display_item_id_23,
        inventory_type_0,
        inventory_type_1,
        inventory_type_2,
        inventory_type_3,
        inventory_type_4,
        inventory_type_5,
        inventory_type_6,
        inventory_type_7,
        inventory_type_8,
        inventory_type_9,
        inventory_type_10,
        inventory_type_11,
        inventory_type_12,
        inventory_type_13,
        inventory_type_14,
        inventory_type_15,
        inventory_type_16,
        inventory_type_17,
        inventory_type_18,
        inventory_type_19,
        inventory_type_20,
        inventory_type_21,
        inventory_type_22,
        inventory_type_23
    FROM `CharStartOutfit`;"
    )
}


pub(crate) fn char_start_outfit_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_start_outfit::CharStartOutfit, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_start_outfit::CharStartOutfitRow {
            id: row.get::<_, i32>(0)?.into(),
            race_id: row.get::<_, i8>(1)?.into(),
            class_id: row.get::<_, i8>(2)?.into(),
            sex_id: row.get::<_, i8>(3)?.into(),
            outfit_id: row.get::<_, i8>(4)?.into(),
            item_id: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(),             ],
            display_item_id: [row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(), row.get::<_, i32>(33)?.into(), row.get::<_, i32>(34)?.into(), row.get::<_, i32>(35)?.into(), row.get::<_, i32>(36)?.into(), row.get::<_, i32>(37)?.into(), row.get::<_, i32>(38)?.into(), row.get::<_, i32>(39)?.into(), row.get::<_, i32>(40)?.into(), row.get::<_, i32>(41)?.into(), row.get::<_, i32>(42)?.into(), row.get::<_, i32>(43)?.into(), row.get::<_, i32>(44)?.into(), row.get::<_, i32>(45)?.into(), row.get::<_, i32>(46)?.into(), row.get::<_, i32>(47)?.into(), row.get::<_, i32>(48)?.into(), row.get::<_, i32>(49)?.into(), row.get::<_, i32>(50)?.into(), row.get::<_, i32>(51)?.into(), row.get::<_, i32>(52)?.into(),             ],
            inventory_type: [row.get::<_, i32>(53)?.into(), row.get::<_, i32>(54)?.into(), row.get::<_, i32>(55)?.into(), row.get::<_, i32>(56)?.into(), row.get::<_, i32>(57)?.into(), row.get::<_, i32>(58)?.into(), row.get::<_, i32>(59)?.into(), row.get::<_, i32>(60)?.into(), row.get::<_, i32>(61)?.into(), row.get::<_, i32>(62)?.into(), row.get::<_, i32>(63)?.into(), row.get::<_, i32>(64)?.into(), row.get::<_, i32>(65)?.into(), row.get::<_, i32>(66)?.into(), row.get::<_, i32>(67)?.into(), row.get::<_, i32>(68)?.into(), row.get::<_, i32>(69)?.into(), row.get::<_, i32>(70)?.into(), row.get::<_, i32>(71)?.into(), row.get::<_, i32>(72)?.into(), row.get::<_, i32>(73)?.into(), row.get::<_, i32>(74)?.into(), row.get::<_, i32>(75)?.into(), row.get::<_, i32>(76)?.into(),             ],
        });
    }
    Ok(char_start_outfit::CharStartOutfit { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharTitles() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharTitles (
        id INTEGER PRIMARY KEY NOT NULL,
        condition_id INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        name1_lang_en_gb TEXT NOT NULL,
        name1_lang_ko_kr TEXT NOT NULL,
        name1_lang_fr_fr TEXT NOT NULL,
        name1_lang_de_de TEXT NOT NULL,
        name1_lang_en_cn TEXT NOT NULL,
        name1_lang_en_tw TEXT NOT NULL,
        name1_lang_es_es TEXT NOT NULL,
        name1_lang_es_mx TEXT NOT NULL,
        name1_lang_ru_ru TEXT NOT NULL,
        name1_lang_ja_jp TEXT NOT NULL,
        name1_lang_pt_pt TEXT NOT NULL,
        name1_lang_it_it TEXT NOT NULL,
        name1_lang_unknown_12 TEXT NOT NULL,
        name1_lang_unknown_13 TEXT NOT NULL,
        name1_lang_unknown_14 TEXT NOT NULL,
        name1_lang_unknown_15 TEXT NOT NULL,
        name1_lang_flags INTEGER NOT NULL,
        mask_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CharTitles (
        id,
        condition_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name1_lang_en_gb,
        name1_lang_ko_kr,
        name1_lang_fr_fr,
        name1_lang_de_de,
        name1_lang_en_cn,
        name1_lang_en_tw,
        name1_lang_es_es,
        name1_lang_es_mx,
        name1_lang_ru_ru,
        name1_lang_ja_jp,
        name1_lang_pt_pt,
        name1_lang_it_it,
        name1_lang_unknown_12,
        name1_lang_unknown_13,
        name1_lang_unknown_14,
        name1_lang_unknown_15,
        name1_lang_flags,
        mask_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37
    );"
    ,
    "SELECT
        id,
        condition_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name1_lang_en_gb,
        name1_lang_ko_kr,
        name1_lang_fr_fr,
        name1_lang_de_de,
        name1_lang_en_cn,
        name1_lang_en_tw,
        name1_lang_es_es,
        name1_lang_es_mx,
        name1_lang_ru_ru,
        name1_lang_ja_jp,
        name1_lang_pt_pt,
        name1_lang_it_it,
        name1_lang_unknown_12,
        name1_lang_unknown_13,
        name1_lang_unknown_14,
        name1_lang_unknown_15,
        name1_lang_flags,
        mask_id
    FROM `CharTitles`;"
    )
}


pub(crate) fn char_titles_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_titles::CharTitles, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_titles::CharTitlesRow {
            id: row.get::<_, i32>(0)?.into(),
            condition_id: row.get::<_, i32>(1)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
            name1_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(19)?.into(),
                ko_kr: row.get::<_, String>(20)?.into(),
                fr_fr: row.get::<_, String>(21)?.into(),
                de_de: row.get::<_, String>(22)?.into(),
                en_cn: row.get::<_, String>(23)?.into(),
                en_tw: row.get::<_, String>(24)?.into(),
                es_es: row.get::<_, String>(25)?.into(),
                es_mx: row.get::<_, String>(26)?.into(),
                ru_ru: row.get::<_, String>(27)?.into(),
                ja_jp: row.get::<_, String>(28)?.into(),
                pt_pt: row.get::<_, String>(29)?.into(),
                it_it: row.get::<_, String>(30)?.into(),
                unknown_12: row.get::<_, String>(31)?.into(),
                unknown_13: row.get::<_, String>(32)?.into(),
                unknown_14: row.get::<_, String>(33)?.into(),
                unknown_15: row.get::<_, String>(34)?.into(),
                flags: row.get::<_, u32>(35)?.into(),
            },
            mask_id: row.get::<_, i32>(36)?.into(),
        });
    }
    Ok(char_titles::CharTitles { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharVariations() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharVariations (
        race_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        texture_hold_layer_0 INTEGER NOT NULL,
        texture_hold_layer_1 INTEGER NOT NULL,
        texture_hold_layer_2 INTEGER NOT NULL,
        texture_hold_layer_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CharVariations (
        race_id,
        sex_id,
        texture_hold_layer_0,
        texture_hold_layer_1,
        texture_hold_layer_2,
        texture_hold_layer_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        race_id,
        sex_id,
        texture_hold_layer_0,
        texture_hold_layer_1,
        texture_hold_layer_2,
        texture_hold_layer_3
    FROM `CharVariations`;"
    )
}


pub(crate) fn char_variations_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<char_variations::CharVariations, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(char_variations::CharVariationsRow {
            race_id: row.get::<_, i32>(0)?.into(),
            sex_id: row.get::<_, i32>(1)?.into(),
            texture_hold_layer: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
        });
    }
    Ok(char_variations::CharVariations { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CharacterFacialHairStyles() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CharacterFacialHairStyles (
        race_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        variation_id INTEGER  NOT NULL,
        geoset_0 INTEGER NOT NULL,
        geoset_1 INTEGER NOT NULL,
        geoset_2 INTEGER NOT NULL,
        geoset_3 INTEGER NOT NULL,
        geoset_4 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CharacterFacialHairStyles (
        race_id,
        sex_id,
        variation_id,
        geoset_0,
        geoset_1,
        geoset_2,
        geoset_3,
        geoset_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        race_id,
        sex_id,
        variation_id,
        geoset_0,
        geoset_1,
        geoset_2,
        geoset_3,
        geoset_4
    FROM `CharacterFacialHairStyles`;"
    )
}


pub(crate) fn character_facial_hair_styles_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<character_facial_hair_styles::CharacterFacialHairStyles, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(character_facial_hair_styles::CharacterFacialHairStylesRow {
            race_id: row.get::<_, i32>(0)?.into(),
            sex_id: row.get::<_, i32>(1)?.into(),
            variation_id: row.get::<_, i32>(2)?.into(),
            geoset: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(),             ],
        });
    }
    Ok(character_facial_hair_styles::CharacterFacialHairStyles { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ChatChannels() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ChatChannels (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        faction_group INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        shortcut_lang_en_gb TEXT NOT NULL,
        shortcut_lang_ko_kr TEXT NOT NULL,
        shortcut_lang_fr_fr TEXT NOT NULL,
        shortcut_lang_de_de TEXT NOT NULL,
        shortcut_lang_en_cn TEXT NOT NULL,
        shortcut_lang_en_tw TEXT NOT NULL,
        shortcut_lang_es_es TEXT NOT NULL,
        shortcut_lang_es_mx TEXT NOT NULL,
        shortcut_lang_ru_ru TEXT NOT NULL,
        shortcut_lang_ja_jp TEXT NOT NULL,
        shortcut_lang_pt_pt TEXT NOT NULL,
        shortcut_lang_it_it TEXT NOT NULL,
        shortcut_lang_unknown_12 TEXT NOT NULL,
        shortcut_lang_unknown_13 TEXT NOT NULL,
        shortcut_lang_unknown_14 TEXT NOT NULL,
        shortcut_lang_unknown_15 TEXT NOT NULL,
        shortcut_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ChatChannels (
        id,
        flags,
        faction_group,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        shortcut_lang_en_gb,
        shortcut_lang_ko_kr,
        shortcut_lang_fr_fr,
        shortcut_lang_de_de,
        shortcut_lang_en_cn,
        shortcut_lang_en_tw,
        shortcut_lang_es_es,
        shortcut_lang_es_mx,
        shortcut_lang_ru_ru,
        shortcut_lang_ja_jp,
        shortcut_lang_pt_pt,
        shortcut_lang_it_it,
        shortcut_lang_unknown_12,
        shortcut_lang_unknown_13,
        shortcut_lang_unknown_14,
        shortcut_lang_unknown_15,
        shortcut_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37
    );"
    ,
    "SELECT
        id,
        flags,
        faction_group,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        shortcut_lang_en_gb,
        shortcut_lang_ko_kr,
        shortcut_lang_fr_fr,
        shortcut_lang_de_de,
        shortcut_lang_en_cn,
        shortcut_lang_en_tw,
        shortcut_lang_es_es,
        shortcut_lang_es_mx,
        shortcut_lang_ru_ru,
        shortcut_lang_ja_jp,
        shortcut_lang_pt_pt,
        shortcut_lang_it_it,
        shortcut_lang_unknown_12,
        shortcut_lang_unknown_13,
        shortcut_lang_unknown_14,
        shortcut_lang_unknown_15,
        shortcut_lang_flags
    FROM `ChatChannels`;"
    )
}


pub(crate) fn chat_channels_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<chat_channels::ChatChannels, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(chat_channels::ChatChannelsRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            faction_group: row.get::<_, i32>(2)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
            shortcut_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(20)?.into(),
                ko_kr: row.get::<_, String>(21)?.into(),
                fr_fr: row.get::<_, String>(22)?.into(),
                de_de: row.get::<_, String>(23)?.into(),
                en_cn: row.get::<_, String>(24)?.into(),
                en_tw: row.get::<_, String>(25)?.into(),
                es_es: row.get::<_, String>(26)?.into(),
                es_mx: row.get::<_, String>(27)?.into(),
                ru_ru: row.get::<_, String>(28)?.into(),
                ja_jp: row.get::<_, String>(29)?.into(),
                pt_pt: row.get::<_, String>(30)?.into(),
                it_it: row.get::<_, String>(31)?.into(),
                unknown_12: row.get::<_, String>(32)?.into(),
                unknown_13: row.get::<_, String>(33)?.into(),
                unknown_14: row.get::<_, String>(34)?.into(),
                unknown_15: row.get::<_, String>(35)?.into(),
                flags: row.get::<_, u32>(36)?.into(),
            },
        });
    }
    Ok(chat_channels::ChatChannels { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ChatProfanity() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ChatProfanity (
        id INTEGER PRIMARY KEY NOT NULL,
        text TEXT  NOT NULL,
        language INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ChatProfanity (
        id,
        text,
        language
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        text,
        language
    FROM `ChatProfanity`;"
    )
}


pub(crate) fn chat_profanity_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<chat_profanity::ChatProfanity, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(chat_profanity::ChatProfanityRow {
            id: row.get::<_, i32>(0)?.into(),
            text: row.get::<_, String>(1)?.into(),
            language: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(chat_profanity::ChatProfanity { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ChrClasses() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ChrClasses (
        id INTEGER PRIMARY KEY NOT NULL,
        damage_bonus_stat INTEGER  NOT NULL,
        display_power INTEGER  NOT NULL,
        pet_name_token TEXT  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        name_female_lang_en_gb TEXT NOT NULL,
        name_female_lang_ko_kr TEXT NOT NULL,
        name_female_lang_fr_fr TEXT NOT NULL,
        name_female_lang_de_de TEXT NOT NULL,
        name_female_lang_en_cn TEXT NOT NULL,
        name_female_lang_en_tw TEXT NOT NULL,
        name_female_lang_es_es TEXT NOT NULL,
        name_female_lang_es_mx TEXT NOT NULL,
        name_female_lang_ru_ru TEXT NOT NULL,
        name_female_lang_ja_jp TEXT NOT NULL,
        name_female_lang_pt_pt TEXT NOT NULL,
        name_female_lang_it_it TEXT NOT NULL,
        name_female_lang_unknown_12 TEXT NOT NULL,
        name_female_lang_unknown_13 TEXT NOT NULL,
        name_female_lang_unknown_14 TEXT NOT NULL,
        name_female_lang_unknown_15 TEXT NOT NULL,
        name_female_lang_flags INTEGER NOT NULL,
        name_male_lang_en_gb TEXT NOT NULL,
        name_male_lang_ko_kr TEXT NOT NULL,
        name_male_lang_fr_fr TEXT NOT NULL,
        name_male_lang_de_de TEXT NOT NULL,
        name_male_lang_en_cn TEXT NOT NULL,
        name_male_lang_en_tw TEXT NOT NULL,
        name_male_lang_es_es TEXT NOT NULL,
        name_male_lang_es_mx TEXT NOT NULL,
        name_male_lang_ru_ru TEXT NOT NULL,
        name_male_lang_ja_jp TEXT NOT NULL,
        name_male_lang_pt_pt TEXT NOT NULL,
        name_male_lang_it_it TEXT NOT NULL,
        name_male_lang_unknown_12 TEXT NOT NULL,
        name_male_lang_unknown_13 TEXT NOT NULL,
        name_male_lang_unknown_14 TEXT NOT NULL,
        name_male_lang_unknown_15 TEXT NOT NULL,
        name_male_lang_flags INTEGER NOT NULL,
        filename TEXT  NOT NULL,
        spell_class_set INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        cinematic_sequence_id INTEGER  NOT NULL,
        required_expansion INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ChrClasses (
        id,
        damage_bonus_stat,
        display_power,
        pet_name_token,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_female_lang_en_gb,
        name_female_lang_ko_kr,
        name_female_lang_fr_fr,
        name_female_lang_de_de,
        name_female_lang_en_cn,
        name_female_lang_en_tw,
        name_female_lang_es_es,
        name_female_lang_es_mx,
        name_female_lang_ru_ru,
        name_female_lang_ja_jp,
        name_female_lang_pt_pt,
        name_female_lang_it_it,
        name_female_lang_unknown_12,
        name_female_lang_unknown_13,
        name_female_lang_unknown_14,
        name_female_lang_unknown_15,
        name_female_lang_flags,
        name_male_lang_en_gb,
        name_male_lang_ko_kr,
        name_male_lang_fr_fr,
        name_male_lang_de_de,
        name_male_lang_en_cn,
        name_male_lang_en_tw,
        name_male_lang_es_es,
        name_male_lang_es_mx,
        name_male_lang_ru_ru,
        name_male_lang_ja_jp,
        name_male_lang_pt_pt,
        name_male_lang_it_it,
        name_male_lang_unknown_12,
        name_male_lang_unknown_13,
        name_male_lang_unknown_14,
        name_male_lang_unknown_15,
        name_male_lang_flags,
        filename,
        spell_class_set,
        flags,
        cinematic_sequence_id,
        required_expansion
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60
    );"
    ,
    "SELECT
        id,
        damage_bonus_stat,
        display_power,
        pet_name_token,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_female_lang_en_gb,
        name_female_lang_ko_kr,
        name_female_lang_fr_fr,
        name_female_lang_de_de,
        name_female_lang_en_cn,
        name_female_lang_en_tw,
        name_female_lang_es_es,
        name_female_lang_es_mx,
        name_female_lang_ru_ru,
        name_female_lang_ja_jp,
        name_female_lang_pt_pt,
        name_female_lang_it_it,
        name_female_lang_unknown_12,
        name_female_lang_unknown_13,
        name_female_lang_unknown_14,
        name_female_lang_unknown_15,
        name_female_lang_flags,
        name_male_lang_en_gb,
        name_male_lang_ko_kr,
        name_male_lang_fr_fr,
        name_male_lang_de_de,
        name_male_lang_en_cn,
        name_male_lang_en_tw,
        name_male_lang_es_es,
        name_male_lang_es_mx,
        name_male_lang_ru_ru,
        name_male_lang_ja_jp,
        name_male_lang_pt_pt,
        name_male_lang_it_it,
        name_male_lang_unknown_12,
        name_male_lang_unknown_13,
        name_male_lang_unknown_14,
        name_male_lang_unknown_15,
        name_male_lang_flags,
        filename,
        spell_class_set,
        flags,
        cinematic_sequence_id,
        required_expansion
    FROM `ChrClasses`;"
    )
}


pub(crate) fn chr_classes_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<chr_classes::ChrClasses, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(chr_classes::ChrClassesRow {
            id: row.get::<_, i32>(0)?.into(),
            damage_bonus_stat: row.get::<_, i32>(1)?.into(),
            display_power: row.get::<_, i32>(2)?.into(),
            pet_name_token: row.get::<_, String>(3)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(4)?.into(),
                ko_kr: row.get::<_, String>(5)?.into(),
                fr_fr: row.get::<_, String>(6)?.into(),
                de_de: row.get::<_, String>(7)?.into(),
                en_cn: row.get::<_, String>(8)?.into(),
                en_tw: row.get::<_, String>(9)?.into(),
                es_es: row.get::<_, String>(10)?.into(),
                es_mx: row.get::<_, String>(11)?.into(),
                ru_ru: row.get::<_, String>(12)?.into(),
                ja_jp: row.get::<_, String>(13)?.into(),
                pt_pt: row.get::<_, String>(14)?.into(),
                it_it: row.get::<_, String>(15)?.into(),
                unknown_12: row.get::<_, String>(16)?.into(),
                unknown_13: row.get::<_, String>(17)?.into(),
                unknown_14: row.get::<_, String>(18)?.into(),
                unknown_15: row.get::<_, String>(19)?.into(),
                flags: row.get::<_, u32>(20)?.into(),
            },
            name_female_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(21)?.into(),
                ko_kr: row.get::<_, String>(22)?.into(),
                fr_fr: row.get::<_, String>(23)?.into(),
                de_de: row.get::<_, String>(24)?.into(),
                en_cn: row.get::<_, String>(25)?.into(),
                en_tw: row.get::<_, String>(26)?.into(),
                es_es: row.get::<_, String>(27)?.into(),
                es_mx: row.get::<_, String>(28)?.into(),
                ru_ru: row.get::<_, String>(29)?.into(),
                ja_jp: row.get::<_, String>(30)?.into(),
                pt_pt: row.get::<_, String>(31)?.into(),
                it_it: row.get::<_, String>(32)?.into(),
                unknown_12: row.get::<_, String>(33)?.into(),
                unknown_13: row.get::<_, String>(34)?.into(),
                unknown_14: row.get::<_, String>(35)?.into(),
                unknown_15: row.get::<_, String>(36)?.into(),
                flags: row.get::<_, u32>(37)?.into(),
            },
            name_male_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(38)?.into(),
                ko_kr: row.get::<_, String>(39)?.into(),
                fr_fr: row.get::<_, String>(40)?.into(),
                de_de: row.get::<_, String>(41)?.into(),
                en_cn: row.get::<_, String>(42)?.into(),
                en_tw: row.get::<_, String>(43)?.into(),
                es_es: row.get::<_, String>(44)?.into(),
                es_mx: row.get::<_, String>(45)?.into(),
                ru_ru: row.get::<_, String>(46)?.into(),
                ja_jp: row.get::<_, String>(47)?.into(),
                pt_pt: row.get::<_, String>(48)?.into(),
                it_it: row.get::<_, String>(49)?.into(),
                unknown_12: row.get::<_, String>(50)?.into(),
                unknown_13: row.get::<_, String>(51)?.into(),
                unknown_14: row.get::<_, String>(52)?.into(),
                unknown_15: row.get::<_, String>(53)?.into(),
                flags: row.get::<_, u32>(54)?.into(),
            },
            filename: row.get::<_, String>(55)?.into(),
            spell_class_set: row.get::<_, i32>(56)?.into(),
            flags: row.get::<_, i32>(57)?.into(),
            cinematic_sequence_id: row.get::<_, i32>(58)?.into(),
            required_expansion: row.get::<_, i32>(59)?.into(),
        });
    }
    Ok(chr_classes::ChrClasses { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ChrRaces() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ChrRaces (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        faction_id INTEGER  NOT NULL,
        exploration_sound_id INTEGER  NOT NULL,
        male_display_id INTEGER  NOT NULL,
        female_display_id INTEGER  NOT NULL,
        client_prefix TEXT  NOT NULL,
        base_language INTEGER  NOT NULL,
        creature_type INTEGER  NOT NULL,
        res_sickness_spell_id INTEGER  NOT NULL,
        splash_sound_id INTEGER  NOT NULL,
        client_file_string TEXT  NOT NULL,
        cinematic_sequence_id INTEGER  NOT NULL,
        alliance INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        name_female_lang_en_gb TEXT NOT NULL,
        name_female_lang_ko_kr TEXT NOT NULL,
        name_female_lang_fr_fr TEXT NOT NULL,
        name_female_lang_de_de TEXT NOT NULL,
        name_female_lang_en_cn TEXT NOT NULL,
        name_female_lang_en_tw TEXT NOT NULL,
        name_female_lang_es_es TEXT NOT NULL,
        name_female_lang_es_mx TEXT NOT NULL,
        name_female_lang_ru_ru TEXT NOT NULL,
        name_female_lang_ja_jp TEXT NOT NULL,
        name_female_lang_pt_pt TEXT NOT NULL,
        name_female_lang_it_it TEXT NOT NULL,
        name_female_lang_unknown_12 TEXT NOT NULL,
        name_female_lang_unknown_13 TEXT NOT NULL,
        name_female_lang_unknown_14 TEXT NOT NULL,
        name_female_lang_unknown_15 TEXT NOT NULL,
        name_female_lang_flags INTEGER NOT NULL,
        name_male_lang_en_gb TEXT NOT NULL,
        name_male_lang_ko_kr TEXT NOT NULL,
        name_male_lang_fr_fr TEXT NOT NULL,
        name_male_lang_de_de TEXT NOT NULL,
        name_male_lang_en_cn TEXT NOT NULL,
        name_male_lang_en_tw TEXT NOT NULL,
        name_male_lang_es_es TEXT NOT NULL,
        name_male_lang_es_mx TEXT NOT NULL,
        name_male_lang_ru_ru TEXT NOT NULL,
        name_male_lang_ja_jp TEXT NOT NULL,
        name_male_lang_pt_pt TEXT NOT NULL,
        name_male_lang_it_it TEXT NOT NULL,
        name_male_lang_unknown_12 TEXT NOT NULL,
        name_male_lang_unknown_13 TEXT NOT NULL,
        name_male_lang_unknown_14 TEXT NOT NULL,
        name_male_lang_unknown_15 TEXT NOT NULL,
        name_male_lang_flags INTEGER NOT NULL,
        facial_hair_customization_0 TEXT NOT NULL,
        facial_hair_customization_1 TEXT NOT NULL,
        hair_customization TEXT  NOT NULL,
        required_expansion INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ChrRaces (
        id,
        flags,
        faction_id,
        exploration_sound_id,
        male_display_id,
        female_display_id,
        client_prefix,
        base_language,
        creature_type,
        res_sickness_spell_id,
        splash_sound_id,
        client_file_string,
        cinematic_sequence_id,
        alliance,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_female_lang_en_gb,
        name_female_lang_ko_kr,
        name_female_lang_fr_fr,
        name_female_lang_de_de,
        name_female_lang_en_cn,
        name_female_lang_en_tw,
        name_female_lang_es_es,
        name_female_lang_es_mx,
        name_female_lang_ru_ru,
        name_female_lang_ja_jp,
        name_female_lang_pt_pt,
        name_female_lang_it_it,
        name_female_lang_unknown_12,
        name_female_lang_unknown_13,
        name_female_lang_unknown_14,
        name_female_lang_unknown_15,
        name_female_lang_flags,
        name_male_lang_en_gb,
        name_male_lang_ko_kr,
        name_male_lang_fr_fr,
        name_male_lang_de_de,
        name_male_lang_en_cn,
        name_male_lang_en_tw,
        name_male_lang_es_es,
        name_male_lang_es_mx,
        name_male_lang_ru_ru,
        name_male_lang_ja_jp,
        name_male_lang_pt_pt,
        name_male_lang_it_it,
        name_male_lang_unknown_12,
        name_male_lang_unknown_13,
        name_male_lang_unknown_14,
        name_male_lang_unknown_15,
        name_male_lang_flags,
        facial_hair_customization_0,
        facial_hair_customization_1,
        hair_customization,
        required_expansion
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62,
        ?63,
        ?64,
        ?65,
        ?66,
        ?67,
        ?68,
        ?69
    );"
    ,
    "SELECT
        id,
        flags,
        faction_id,
        exploration_sound_id,
        male_display_id,
        female_display_id,
        client_prefix,
        base_language,
        creature_type,
        res_sickness_spell_id,
        splash_sound_id,
        client_file_string,
        cinematic_sequence_id,
        alliance,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_female_lang_en_gb,
        name_female_lang_ko_kr,
        name_female_lang_fr_fr,
        name_female_lang_de_de,
        name_female_lang_en_cn,
        name_female_lang_en_tw,
        name_female_lang_es_es,
        name_female_lang_es_mx,
        name_female_lang_ru_ru,
        name_female_lang_ja_jp,
        name_female_lang_pt_pt,
        name_female_lang_it_it,
        name_female_lang_unknown_12,
        name_female_lang_unknown_13,
        name_female_lang_unknown_14,
        name_female_lang_unknown_15,
        name_female_lang_flags,
        name_male_lang_en_gb,
        name_male_lang_ko_kr,
        name_male_lang_fr_fr,
        name_male_lang_de_de,
        name_male_lang_en_cn,
        name_male_lang_en_tw,
        name_male_lang_es_es,
        name_male_lang_es_mx,
        name_male_lang_ru_ru,
        name_male_lang_ja_jp,
        name_male_lang_pt_pt,
        name_male_lang_it_it,
        name_male_lang_unknown_12,
        name_male_lang_unknown_13,
        name_male_lang_unknown_14,
        name_male_lang_unknown_15,
        name_male_lang_flags,
        facial_hair_customization_0,
        facial_hair_customization_1,
        hair_customization,
        required_expansion
    FROM `ChrRaces`;"
    )
}


pub(crate) fn chr_races_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<chr_races::ChrRaces, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(chr_races::ChrRacesRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            faction_id: row.get::<_, i32>(2)?.into(),
            exploration_sound_id: row.get::<_, i32>(3)?.into(),
            male_display_id: row.get::<_, i32>(4)?.into(),
            female_display_id: row.get::<_, i32>(5)?.into(),
            client_prefix: row.get::<_, String>(6)?.into(),
            base_language: row.get::<_, i32>(7)?.into(),
            creature_type: row.get::<_, i32>(8)?.into(),
            res_sickness_spell_id: row.get::<_, i32>(9)?.into(),
            splash_sound_id: row.get::<_, i32>(10)?.into(),
            client_file_string: row.get::<_, String>(11)?.into(),
            cinematic_sequence_id: row.get::<_, i32>(12)?.into(),
            alliance: row.get::<_, i32>(13)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(14)?.into(),
                ko_kr: row.get::<_, String>(15)?.into(),
                fr_fr: row.get::<_, String>(16)?.into(),
                de_de: row.get::<_, String>(17)?.into(),
                en_cn: row.get::<_, String>(18)?.into(),
                en_tw: row.get::<_, String>(19)?.into(),
                es_es: row.get::<_, String>(20)?.into(),
                es_mx: row.get::<_, String>(21)?.into(),
                ru_ru: row.get::<_, String>(22)?.into(),
                ja_jp: row.get::<_, String>(23)?.into(),
                pt_pt: row.get::<_, String>(24)?.into(),
                it_it: row.get::<_, String>(25)?.into(),
                unknown_12: row.get::<_, String>(26)?.into(),
                unknown_13: row.get::<_, String>(27)?.into(),
                unknown_14: row.get::<_, String>(28)?.into(),
                unknown_15: row.get::<_, String>(29)?.into(),
                flags: row.get::<_, u32>(30)?.into(),
            },
            name_female_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(31)?.into(),
                ko_kr: row.get::<_, String>(32)?.into(),
                fr_fr: row.get::<_, String>(33)?.into(),
                de_de: row.get::<_, String>(34)?.into(),
                en_cn: row.get::<_, String>(35)?.into(),
                en_tw: row.get::<_, String>(36)?.into(),
                es_es: row.get::<_, String>(37)?.into(),
                es_mx: row.get::<_, String>(38)?.into(),
                ru_ru: row.get::<_, String>(39)?.into(),
                ja_jp: row.get::<_, String>(40)?.into(),
                pt_pt: row.get::<_, String>(41)?.into(),
                it_it: row.get::<_, String>(42)?.into(),
                unknown_12: row.get::<_, String>(43)?.into(),
                unknown_13: row.get::<_, String>(44)?.into(),
                unknown_14: row.get::<_, String>(45)?.into(),
                unknown_15: row.get::<_, String>(46)?.into(),
                flags: row.get::<_, u32>(47)?.into(),
            },
            name_male_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(48)?.into(),
                ko_kr: row.get::<_, String>(49)?.into(),
                fr_fr: row.get::<_, String>(50)?.into(),
                de_de: row.get::<_, String>(51)?.into(),
                en_cn: row.get::<_, String>(52)?.into(),
                en_tw: row.get::<_, String>(53)?.into(),
                es_es: row.get::<_, String>(54)?.into(),
                es_mx: row.get::<_, String>(55)?.into(),
                ru_ru: row.get::<_, String>(56)?.into(),
                ja_jp: row.get::<_, String>(57)?.into(),
                pt_pt: row.get::<_, String>(58)?.into(),
                it_it: row.get::<_, String>(59)?.into(),
                unknown_12: row.get::<_, String>(60)?.into(),
                unknown_13: row.get::<_, String>(61)?.into(),
                unknown_14: row.get::<_, String>(62)?.into(),
                unknown_15: row.get::<_, String>(63)?.into(),
                flags: row.get::<_, u32>(64)?.into(),
            },
            facial_hair_customization: [row.get::<_, String>(65)?.into(), row.get::<_, String>(66)?.into(),             ],
            hair_customization: row.get::<_, String>(67)?.into(),
            required_expansion: row.get::<_, i32>(68)?.into(),
        });
    }
    Ok(chr_races::ChrRaces { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CinematicCamera() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CinematicCamera (
        id INTEGER PRIMARY KEY NOT NULL,
        model TEXT  NOT NULL,
        sound_id INTEGER  NOT NULL,
        origin_0 REAL NOT NULL,
        origin_1 REAL NOT NULL,
        origin_2 REAL NOT NULL,
        origin_facing REAL  NOT NULL
    );"
    ,
    "INSERT INTO CinematicCamera (
        id,
        model,
        sound_id,
        origin_0,
        origin_1,
        origin_2,
        origin_facing
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        model,
        sound_id,
        origin_0,
        origin_1,
        origin_2,
        origin_facing
    FROM `CinematicCamera`;"
    )
}


pub(crate) fn cinematic_camera_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<cinematic_camera::CinematicCamera, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(cinematic_camera::CinematicCameraRow {
            id: row.get::<_, i32>(0)?.into(),
            model: row.get::<_, String>(1)?.into(),
            sound_id: row.get::<_, i32>(2)?.into(),
            origin: [row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(),             ],
            origin_facing: row.get::<_, f32>(6)?.into(),
        });
    }
    Ok(cinematic_camera::CinematicCamera { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CinematicSequences() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CinematicSequences (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_id INTEGER  NOT NULL,
        camera_0 INTEGER NOT NULL,
        camera_1 INTEGER NOT NULL,
        camera_2 INTEGER NOT NULL,
        camera_3 INTEGER NOT NULL,
        camera_4 INTEGER NOT NULL,
        camera_5 INTEGER NOT NULL,
        camera_6 INTEGER NOT NULL,
        camera_7 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CinematicSequences (
        id,
        sound_id,
        camera_0,
        camera_1,
        camera_2,
        camera_3,
        camera_4,
        camera_5,
        camera_6,
        camera_7
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        sound_id,
        camera_0,
        camera_1,
        camera_2,
        camera_3,
        camera_4,
        camera_5,
        camera_6,
        camera_7
    FROM `CinematicSequences`;"
    )
}


pub(crate) fn cinematic_sequences_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<cinematic_sequences::CinematicSequences, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(cinematic_sequences::CinematicSequencesRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_id: row.get::<_, i32>(1)?.into(),
            camera: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(),             ],
        });
    }
    Ok(cinematic_sequences::CinematicSequences { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureDisplayInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureDisplayInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        model_id INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        extended_display_info_id INTEGER  NOT NULL,
        creature_model_scale REAL  NOT NULL,
        creature_model_alpha INTEGER  NOT NULL,
        texture_variation_0 TEXT NOT NULL,
        texture_variation_1 TEXT NOT NULL,
        texture_variation_2 TEXT NOT NULL,
        portrait_texture_name TEXT  NOT NULL,
        size_class INTEGER  NOT NULL,
        blood_id INTEGER  NOT NULL,
        n_p_c_sound_id INTEGER  NOT NULL,
        particle_color_id INTEGER  NOT NULL,
        creature_geoset_data INTEGER  NOT NULL,
        object_effect_package_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CreatureDisplayInfo (
        id,
        model_id,
        sound_id,
        extended_display_info_id,
        creature_model_scale,
        creature_model_alpha,
        texture_variation_0,
        texture_variation_1,
        texture_variation_2,
        portrait_texture_name,
        size_class,
        blood_id,
        n_p_c_sound_id,
        particle_color_id,
        creature_geoset_data,
        object_effect_package_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16
    );"
    ,
    "SELECT
        id,
        model_id,
        sound_id,
        extended_display_info_id,
        creature_model_scale,
        creature_model_alpha,
        texture_variation_0,
        texture_variation_1,
        texture_variation_2,
        portrait_texture_name,
        size_class,
        blood_id,
        n_p_c_sound_id,
        particle_color_id,
        creature_geoset_data,
        object_effect_package_id
    FROM `CreatureDisplayInfo`;"
    )
}


pub(crate) fn creature_display_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_display_info::CreatureDisplayInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_display_info::CreatureDisplayInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            model_id: row.get::<_, i32>(1)?.into(),
            sound_id: row.get::<_, i32>(2)?.into(),
            extended_display_info_id: row.get::<_, i32>(3)?.into(),
            creature_model_scale: row.get::<_, f32>(4)?.into(),
            creature_model_alpha: row.get::<_, i32>(5)?.into(),
            texture_variation: [row.get::<_, String>(6)?.into(), row.get::<_, String>(7)?.into(), row.get::<_, String>(8)?.into(),             ],
            portrait_texture_name: row.get::<_, String>(9)?.into(),
            size_class: row.get::<_, i32>(10)?.into(),
            blood_id: row.get::<_, i32>(11)?.into(),
            n_p_c_sound_id: row.get::<_, i32>(12)?.into(),
            particle_color_id: row.get::<_, i32>(13)?.into(),
            creature_geoset_data: row.get::<_, i32>(14)?.into(),
            object_effect_package_id: row.get::<_, i32>(15)?.into(),
        });
    }
    Ok(creature_display_info::CreatureDisplayInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureDisplayInfoExtra() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureDisplayInfoExtra (
        id INTEGER PRIMARY KEY NOT NULL,
        display_race_id INTEGER  NOT NULL,
        display_sex_id INTEGER  NOT NULL,
        skin_id INTEGER  NOT NULL,
        face_id INTEGER  NOT NULL,
        hair_style_id INTEGER  NOT NULL,
        hair_color_id INTEGER  NOT NULL,
        facial_hair_id INTEGER  NOT NULL,
        n_p_c_item_display_0 INTEGER NOT NULL,
        n_p_c_item_display_1 INTEGER NOT NULL,
        n_p_c_item_display_2 INTEGER NOT NULL,
        n_p_c_item_display_3 INTEGER NOT NULL,
        n_p_c_item_display_4 INTEGER NOT NULL,
        n_p_c_item_display_5 INTEGER NOT NULL,
        n_p_c_item_display_6 INTEGER NOT NULL,
        n_p_c_item_display_7 INTEGER NOT NULL,
        n_p_c_item_display_8 INTEGER NOT NULL,
        n_p_c_item_display_9 INTEGER NOT NULL,
        n_p_c_item_display_10 INTEGER NOT NULL,
        flags INTEGER  NOT NULL,
        bake_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO CreatureDisplayInfoExtra (
        id,
        display_race_id,
        display_sex_id,
        skin_id,
        face_id,
        hair_style_id,
        hair_color_id,
        facial_hair_id,
        n_p_c_item_display_0,
        n_p_c_item_display_1,
        n_p_c_item_display_2,
        n_p_c_item_display_3,
        n_p_c_item_display_4,
        n_p_c_item_display_5,
        n_p_c_item_display_6,
        n_p_c_item_display_7,
        n_p_c_item_display_8,
        n_p_c_item_display_9,
        n_p_c_item_display_10,
        flags,
        bake_name
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21
    );"
    ,
    "SELECT
        id,
        display_race_id,
        display_sex_id,
        skin_id,
        face_id,
        hair_style_id,
        hair_color_id,
        facial_hair_id,
        n_p_c_item_display_0,
        n_p_c_item_display_1,
        n_p_c_item_display_2,
        n_p_c_item_display_3,
        n_p_c_item_display_4,
        n_p_c_item_display_5,
        n_p_c_item_display_6,
        n_p_c_item_display_7,
        n_p_c_item_display_8,
        n_p_c_item_display_9,
        n_p_c_item_display_10,
        flags,
        bake_name
    FROM `CreatureDisplayInfoExtra`;"
    )
}


pub(crate) fn creature_display_info_extra_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_display_info_extra::CreatureDisplayInfoExtra, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_display_info_extra::CreatureDisplayInfoExtraRow {
            id: row.get::<_, i32>(0)?.into(),
            display_race_id: row.get::<_, i32>(1)?.into(),
            display_sex_id: row.get::<_, i32>(2)?.into(),
            skin_id: row.get::<_, i32>(3)?.into(),
            face_id: row.get::<_, i32>(4)?.into(),
            hair_style_id: row.get::<_, i32>(5)?.into(),
            hair_color_id: row.get::<_, i32>(6)?.into(),
            facial_hair_id: row.get::<_, i32>(7)?.into(),
            n_p_c_item_display: [row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(),             ],
            flags: row.get::<_, i32>(19)?.into(),
            bake_name: row.get::<_, String>(20)?.into(),
        });
    }
    Ok(creature_display_info_extra::CreatureDisplayInfoExtra { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureFamily() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureFamily (
        id INTEGER PRIMARY KEY NOT NULL,
        min_scale REAL  NOT NULL,
        min_scale_level INTEGER  NOT NULL,
        max_scale REAL  NOT NULL,
        max_scale_level INTEGER  NOT NULL,
        skill_line_0 INTEGER NOT NULL,
        skill_line_1 INTEGER NOT NULL,
        pet_food_mask INTEGER  NOT NULL,
        pet_talent_type INTEGER  NOT NULL,
        category_enum_id INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        icon_file TEXT  NOT NULL
    );"
    ,
    "INSERT INTO CreatureFamily (
        id,
        min_scale,
        min_scale_level,
        max_scale,
        max_scale_level,
        skill_line_0,
        skill_line_1,
        pet_food_mask,
        pet_talent_type,
        category_enum_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        icon_file
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28
    );"
    ,
    "SELECT
        id,
        min_scale,
        min_scale_level,
        max_scale,
        max_scale_level,
        skill_line_0,
        skill_line_1,
        pet_food_mask,
        pet_talent_type,
        category_enum_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        icon_file
    FROM `CreatureFamily`;"
    )
}


pub(crate) fn creature_family_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_family::CreatureFamily, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_family::CreatureFamilyRow {
            id: row.get::<_, i32>(0)?.into(),
            min_scale: row.get::<_, f32>(1)?.into(),
            min_scale_level: row.get::<_, i32>(2)?.into(),
            max_scale: row.get::<_, f32>(3)?.into(),
            max_scale_level: row.get::<_, i32>(4)?.into(),
            skill_line: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
            pet_food_mask: row.get::<_, i32>(7)?.into(),
            pet_talent_type: row.get::<_, i32>(8)?.into(),
            category_enum_id: row.get::<_, i32>(9)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(10)?.into(),
                ko_kr: row.get::<_, String>(11)?.into(),
                fr_fr: row.get::<_, String>(12)?.into(),
                de_de: row.get::<_, String>(13)?.into(),
                en_cn: row.get::<_, String>(14)?.into(),
                en_tw: row.get::<_, String>(15)?.into(),
                es_es: row.get::<_, String>(16)?.into(),
                es_mx: row.get::<_, String>(17)?.into(),
                ru_ru: row.get::<_, String>(18)?.into(),
                ja_jp: row.get::<_, String>(19)?.into(),
                pt_pt: row.get::<_, String>(20)?.into(),
                it_it: row.get::<_, String>(21)?.into(),
                unknown_12: row.get::<_, String>(22)?.into(),
                unknown_13: row.get::<_, String>(23)?.into(),
                unknown_14: row.get::<_, String>(24)?.into(),
                unknown_15: row.get::<_, String>(25)?.into(),
                flags: row.get::<_, u32>(26)?.into(),
            },
            icon_file: row.get::<_, String>(27)?.into(),
        });
    }
    Ok(creature_family::CreatureFamily { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureModelData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureModelData (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        model_name TEXT  NOT NULL,
        size_class INTEGER  NOT NULL,
        model_scale REAL  NOT NULL,
        blood_id INTEGER  NOT NULL,
        footprint_texture_id INTEGER  NOT NULL,
        footprint_texture_length REAL  NOT NULL,
        footprint_texture_width REAL  NOT NULL,
        footprint_particle_scale REAL  NOT NULL,
        foley_material_id INTEGER  NOT NULL,
        footstep_shake_size INTEGER  NOT NULL,
        death_thud_shake_size INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        collision_width REAL  NOT NULL,
        collision_height REAL  NOT NULL,
        mount_height REAL  NOT NULL,
        geo_box_min_x REAL  NOT NULL,
        geo_box_min_y REAL  NOT NULL,
        geo_box_min_z REAL  NOT NULL,
        geo_box_max_x REAL  NOT NULL,
        geo_box_max_y REAL  NOT NULL,
        geo_box_max_z REAL  NOT NULL,
        world_effect_scale REAL  NOT NULL,
        attached_effect_scale REAL  NOT NULL,
        missile_collision_radius REAL  NOT NULL,
        missile_collision_push REAL  NOT NULL,
        missile_collision_raise REAL  NOT NULL
    );"
    ,
    "INSERT INTO CreatureModelData (
        id,
        flags,
        model_name,
        size_class,
        model_scale,
        blood_id,
        footprint_texture_id,
        footprint_texture_length,
        footprint_texture_width,
        footprint_particle_scale,
        foley_material_id,
        footstep_shake_size,
        death_thud_shake_size,
        sound_id,
        collision_width,
        collision_height,
        mount_height,
        geo_box_min_x,
        geo_box_min_y,
        geo_box_min_z,
        geo_box_max_x,
        geo_box_max_y,
        geo_box_max_z,
        world_effect_scale,
        attached_effect_scale,
        missile_collision_radius,
        missile_collision_push,
        missile_collision_raise
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28
    );"
    ,
    "SELECT
        id,
        flags,
        model_name,
        size_class,
        model_scale,
        blood_id,
        footprint_texture_id,
        footprint_texture_length,
        footprint_texture_width,
        footprint_particle_scale,
        foley_material_id,
        footstep_shake_size,
        death_thud_shake_size,
        sound_id,
        collision_width,
        collision_height,
        mount_height,
        geo_box_min_x,
        geo_box_min_y,
        geo_box_min_z,
        geo_box_max_x,
        geo_box_max_y,
        geo_box_max_z,
        world_effect_scale,
        attached_effect_scale,
        missile_collision_radius,
        missile_collision_push,
        missile_collision_raise
    FROM `CreatureModelData`;"
    )
}


pub(crate) fn creature_model_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_model_data::CreatureModelData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_model_data::CreatureModelDataRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            model_name: row.get::<_, String>(2)?.into(),
            size_class: row.get::<_, i32>(3)?.into(),
            model_scale: row.get::<_, f32>(4)?.into(),
            blood_id: row.get::<_, i32>(5)?.into(),
            footprint_texture_id: row.get::<_, i32>(6)?.into(),
            footprint_texture_length: row.get::<_, f32>(7)?.into(),
            footprint_texture_width: row.get::<_, f32>(8)?.into(),
            footprint_particle_scale: row.get::<_, f32>(9)?.into(),
            foley_material_id: row.get::<_, i32>(10)?.into(),
            footstep_shake_size: row.get::<_, i32>(11)?.into(),
            death_thud_shake_size: row.get::<_, i32>(12)?.into(),
            sound_id: row.get::<_, i32>(13)?.into(),
            collision_width: row.get::<_, f32>(14)?.into(),
            collision_height: row.get::<_, f32>(15)?.into(),
            mount_height: row.get::<_, f32>(16)?.into(),
            geo_box_min_x: row.get::<_, f32>(17)?.into(),
            geo_box_min_y: row.get::<_, f32>(18)?.into(),
            geo_box_min_z: row.get::<_, f32>(19)?.into(),
            geo_box_max_x: row.get::<_, f32>(20)?.into(),
            geo_box_max_y: row.get::<_, f32>(21)?.into(),
            geo_box_max_z: row.get::<_, f32>(22)?.into(),
            world_effect_scale: row.get::<_, f32>(23)?.into(),
            attached_effect_scale: row.get::<_, f32>(24)?.into(),
            missile_collision_radius: row.get::<_, f32>(25)?.into(),
            missile_collision_push: row.get::<_, f32>(26)?.into(),
            missile_collision_raise: row.get::<_, f32>(27)?.into(),
        });
    }
    Ok(creature_model_data::CreatureModelData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureMovementInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureMovementInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        smooth_facing_chase_rate REAL  NOT NULL
    );"
    ,
    "INSERT INTO CreatureMovementInfo (
        id,
        smooth_facing_chase_rate
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        smooth_facing_chase_rate
    FROM `CreatureMovementInfo`;"
    )
}


pub(crate) fn creature_movement_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_movement_info::CreatureMovementInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_movement_info::CreatureMovementInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            smooth_facing_chase_rate: row.get::<_, f32>(1)?.into(),
        });
    }
    Ok(creature_movement_info::CreatureMovementInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureSoundData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureSoundData (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_exertion_id INTEGER  NOT NULL,
        sound_exertion_critical_id INTEGER  NOT NULL,
        sound_injury_id INTEGER  NOT NULL,
        sound_injury_critical_id INTEGER  NOT NULL,
        sound_injury_crushing_blow_id INTEGER  NOT NULL,
        sound_death_id INTEGER  NOT NULL,
        sound_stun_id INTEGER  NOT NULL,
        sound_stand_id INTEGER  NOT NULL,
        sound_footstep_id INTEGER  NOT NULL,
        sound_aggro_id INTEGER  NOT NULL,
        sound_wing_flap_id INTEGER  NOT NULL,
        sound_wing_glide_id INTEGER  NOT NULL,
        sound_alert_id INTEGER  NOT NULL,
        sound_fidget_0 INTEGER NOT NULL,
        sound_fidget_1 INTEGER NOT NULL,
        sound_fidget_2 INTEGER NOT NULL,
        sound_fidget_3 INTEGER NOT NULL,
        sound_fidget_4 INTEGER NOT NULL,
        custom_attack_0 INTEGER NOT NULL,
        custom_attack_1 INTEGER NOT NULL,
        custom_attack_2 INTEGER NOT NULL,
        custom_attack_3 INTEGER NOT NULL,
        n_p_c_sound_id INTEGER  NOT NULL,
        loop_sound_id INTEGER  NOT NULL,
        creature_impact_type INTEGER  NOT NULL,
        sound_jump_start_id INTEGER  NOT NULL,
        sound_jump_end_id INTEGER  NOT NULL,
        sound_pet_attack_id INTEGER  NOT NULL,
        sound_pet_order_id INTEGER  NOT NULL,
        sound_pet_dismiss_id INTEGER  NOT NULL,
        fidget_delay_seconds_min REAL  NOT NULL,
        fidget_delay_seconds_max REAL  NOT NULL,
        birth_sound_id INTEGER  NOT NULL,
        spell_cast_directed_sound_id INTEGER  NOT NULL,
        submerge_sound_id INTEGER  NOT NULL,
        submerged_sound_id INTEGER  NOT NULL,
        creature_sound_data_id_pet INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CreatureSoundData (
        id,
        sound_exertion_id,
        sound_exertion_critical_id,
        sound_injury_id,
        sound_injury_critical_id,
        sound_injury_crushing_blow_id,
        sound_death_id,
        sound_stun_id,
        sound_stand_id,
        sound_footstep_id,
        sound_aggro_id,
        sound_wing_flap_id,
        sound_wing_glide_id,
        sound_alert_id,
        sound_fidget_0,
        sound_fidget_1,
        sound_fidget_2,
        sound_fidget_3,
        sound_fidget_4,
        custom_attack_0,
        custom_attack_1,
        custom_attack_2,
        custom_attack_3,
        n_p_c_sound_id,
        loop_sound_id,
        creature_impact_type,
        sound_jump_start_id,
        sound_jump_end_id,
        sound_pet_attack_id,
        sound_pet_order_id,
        sound_pet_dismiss_id,
        fidget_delay_seconds_min,
        fidget_delay_seconds_max,
        birth_sound_id,
        spell_cast_directed_sound_id,
        submerge_sound_id,
        submerged_sound_id,
        creature_sound_data_id_pet
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38
    );"
    ,
    "SELECT
        id,
        sound_exertion_id,
        sound_exertion_critical_id,
        sound_injury_id,
        sound_injury_critical_id,
        sound_injury_crushing_blow_id,
        sound_death_id,
        sound_stun_id,
        sound_stand_id,
        sound_footstep_id,
        sound_aggro_id,
        sound_wing_flap_id,
        sound_wing_glide_id,
        sound_alert_id,
        sound_fidget_0,
        sound_fidget_1,
        sound_fidget_2,
        sound_fidget_3,
        sound_fidget_4,
        custom_attack_0,
        custom_attack_1,
        custom_attack_2,
        custom_attack_3,
        n_p_c_sound_id,
        loop_sound_id,
        creature_impact_type,
        sound_jump_start_id,
        sound_jump_end_id,
        sound_pet_attack_id,
        sound_pet_order_id,
        sound_pet_dismiss_id,
        fidget_delay_seconds_min,
        fidget_delay_seconds_max,
        birth_sound_id,
        spell_cast_directed_sound_id,
        submerge_sound_id,
        submerged_sound_id,
        creature_sound_data_id_pet
    FROM `CreatureSoundData`;"
    )
}


pub(crate) fn creature_sound_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_sound_data::CreatureSoundData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_sound_data::CreatureSoundDataRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_exertion_id: row.get::<_, i32>(1)?.into(),
            sound_exertion_critical_id: row.get::<_, i32>(2)?.into(),
            sound_injury_id: row.get::<_, i32>(3)?.into(),
            sound_injury_critical_id: row.get::<_, i32>(4)?.into(),
            sound_injury_crushing_blow_id: row.get::<_, i32>(5)?.into(),
            sound_death_id: row.get::<_, i32>(6)?.into(),
            sound_stun_id: row.get::<_, i32>(7)?.into(),
            sound_stand_id: row.get::<_, i32>(8)?.into(),
            sound_footstep_id: row.get::<_, i32>(9)?.into(),
            sound_aggro_id: row.get::<_, i32>(10)?.into(),
            sound_wing_flap_id: row.get::<_, i32>(11)?.into(),
            sound_wing_glide_id: row.get::<_, i32>(12)?.into(),
            sound_alert_id: row.get::<_, i32>(13)?.into(),
            sound_fidget: [row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(),             ],
            custom_attack: [row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
            n_p_c_sound_id: row.get::<_, i32>(23)?.into(),
            loop_sound_id: row.get::<_, i32>(24)?.into(),
            creature_impact_type: row.get::<_, i32>(25)?.into(),
            sound_jump_start_id: row.get::<_, i32>(26)?.into(),
            sound_jump_end_id: row.get::<_, i32>(27)?.into(),
            sound_pet_attack_id: row.get::<_, i32>(28)?.into(),
            sound_pet_order_id: row.get::<_, i32>(29)?.into(),
            sound_pet_dismiss_id: row.get::<_, i32>(30)?.into(),
            fidget_delay_seconds_min: row.get::<_, f32>(31)?.into(),
            fidget_delay_seconds_max: row.get::<_, f32>(32)?.into(),
            birth_sound_id: row.get::<_, i32>(33)?.into(),
            spell_cast_directed_sound_id: row.get::<_, i32>(34)?.into(),
            submerge_sound_id: row.get::<_, i32>(35)?.into(),
            submerged_sound_id: row.get::<_, i32>(36)?.into(),
            creature_sound_data_id_pet: row.get::<_, i32>(37)?.into(),
        });
    }
    Ok(creature_sound_data::CreatureSoundData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureSpellData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureSpellData (
        id INTEGER PRIMARY KEY NOT NULL,
        spells_0 INTEGER NOT NULL,
        spells_1 INTEGER NOT NULL,
        spells_2 INTEGER NOT NULL,
        spells_3 INTEGER NOT NULL,
        availability_0 INTEGER NOT NULL,
        availability_1 INTEGER NOT NULL,
        availability_2 INTEGER NOT NULL,
        availability_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CreatureSpellData (
        id,
        spells_0,
        spells_1,
        spells_2,
        spells_3,
        availability_0,
        availability_1,
        availability_2,
        availability_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9
    );"
    ,
    "SELECT
        id,
        spells_0,
        spells_1,
        spells_2,
        spells_3,
        availability_0,
        availability_1,
        availability_2,
        availability_3
    FROM `CreatureSpellData`;"
    )
}


pub(crate) fn creature_spell_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_spell_data::CreatureSpellData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_spell_data::CreatureSpellDataRow {
            id: row.get::<_, i32>(0)?.into(),
            spells: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            availability: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
        });
    }
    Ok(creature_spell_data::CreatureSpellData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CreatureType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CreatureType (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CreatureType (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        flags
    FROM `CreatureType`;"
    )
}


pub(crate) fn creature_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<creature_type::CreatureType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(creature_type::CreatureTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            flags: row.get::<_, i32>(18)?.into(),
        });
    }
    Ok(creature_type::CreatureType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CurrencyCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CurrencyCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO CurrencyCategory (
        id,
        flags,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        flags,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `CurrencyCategory`;"
    )
}


pub(crate) fn currency_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<currency_category::CurrencyCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(currency_category::CurrencyCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
        });
    }
    Ok(currency_category::CurrencyCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn CurrencyTypes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS CurrencyTypes (
        id INTEGER PRIMARY KEY NOT NULL,
        item_id INTEGER  NOT NULL,
        category_id INTEGER  NOT NULL,
        bit_index INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO CurrencyTypes (
        id,
        item_id,
        category_id,
        bit_index
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        item_id,
        category_id,
        bit_index
    FROM `CurrencyTypes`;"
    )
}


pub(crate) fn currency_types_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<currency_types::CurrencyTypes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(currency_types::CurrencyTypesRow {
            id: row.get::<_, i32>(0)?.into(),
            item_id: row.get::<_, i32>(1)?.into(),
            category_id: row.get::<_, i32>(2)?.into(),
            bit_index: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(currency_types::CurrencyTypes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DanceMoves() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DanceMoves (
        id INTEGER PRIMARY KEY NOT NULL,
        ty INTEGER  NOT NULL,
        param INTEGER  NOT NULL,
        fallback INTEGER  NOT NULL,
        racemask INTEGER  NOT NULL,
        internal_name TEXT  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        lock_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO DanceMoves (
        id,
        ty,
        param,
        fallback,
        racemask,
        internal_name,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        lock_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        ty,
        param,
        fallback,
        racemask,
        internal_name,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        lock_id
    FROM `DanceMoves`;"
    )
}


pub(crate) fn dance_moves_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<dance_moves::DanceMoves, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(dance_moves::DanceMovesRow {
            id: row.get::<_, i32>(0)?.into(),
            ty: row.get::<_, i32>(1)?.into(),
            param: row.get::<_, i32>(2)?.into(),
            fallback: row.get::<_, i32>(3)?.into(),
            racemask: row.get::<_, i32>(4)?.into(),
            internal_name: row.get::<_, String>(5)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(6)?.into(),
                ko_kr: row.get::<_, String>(7)?.into(),
                fr_fr: row.get::<_, String>(8)?.into(),
                de_de: row.get::<_, String>(9)?.into(),
                en_cn: row.get::<_, String>(10)?.into(),
                en_tw: row.get::<_, String>(11)?.into(),
                es_es: row.get::<_, String>(12)?.into(),
                es_mx: row.get::<_, String>(13)?.into(),
                ru_ru: row.get::<_, String>(14)?.into(),
                ja_jp: row.get::<_, String>(15)?.into(),
                pt_pt: row.get::<_, String>(16)?.into(),
                it_it: row.get::<_, String>(17)?.into(),
                unknown_12: row.get::<_, String>(18)?.into(),
                unknown_13: row.get::<_, String>(19)?.into(),
                unknown_14: row.get::<_, String>(20)?.into(),
                unknown_15: row.get::<_, String>(21)?.into(),
                flags: row.get::<_, u32>(22)?.into(),
            },
            lock_id: row.get::<_, i32>(23)?.into(),
        });
    }
    Ok(dance_moves::DanceMoves { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DeathThudLookups() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DeathThudLookups (
        id INTEGER PRIMARY KEY NOT NULL,
        size_class INTEGER  NOT NULL,
        terrain_type_sound_id INTEGER  NOT NULL,
        sound_entry_id INTEGER  NOT NULL,
        sound_entry_id_water INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO DeathThudLookups (
        id,
        size_class,
        terrain_type_sound_id,
        sound_entry_id,
        sound_entry_id_water
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        size_class,
        terrain_type_sound_id,
        sound_entry_id,
        sound_entry_id_water
    FROM `DeathThudLookups`;"
    )
}


pub(crate) fn death_thud_lookups_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<death_thud_lookups::DeathThudLookups, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(death_thud_lookups::DeathThudLookupsRow {
            id: row.get::<_, i32>(0)?.into(),
            size_class: row.get::<_, i32>(1)?.into(),
            terrain_type_sound_id: row.get::<_, i32>(2)?.into(),
            sound_entry_id: row.get::<_, i32>(3)?.into(),
            sound_entry_id_water: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(death_thud_lookups::DeathThudLookups { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DeclinedWord() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DeclinedWord (
        id INTEGER PRIMARY KEY NOT NULL,
        word TEXT  NOT NULL
    );"
    ,
    "INSERT INTO DeclinedWord (
        id,
        word
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        word
    FROM `DeclinedWord`;"
    )
}


pub(crate) fn declined_word_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<declined_word::DeclinedWord, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(declined_word::DeclinedWordRow {
            id: row.get::<_, i32>(0)?.into(),
            word: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(declined_word::DeclinedWord { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DeclinedWordCases() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DeclinedWordCases (
        id INTEGER PRIMARY KEY NOT NULL,
        declined_word_id INTEGER  NOT NULL,
        case_index INTEGER  NOT NULL,
        declined_word TEXT  NOT NULL
    );"
    ,
    "INSERT INTO DeclinedWordCases (
        id,
        declined_word_id,
        case_index,
        declined_word
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        declined_word_id,
        case_index,
        declined_word
    FROM `DeclinedWordCases`;"
    )
}


pub(crate) fn declined_word_cases_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<declined_word_cases::DeclinedWordCases, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(declined_word_cases::DeclinedWordCasesRow {
            id: row.get::<_, i32>(0)?.into(),
            declined_word_id: row.get::<_, i32>(1)?.into(),
            case_index: row.get::<_, i32>(2)?.into(),
            declined_word: row.get::<_, String>(3)?.into(),
        });
    }
    Ok(declined_word_cases::DeclinedWordCases { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DestructibleModelData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DestructibleModelData (
        id INTEGER PRIMARY KEY NOT NULL,
        state0_impact_effect_doodad_set INTEGER  NOT NULL,
        state0_ambient_doodad_set INTEGER  NOT NULL,
        state1_w_m_o INTEGER  NOT NULL,
        state1_destruction_doodad_set INTEGER  NOT NULL,
        state1_impact_effect_doodad_set INTEGER  NOT NULL,
        state1_ambient_doodad_set INTEGER  NOT NULL,
        state2_w_m_o INTEGER  NOT NULL,
        state2_destruction_doodad_set INTEGER  NOT NULL,
        state2_impact_effect_doodad_set INTEGER  NOT NULL,
        state2_ambient_doodad_set INTEGER  NOT NULL,
        state3_w_m_o INTEGER  NOT NULL,
        state3_init_doodad_set INTEGER  NOT NULL,
        state3_ambient_doodad_set INTEGER  NOT NULL,
        eject_direction INTEGER  NOT NULL,
        repair_ground_fx INTEGER  NOT NULL,
        do_not_highlight INTEGER  NOT NULL,
        heal_effect INTEGER  NOT NULL,
        heal_effect_speed INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO DestructibleModelData (
        id,
        state0_impact_effect_doodad_set,
        state0_ambient_doodad_set,
        state1_w_m_o,
        state1_destruction_doodad_set,
        state1_impact_effect_doodad_set,
        state1_ambient_doodad_set,
        state2_w_m_o,
        state2_destruction_doodad_set,
        state2_impact_effect_doodad_set,
        state2_ambient_doodad_set,
        state3_w_m_o,
        state3_init_doodad_set,
        state3_ambient_doodad_set,
        eject_direction,
        repair_ground_fx,
        do_not_highlight,
        heal_effect,
        heal_effect_speed
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        state0_impact_effect_doodad_set,
        state0_ambient_doodad_set,
        state1_w_m_o,
        state1_destruction_doodad_set,
        state1_impact_effect_doodad_set,
        state1_ambient_doodad_set,
        state2_w_m_o,
        state2_destruction_doodad_set,
        state2_impact_effect_doodad_set,
        state2_ambient_doodad_set,
        state3_w_m_o,
        state3_init_doodad_set,
        state3_ambient_doodad_set,
        eject_direction,
        repair_ground_fx,
        do_not_highlight,
        heal_effect,
        heal_effect_speed
    FROM `DestructibleModelData`;"
    )
}


pub(crate) fn destructible_model_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<destructible_model_data::DestructibleModelData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(destructible_model_data::DestructibleModelDataRow {
            id: row.get::<_, i32>(0)?.into(),
            state0_impact_effect_doodad_set: row.get::<_, i32>(1)?.into(),
            state0_ambient_doodad_set: row.get::<_, i32>(2)?.into(),
            state1_w_m_o: row.get::<_, i32>(3)?.into(),
            state1_destruction_doodad_set: row.get::<_, i32>(4)?.into(),
            state1_impact_effect_doodad_set: row.get::<_, i32>(5)?.into(),
            state1_ambient_doodad_set: row.get::<_, i32>(6)?.into(),
            state2_w_m_o: row.get::<_, i32>(7)?.into(),
            state2_destruction_doodad_set: row.get::<_, i32>(8)?.into(),
            state2_impact_effect_doodad_set: row.get::<_, i32>(9)?.into(),
            state2_ambient_doodad_set: row.get::<_, i32>(10)?.into(),
            state3_w_m_o: row.get::<_, i32>(11)?.into(),
            state3_init_doodad_set: row.get::<_, i32>(12)?.into(),
            state3_ambient_doodad_set: row.get::<_, i32>(13)?.into(),
            eject_direction: row.get::<_, i32>(14)?.into(),
            repair_ground_fx: row.get::<_, i32>(15)?.into(),
            do_not_highlight: row.get::<_, i32>(16)?.into(),
            heal_effect: row.get::<_, i32>(17)?.into(),
            heal_effect_speed: row.get::<_, i32>(18)?.into(),
        });
    }
    Ok(destructible_model_data::DestructibleModelData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DungeonEncounter() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DungeonEncounter (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        difficulty INTEGER  NOT NULL,
        order_index INTEGER  NOT NULL,
        bit INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        spell_icon_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO DungeonEncounter (
        id,
        map_id,
        difficulty,
        order_index,
        bit,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        spell_icon_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        map_id,
        difficulty,
        order_index,
        bit,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        spell_icon_id
    FROM `DungeonEncounter`;"
    )
}


pub(crate) fn dungeon_encounter_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<dungeon_encounter::DungeonEncounter, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(dungeon_encounter::DungeonEncounterRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            difficulty: row.get::<_, i32>(2)?.into(),
            order_index: row.get::<_, i32>(3)?.into(),
            bit: row.get::<_, i32>(4)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
            spell_icon_id: row.get::<_, i32>(22)?.into(),
        });
    }
    Ok(dungeon_encounter::DungeonEncounter { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DungeonMap() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DungeonMap (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        floor_index INTEGER  NOT NULL,
        min_x REAL  NOT NULL,
        max_x REAL  NOT NULL,
        min_y REAL  NOT NULL,
        max_y REAL  NOT NULL,
        parent_world_map_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO DungeonMap (
        id,
        map_id,
        floor_index,
        min_x,
        max_x,
        min_y,
        max_y,
        parent_world_map_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        map_id,
        floor_index,
        min_x,
        max_x,
        min_y,
        max_y,
        parent_world_map_id
    FROM `DungeonMap`;"
    )
}


pub(crate) fn dungeon_map_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<dungeon_map::DungeonMap, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(dungeon_map::DungeonMapRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            floor_index: row.get::<_, i32>(2)?.into(),
            min_x: row.get::<_, f32>(3)?.into(),
            max_x: row.get::<_, f32>(4)?.into(),
            min_y: row.get::<_, f32>(5)?.into(),
            max_y: row.get::<_, f32>(6)?.into(),
            parent_world_map_id: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(dungeon_map::DungeonMap { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DungeonMapChunk() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DungeonMapChunk (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        w_m_o_group_id INTEGER  NOT NULL,
        dungeon_map_id INTEGER  NOT NULL,
        min_z REAL  NOT NULL
    );"
    ,
    "INSERT INTO DungeonMapChunk (
        id,
        map_id,
        w_m_o_group_id,
        dungeon_map_id,
        min_z
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        map_id,
        w_m_o_group_id,
        dungeon_map_id,
        min_z
    FROM `DungeonMapChunk`;"
    )
}


pub(crate) fn dungeon_map_chunk_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<dungeon_map_chunk::DungeonMapChunk, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(dungeon_map_chunk::DungeonMapChunkRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            w_m_o_group_id: row.get::<_, i32>(2)?.into(),
            dungeon_map_id: row.get::<_, i32>(3)?.into(),
            min_z: row.get::<_, f32>(4)?.into(),
        });
    }
    Ok(dungeon_map_chunk::DungeonMapChunk { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DurabilityCosts() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DurabilityCosts (
        id INTEGER PRIMARY KEY NOT NULL,
        weapon_sub_class_cost_0 INTEGER NOT NULL,
        weapon_sub_class_cost_1 INTEGER NOT NULL,
        weapon_sub_class_cost_2 INTEGER NOT NULL,
        weapon_sub_class_cost_3 INTEGER NOT NULL,
        weapon_sub_class_cost_4 INTEGER NOT NULL,
        weapon_sub_class_cost_5 INTEGER NOT NULL,
        weapon_sub_class_cost_6 INTEGER NOT NULL,
        weapon_sub_class_cost_7 INTEGER NOT NULL,
        weapon_sub_class_cost_8 INTEGER NOT NULL,
        weapon_sub_class_cost_9 INTEGER NOT NULL,
        weapon_sub_class_cost_10 INTEGER NOT NULL,
        weapon_sub_class_cost_11 INTEGER NOT NULL,
        weapon_sub_class_cost_12 INTEGER NOT NULL,
        weapon_sub_class_cost_13 INTEGER NOT NULL,
        weapon_sub_class_cost_14 INTEGER NOT NULL,
        weapon_sub_class_cost_15 INTEGER NOT NULL,
        weapon_sub_class_cost_16 INTEGER NOT NULL,
        weapon_sub_class_cost_17 INTEGER NOT NULL,
        weapon_sub_class_cost_18 INTEGER NOT NULL,
        weapon_sub_class_cost_19 INTEGER NOT NULL,
        weapon_sub_class_cost_20 INTEGER NOT NULL,
        armor_sub_class_cost_0 INTEGER NOT NULL,
        armor_sub_class_cost_1 INTEGER NOT NULL,
        armor_sub_class_cost_2 INTEGER NOT NULL,
        armor_sub_class_cost_3 INTEGER NOT NULL,
        armor_sub_class_cost_4 INTEGER NOT NULL,
        armor_sub_class_cost_5 INTEGER NOT NULL,
        armor_sub_class_cost_6 INTEGER NOT NULL,
        armor_sub_class_cost_7 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO DurabilityCosts (
        id,
        weapon_sub_class_cost_0,
        weapon_sub_class_cost_1,
        weapon_sub_class_cost_2,
        weapon_sub_class_cost_3,
        weapon_sub_class_cost_4,
        weapon_sub_class_cost_5,
        weapon_sub_class_cost_6,
        weapon_sub_class_cost_7,
        weapon_sub_class_cost_8,
        weapon_sub_class_cost_9,
        weapon_sub_class_cost_10,
        weapon_sub_class_cost_11,
        weapon_sub_class_cost_12,
        weapon_sub_class_cost_13,
        weapon_sub_class_cost_14,
        weapon_sub_class_cost_15,
        weapon_sub_class_cost_16,
        weapon_sub_class_cost_17,
        weapon_sub_class_cost_18,
        weapon_sub_class_cost_19,
        weapon_sub_class_cost_20,
        armor_sub_class_cost_0,
        armor_sub_class_cost_1,
        armor_sub_class_cost_2,
        armor_sub_class_cost_3,
        armor_sub_class_cost_4,
        armor_sub_class_cost_5,
        armor_sub_class_cost_6,
        armor_sub_class_cost_7
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30
    );"
    ,
    "SELECT
        id,
        weapon_sub_class_cost_0,
        weapon_sub_class_cost_1,
        weapon_sub_class_cost_2,
        weapon_sub_class_cost_3,
        weapon_sub_class_cost_4,
        weapon_sub_class_cost_5,
        weapon_sub_class_cost_6,
        weapon_sub_class_cost_7,
        weapon_sub_class_cost_8,
        weapon_sub_class_cost_9,
        weapon_sub_class_cost_10,
        weapon_sub_class_cost_11,
        weapon_sub_class_cost_12,
        weapon_sub_class_cost_13,
        weapon_sub_class_cost_14,
        weapon_sub_class_cost_15,
        weapon_sub_class_cost_16,
        weapon_sub_class_cost_17,
        weapon_sub_class_cost_18,
        weapon_sub_class_cost_19,
        weapon_sub_class_cost_20,
        armor_sub_class_cost_0,
        armor_sub_class_cost_1,
        armor_sub_class_cost_2,
        armor_sub_class_cost_3,
        armor_sub_class_cost_4,
        armor_sub_class_cost_5,
        armor_sub_class_cost_6,
        armor_sub_class_cost_7
    FROM `DurabilityCosts`;"
    )
}


pub(crate) fn durability_costs_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<durability_costs::DurabilityCosts, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(durability_costs::DurabilityCostsRow {
            id: row.get::<_, i32>(0)?.into(),
            weapon_sub_class_cost: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(),             ],
            armor_sub_class_cost: [row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(),             ],
        });
    }
    Ok(durability_costs::DurabilityCosts { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn DurabilityQuality() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS DurabilityQuality (
        id INTEGER PRIMARY KEY NOT NULL,
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO DurabilityQuality (
        id,
        data
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        data
    FROM `DurabilityQuality`;"
    )
}


pub(crate) fn durability_quality_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<durability_quality::DurabilityQuality, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(durability_quality::DurabilityQualityRow {
            id: row.get::<_, i32>(0)?.into(),
            data: row.get::<_, f32>(1)?.into(),
        });
    }
    Ok(durability_quality::DurabilityQuality { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Emotes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Emotes (
        id INTEGER PRIMARY KEY NOT NULL,
        emote_slash_command TEXT  NOT NULL,
        anim_id INTEGER  NOT NULL,
        emote_flags INTEGER  NOT NULL,
        emote_spec_proc INTEGER  NOT NULL,
        emote_spec_proc_param INTEGER  NOT NULL,
        event_sound_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Emotes (
        id,
        emote_slash_command,
        anim_id,
        emote_flags,
        emote_spec_proc,
        emote_spec_proc_param,
        event_sound_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        emote_slash_command,
        anim_id,
        emote_flags,
        emote_spec_proc,
        emote_spec_proc_param,
        event_sound_id
    FROM `Emotes`;"
    )
}


pub(crate) fn emotes_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<emotes::Emotes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(emotes::EmotesRow {
            id: row.get::<_, i32>(0)?.into(),
            emote_slash_command: row.get::<_, String>(1)?.into(),
            anim_id: row.get::<_, i32>(2)?.into(),
            emote_flags: row.get::<_, i32>(3)?.into(),
            emote_spec_proc: row.get::<_, i32>(4)?.into(),
            emote_spec_proc_param: row.get::<_, i32>(5)?.into(),
            event_sound_id: row.get::<_, i32>(6)?.into(),
        });
    }
    Ok(emotes::Emotes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn EmotesText() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS EmotesText (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        emote_id INTEGER  NOT NULL,
        emote_text_0 INTEGER NOT NULL,
        emote_text_1 INTEGER NOT NULL,
        emote_text_2 INTEGER NOT NULL,
        emote_text_3 INTEGER NOT NULL,
        emote_text_4 INTEGER NOT NULL,
        emote_text_5 INTEGER NOT NULL,
        emote_text_6 INTEGER NOT NULL,
        emote_text_7 INTEGER NOT NULL,
        emote_text_8 INTEGER NOT NULL,
        emote_text_9 INTEGER NOT NULL,
        emote_text_10 INTEGER NOT NULL,
        emote_text_11 INTEGER NOT NULL,
        emote_text_12 INTEGER NOT NULL,
        emote_text_13 INTEGER NOT NULL,
        emote_text_14 INTEGER NOT NULL,
        emote_text_15 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO EmotesText (
        id,
        name,
        emote_id,
        emote_text_0,
        emote_text_1,
        emote_text_2,
        emote_text_3,
        emote_text_4,
        emote_text_5,
        emote_text_6,
        emote_text_7,
        emote_text_8,
        emote_text_9,
        emote_text_10,
        emote_text_11,
        emote_text_12,
        emote_text_13,
        emote_text_14,
        emote_text_15
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        name,
        emote_id,
        emote_text_0,
        emote_text_1,
        emote_text_2,
        emote_text_3,
        emote_text_4,
        emote_text_5,
        emote_text_6,
        emote_text_7,
        emote_text_8,
        emote_text_9,
        emote_text_10,
        emote_text_11,
        emote_text_12,
        emote_text_13,
        emote_text_14,
        emote_text_15
    FROM `EmotesText`;"
    )
}


pub(crate) fn emotes_text_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<emotes_text::EmotesText, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(emotes_text::EmotesTextRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            emote_id: row.get::<_, i32>(2)?.into(),
            emote_text: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(),             ],
        });
    }
    Ok(emotes_text::EmotesText { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn EmotesTextData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS EmotesTextData (
        id INTEGER PRIMARY KEY NOT NULL,
        text_lang_en_gb TEXT NOT NULL,
        text_lang_ko_kr TEXT NOT NULL,
        text_lang_fr_fr TEXT NOT NULL,
        text_lang_de_de TEXT NOT NULL,
        text_lang_en_cn TEXT NOT NULL,
        text_lang_en_tw TEXT NOT NULL,
        text_lang_es_es TEXT NOT NULL,
        text_lang_es_mx TEXT NOT NULL,
        text_lang_ru_ru TEXT NOT NULL,
        text_lang_ja_jp TEXT NOT NULL,
        text_lang_pt_pt TEXT NOT NULL,
        text_lang_it_it TEXT NOT NULL,
        text_lang_unknown_12 TEXT NOT NULL,
        text_lang_unknown_13 TEXT NOT NULL,
        text_lang_unknown_14 TEXT NOT NULL,
        text_lang_unknown_15 TEXT NOT NULL,
        text_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO EmotesTextData (
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
    FROM `EmotesTextData`;"
    )
}


pub(crate) fn emotes_text_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<emotes_text_data::EmotesTextData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(emotes_text_data::EmotesTextDataRow {
            id: row.get::<_, i32>(0)?.into(),
            text_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(emotes_text_data::EmotesTextData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn EmotesTextSound() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS EmotesTextSound (
        id INTEGER PRIMARY KEY NOT NULL,
        emotes_text_id INTEGER  NOT NULL,
        race_id INTEGER  NOT NULL,
        sex_id INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO EmotesTextSound (
        id,
        emotes_text_id,
        race_id,
        sex_id,
        sound_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        emotes_text_id,
        race_id,
        sex_id,
        sound_id
    FROM `EmotesTextSound`;"
    )
}


pub(crate) fn emotes_text_sound_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<emotes_text_sound::EmotesTextSound, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(emotes_text_sound::EmotesTextSoundRow {
            id: row.get::<_, i32>(0)?.into(),
            emotes_text_id: row.get::<_, i32>(1)?.into(),
            race_id: row.get::<_, i32>(2)?.into(),
            sex_id: row.get::<_, i32>(3)?.into(),
            sound_id: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(emotes_text_sound::EmotesTextSound { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn EnvironmentalDamage() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS EnvironmentalDamage (
        id INTEGER PRIMARY KEY NOT NULL,
        enum_id INTEGER  NOT NULL,
        visualkit_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO EnvironmentalDamage (
        id,
        enum_id,
        visualkit_id
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        enum_id,
        visualkit_id
    FROM `EnvironmentalDamage`;"
    )
}


pub(crate) fn environmental_damage_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<environmental_damage::EnvironmentalDamage, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(environmental_damage::EnvironmentalDamageRow {
            id: row.get::<_, i32>(0)?.into(),
            enum_id: row.get::<_, i32>(1)?.into(),
            visualkit_id: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(environmental_damage::EnvironmentalDamage { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Exhaustion() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Exhaustion (
        id INTEGER PRIMARY KEY NOT NULL,
        xp INTEGER  NOT NULL,
        factor REAL  NOT NULL,
        outdoor_hours REAL  NOT NULL,
        inn_hours REAL  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        threshold REAL  NOT NULL
    );"
    ,
    "INSERT INTO Exhaustion (
        id,
        xp,
        factor,
        outdoor_hours,
        inn_hours,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        threshold
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        xp,
        factor,
        outdoor_hours,
        inn_hours,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        threshold
    FROM `Exhaustion`;"
    )
}


pub(crate) fn exhaustion_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<exhaustion::Exhaustion, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(exhaustion::ExhaustionRow {
            id: row.get::<_, i32>(0)?.into(),
            xp: row.get::<_, i32>(1)?.into(),
            factor: row.get::<_, f32>(2)?.into(),
            outdoor_hours: row.get::<_, f32>(3)?.into(),
            inn_hours: row.get::<_, f32>(4)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
            threshold: row.get::<_, f32>(22)?.into(),
        });
    }
    Ok(exhaustion::Exhaustion { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Faction() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Faction (
        id INTEGER PRIMARY KEY NOT NULL,
        reputation_index INTEGER  NOT NULL,
        reputation_race_mask_0 INTEGER NOT NULL,
        reputation_race_mask_1 INTEGER NOT NULL,
        reputation_race_mask_2 INTEGER NOT NULL,
        reputation_race_mask_3 INTEGER NOT NULL,
        reputation_class_mask_0 INTEGER NOT NULL,
        reputation_class_mask_1 INTEGER NOT NULL,
        reputation_class_mask_2 INTEGER NOT NULL,
        reputation_class_mask_3 INTEGER NOT NULL,
        reputation_base_0 INTEGER NOT NULL,
        reputation_base_1 INTEGER NOT NULL,
        reputation_base_2 INTEGER NOT NULL,
        reputation_base_3 INTEGER NOT NULL,
        reputation_flags_0 INTEGER NOT NULL,
        reputation_flags_1 INTEGER NOT NULL,
        reputation_flags_2 INTEGER NOT NULL,
        reputation_flags_3 INTEGER NOT NULL,
        parent_faction_id INTEGER  NOT NULL,
        parent_faction_mod_0 REAL NOT NULL,
        parent_faction_mod_1 REAL NOT NULL,
        parent_faction_cap_0 INTEGER NOT NULL,
        parent_faction_cap_1 INTEGER NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Faction (
        id,
        reputation_index,
        reputation_race_mask_0,
        reputation_race_mask_1,
        reputation_race_mask_2,
        reputation_race_mask_3,
        reputation_class_mask_0,
        reputation_class_mask_1,
        reputation_class_mask_2,
        reputation_class_mask_3,
        reputation_base_0,
        reputation_base_1,
        reputation_base_2,
        reputation_base_3,
        reputation_flags_0,
        reputation_flags_1,
        reputation_flags_2,
        reputation_flags_3,
        parent_faction_id,
        parent_faction_mod_0,
        parent_faction_mod_1,
        parent_faction_cap_0,
        parent_faction_cap_1,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57
    );"
    ,
    "SELECT
        id,
        reputation_index,
        reputation_race_mask_0,
        reputation_race_mask_1,
        reputation_race_mask_2,
        reputation_race_mask_3,
        reputation_class_mask_0,
        reputation_class_mask_1,
        reputation_class_mask_2,
        reputation_class_mask_3,
        reputation_base_0,
        reputation_base_1,
        reputation_base_2,
        reputation_base_3,
        reputation_flags_0,
        reputation_flags_1,
        reputation_flags_2,
        reputation_flags_3,
        parent_faction_id,
        parent_faction_mod_0,
        parent_faction_mod_1,
        parent_faction_cap_0,
        parent_faction_cap_1,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
    FROM `Faction`;"
    )
}


pub(crate) fn faction_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<faction::Faction, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(faction::FactionRow {
            id: row.get::<_, i32>(0)?.into(),
            reputation_index: row.get::<_, i32>(1)?.into(),
            reputation_race_mask: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
            reputation_class_mask: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(),             ],
            reputation_base: [row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            reputation_flags: [row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(),             ],
            parent_faction_id: row.get::<_, i32>(18)?.into(),
            parent_faction_mod: [row.get::<_, f32>(19)?.into(), row.get::<_, f32>(20)?.into(),             ],
            parent_faction_cap: [row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(23)?.into(),
                ko_kr: row.get::<_, String>(24)?.into(),
                fr_fr: row.get::<_, String>(25)?.into(),
                de_de: row.get::<_, String>(26)?.into(),
                en_cn: row.get::<_, String>(27)?.into(),
                en_tw: row.get::<_, String>(28)?.into(),
                es_es: row.get::<_, String>(29)?.into(),
                es_mx: row.get::<_, String>(30)?.into(),
                ru_ru: row.get::<_, String>(31)?.into(),
                ja_jp: row.get::<_, String>(32)?.into(),
                pt_pt: row.get::<_, String>(33)?.into(),
                it_it: row.get::<_, String>(34)?.into(),
                unknown_12: row.get::<_, String>(35)?.into(),
                unknown_13: row.get::<_, String>(36)?.into(),
                unknown_14: row.get::<_, String>(37)?.into(),
                unknown_15: row.get::<_, String>(38)?.into(),
                flags: row.get::<_, u32>(39)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(40)?.into(),
                ko_kr: row.get::<_, String>(41)?.into(),
                fr_fr: row.get::<_, String>(42)?.into(),
                de_de: row.get::<_, String>(43)?.into(),
                en_cn: row.get::<_, String>(44)?.into(),
                en_tw: row.get::<_, String>(45)?.into(),
                es_es: row.get::<_, String>(46)?.into(),
                es_mx: row.get::<_, String>(47)?.into(),
                ru_ru: row.get::<_, String>(48)?.into(),
                ja_jp: row.get::<_, String>(49)?.into(),
                pt_pt: row.get::<_, String>(50)?.into(),
                it_it: row.get::<_, String>(51)?.into(),
                unknown_12: row.get::<_, String>(52)?.into(),
                unknown_13: row.get::<_, String>(53)?.into(),
                unknown_14: row.get::<_, String>(54)?.into(),
                unknown_15: row.get::<_, String>(55)?.into(),
                flags: row.get::<_, u32>(56)?.into(),
            },
        });
    }
    Ok(faction::Faction { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn FactionGroup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS FactionGroup (
        id INTEGER PRIMARY KEY NOT NULL,
        mask_id INTEGER  NOT NULL,
        internal_name TEXT  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO FactionGroup (
        id,
        mask_id,
        internal_name,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        mask_id,
        internal_name,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `FactionGroup`;"
    )
}


pub(crate) fn faction_group_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<faction_group::FactionGroup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(faction_group::FactionGroupRow {
            id: row.get::<_, i32>(0)?.into(),
            mask_id: row.get::<_, i32>(1)?.into(),
            internal_name: row.get::<_, String>(2)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
        });
    }
    Ok(faction_group::FactionGroup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn FactionTemplate() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS FactionTemplate (
        id INTEGER PRIMARY KEY NOT NULL,
        faction INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        faction_group INTEGER  NOT NULL,
        friend_group INTEGER  NOT NULL,
        enemy_group INTEGER  NOT NULL,
        enemies_0 INTEGER NOT NULL,
        enemies_1 INTEGER NOT NULL,
        enemies_2 INTEGER NOT NULL,
        enemies_3 INTEGER NOT NULL,
        friend_0 INTEGER NOT NULL,
        friend_1 INTEGER NOT NULL,
        friend_2 INTEGER NOT NULL,
        friend_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO FactionTemplate (
        id,
        faction,
        flags,
        faction_group,
        friend_group,
        enemy_group,
        enemies_0,
        enemies_1,
        enemies_2,
        enemies_3,
        friend_0,
        friend_1,
        friend_2,
        friend_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14
    );"
    ,
    "SELECT
        id,
        faction,
        flags,
        faction_group,
        friend_group,
        enemy_group,
        enemies_0,
        enemies_1,
        enemies_2,
        enemies_3,
        friend_0,
        friend_1,
        friend_2,
        friend_3
    FROM `FactionTemplate`;"
    )
}


pub(crate) fn faction_template_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<faction_template::FactionTemplate, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(faction_template::FactionTemplateRow {
            id: row.get::<_, i32>(0)?.into(),
            faction: row.get::<_, i32>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
            faction_group: row.get::<_, i32>(3)?.into(),
            friend_group: row.get::<_, i32>(4)?.into(),
            enemy_group: row.get::<_, i32>(5)?.into(),
            enemies: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(),             ],
            friend: [row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
        });
    }
    Ok(faction_template::FactionTemplate { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn FileData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS FileData (
        id INTEGER PRIMARY KEY NOT NULL,
        filename TEXT  NOT NULL,
        filepath TEXT  NOT NULL
    );"
    ,
    "INSERT INTO FileData (
        id,
        filename,
        filepath
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        filename,
        filepath
    FROM `FileData`;"
    )
}


pub(crate) fn file_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<file_data::FileData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(file_data::FileDataRow {
            id: row.get::<_, i32>(0)?.into(),
            filename: row.get::<_, String>(1)?.into(),
            filepath: row.get::<_, String>(2)?.into(),
        });
    }
    Ok(file_data::FileData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn FootprintTextures() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS FootprintTextures (
        id INTEGER PRIMARY KEY NOT NULL,
        footstep_filename TEXT  NOT NULL
    );"
    ,
    "INSERT INTO FootprintTextures (
        id,
        footstep_filename
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        footstep_filename
    FROM `FootprintTextures`;"
    )
}


pub(crate) fn footprint_textures_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<footprint_textures::FootprintTextures, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(footprint_textures::FootprintTexturesRow {
            id: row.get::<_, i32>(0)?.into(),
            footstep_filename: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(footprint_textures::FootprintTextures { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn FootstepTerrainLookup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS FootstepTerrainLookup (
        id INTEGER PRIMARY KEY NOT NULL,
        creature_footstep_id INTEGER  NOT NULL,
        terrain_sound_id INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        sound_id_splash INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO FootstepTerrainLookup (
        id,
        creature_footstep_id,
        terrain_sound_id,
        sound_id,
        sound_id_splash
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        creature_footstep_id,
        terrain_sound_id,
        sound_id,
        sound_id_splash
    FROM `FootstepTerrainLookup`;"
    )
}


pub(crate) fn footstep_terrain_lookup_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<footstep_terrain_lookup::FootstepTerrainLookup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(footstep_terrain_lookup::FootstepTerrainLookupRow {
            id: row.get::<_, i32>(0)?.into(),
            creature_footstep_id: row.get::<_, i32>(1)?.into(),
            terrain_sound_id: row.get::<_, i32>(2)?.into(),
            sound_id: row.get::<_, i32>(3)?.into(),
            sound_id_splash: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(footstep_terrain_lookup::FootstepTerrainLookup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GMSurveyAnswers() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GMSurveyAnswers (
        id INTEGER PRIMARY KEY NOT NULL,
        sort_index INTEGER  NOT NULL,
        g_m_survey_question_id INTEGER  NOT NULL,
        answer_lang_en_gb TEXT NOT NULL,
        answer_lang_ko_kr TEXT NOT NULL,
        answer_lang_fr_fr TEXT NOT NULL,
        answer_lang_de_de TEXT NOT NULL,
        answer_lang_en_cn TEXT NOT NULL,
        answer_lang_en_tw TEXT NOT NULL,
        answer_lang_es_es TEXT NOT NULL,
        answer_lang_es_mx TEXT NOT NULL,
        answer_lang_ru_ru TEXT NOT NULL,
        answer_lang_ja_jp TEXT NOT NULL,
        answer_lang_pt_pt TEXT NOT NULL,
        answer_lang_it_it TEXT NOT NULL,
        answer_lang_unknown_12 TEXT NOT NULL,
        answer_lang_unknown_13 TEXT NOT NULL,
        answer_lang_unknown_14 TEXT NOT NULL,
        answer_lang_unknown_15 TEXT NOT NULL,
        answer_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO GMSurveyAnswers (
        id,
        sort_index,
        g_m_survey_question_id,
        answer_lang_en_gb,
        answer_lang_ko_kr,
        answer_lang_fr_fr,
        answer_lang_de_de,
        answer_lang_en_cn,
        answer_lang_en_tw,
        answer_lang_es_es,
        answer_lang_es_mx,
        answer_lang_ru_ru,
        answer_lang_ja_jp,
        answer_lang_pt_pt,
        answer_lang_it_it,
        answer_lang_unknown_12,
        answer_lang_unknown_13,
        answer_lang_unknown_14,
        answer_lang_unknown_15,
        answer_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        sort_index,
        g_m_survey_question_id,
        answer_lang_en_gb,
        answer_lang_ko_kr,
        answer_lang_fr_fr,
        answer_lang_de_de,
        answer_lang_en_cn,
        answer_lang_en_tw,
        answer_lang_es_es,
        answer_lang_es_mx,
        answer_lang_ru_ru,
        answer_lang_ja_jp,
        answer_lang_pt_pt,
        answer_lang_it_it,
        answer_lang_unknown_12,
        answer_lang_unknown_13,
        answer_lang_unknown_14,
        answer_lang_unknown_15,
        answer_lang_flags
    FROM `GMSurveyAnswers`;"
    )
}


pub(crate) fn gm_survey_answers_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gm_survey_answers::GMSurveyAnswers, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gm_survey_answers::GMSurveyAnswersRow {
            id: row.get::<_, i32>(0)?.into(),
            sort_index: row.get::<_, i32>(1)?.into(),
            g_m_survey_question_id: row.get::<_, i32>(2)?.into(),
            answer_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
        });
    }
    Ok(gm_survey_answers::GMSurveyAnswers { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GMSurveyCurrentSurvey() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GMSurveyCurrentSurvey (
        id INTEGER PRIMARY KEY NOT NULL,
        gm_survey_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GMSurveyCurrentSurvey (
        id,
        gm_survey_id
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        gm_survey_id
    FROM `GMSurveyCurrentSurvey`;"
    )
}


pub(crate) fn gm_survey_current_survey_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gm_survey_current_survey::GMSurveyCurrentSurvey, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gm_survey_current_survey::GMSurveyCurrentSurveyRow {
            id: row.get::<_, i32>(0)?.into(),
            gm_survey_id: row.get::<_, i32>(1)?.into(),
        });
    }
    Ok(gm_survey_current_survey::GMSurveyCurrentSurvey { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GMSurveyQuestions() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GMSurveyQuestions (
        id INTEGER PRIMARY KEY NOT NULL,
        question_lang_en_gb TEXT NOT NULL,
        question_lang_ko_kr TEXT NOT NULL,
        question_lang_fr_fr TEXT NOT NULL,
        question_lang_de_de TEXT NOT NULL,
        question_lang_en_cn TEXT NOT NULL,
        question_lang_en_tw TEXT NOT NULL,
        question_lang_es_es TEXT NOT NULL,
        question_lang_es_mx TEXT NOT NULL,
        question_lang_ru_ru TEXT NOT NULL,
        question_lang_ja_jp TEXT NOT NULL,
        question_lang_pt_pt TEXT NOT NULL,
        question_lang_it_it TEXT NOT NULL,
        question_lang_unknown_12 TEXT NOT NULL,
        question_lang_unknown_13 TEXT NOT NULL,
        question_lang_unknown_14 TEXT NOT NULL,
        question_lang_unknown_15 TEXT NOT NULL,
        question_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO GMSurveyQuestions (
        id,
        question_lang_en_gb,
        question_lang_ko_kr,
        question_lang_fr_fr,
        question_lang_de_de,
        question_lang_en_cn,
        question_lang_en_tw,
        question_lang_es_es,
        question_lang_es_mx,
        question_lang_ru_ru,
        question_lang_ja_jp,
        question_lang_pt_pt,
        question_lang_it_it,
        question_lang_unknown_12,
        question_lang_unknown_13,
        question_lang_unknown_14,
        question_lang_unknown_15,
        question_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        question_lang_en_gb,
        question_lang_ko_kr,
        question_lang_fr_fr,
        question_lang_de_de,
        question_lang_en_cn,
        question_lang_en_tw,
        question_lang_es_es,
        question_lang_es_mx,
        question_lang_ru_ru,
        question_lang_ja_jp,
        question_lang_pt_pt,
        question_lang_it_it,
        question_lang_unknown_12,
        question_lang_unknown_13,
        question_lang_unknown_14,
        question_lang_unknown_15,
        question_lang_flags
    FROM `GMSurveyQuestions`;"
    )
}


pub(crate) fn gm_survey_questions_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gm_survey_questions::GMSurveyQuestions, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gm_survey_questions::GMSurveyQuestionsRow {
            id: row.get::<_, i32>(0)?.into(),
            question_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(gm_survey_questions::GMSurveyQuestions { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GMSurveySurveys() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GMSurveySurveys (
        id INTEGER PRIMARY KEY NOT NULL,
        q_0 INTEGER NOT NULL,
        q_1 INTEGER NOT NULL,
        q_2 INTEGER NOT NULL,
        q_3 INTEGER NOT NULL,
        q_4 INTEGER NOT NULL,
        q_5 INTEGER NOT NULL,
        q_6 INTEGER NOT NULL,
        q_7 INTEGER NOT NULL,
        q_8 INTEGER NOT NULL,
        q_9 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO GMSurveySurveys (
        id,
        q_0,
        q_1,
        q_2,
        q_3,
        q_4,
        q_5,
        q_6,
        q_7,
        q_8,
        q_9
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        q_0,
        q_1,
        q_2,
        q_3,
        q_4,
        q_5,
        q_6,
        q_7,
        q_8,
        q_9
    FROM `GMSurveySurveys`;"
    )
}


pub(crate) fn gm_survey_surveys_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gm_survey_surveys::GMSurveySurveys, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gm_survey_surveys::GMSurveySurveysRow {
            id: row.get::<_, i32>(0)?.into(),
            q: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
        });
    }
    Ok(gm_survey_surveys::GMSurveySurveys { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GMTicketCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GMTicketCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        category_lang_en_gb TEXT NOT NULL,
        category_lang_ko_kr TEXT NOT NULL,
        category_lang_fr_fr TEXT NOT NULL,
        category_lang_de_de TEXT NOT NULL,
        category_lang_en_cn TEXT NOT NULL,
        category_lang_en_tw TEXT NOT NULL,
        category_lang_es_es TEXT NOT NULL,
        category_lang_es_mx TEXT NOT NULL,
        category_lang_ru_ru TEXT NOT NULL,
        category_lang_ja_jp TEXT NOT NULL,
        category_lang_pt_pt TEXT NOT NULL,
        category_lang_it_it TEXT NOT NULL,
        category_lang_unknown_12 TEXT NOT NULL,
        category_lang_unknown_13 TEXT NOT NULL,
        category_lang_unknown_14 TEXT NOT NULL,
        category_lang_unknown_15 TEXT NOT NULL,
        category_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO GMTicketCategory (
        id,
        category_lang_en_gb,
        category_lang_ko_kr,
        category_lang_fr_fr,
        category_lang_de_de,
        category_lang_en_cn,
        category_lang_en_tw,
        category_lang_es_es,
        category_lang_es_mx,
        category_lang_ru_ru,
        category_lang_ja_jp,
        category_lang_pt_pt,
        category_lang_it_it,
        category_lang_unknown_12,
        category_lang_unknown_13,
        category_lang_unknown_14,
        category_lang_unknown_15,
        category_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        category_lang_en_gb,
        category_lang_ko_kr,
        category_lang_fr_fr,
        category_lang_de_de,
        category_lang_en_cn,
        category_lang_en_tw,
        category_lang_es_es,
        category_lang_es_mx,
        category_lang_ru_ru,
        category_lang_ja_jp,
        category_lang_pt_pt,
        category_lang_it_it,
        category_lang_unknown_12,
        category_lang_unknown_13,
        category_lang_unknown_14,
        category_lang_unknown_15,
        category_lang_flags
    FROM `GMTicketCategory`;"
    )
}


pub(crate) fn gm_ticket_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gm_ticket_category::GMTicketCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gm_ticket_category::GMTicketCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            category_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(gm_ticket_category::GMTicketCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GameObjectArtKit() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GameObjectArtKit (
        id INTEGER PRIMARY KEY NOT NULL,
        texture_variation_0 TEXT NOT NULL,
        texture_variation_1 TEXT NOT NULL,
        texture_variation_2 TEXT NOT NULL,
        attach_model_0 TEXT NOT NULL,
        attach_model_1 TEXT NOT NULL,
        attach_model_2 TEXT NOT NULL,
        attach_model_3 TEXT NOT NULL
    );"
    ,
    "INSERT INTO GameObjectArtKit (
        id,
        texture_variation_0,
        texture_variation_1,
        texture_variation_2,
        attach_model_0,
        attach_model_1,
        attach_model_2,
        attach_model_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        texture_variation_0,
        texture_variation_1,
        texture_variation_2,
        attach_model_0,
        attach_model_1,
        attach_model_2,
        attach_model_3
    FROM `GameObjectArtKit`;"
    )
}


pub(crate) fn game_object_art_kit_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<game_object_art_kit::GameObjectArtKit, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(game_object_art_kit::GameObjectArtKitRow {
            id: row.get::<_, i32>(0)?.into(),
            texture_variation: [row.get::<_, String>(1)?.into(), row.get::<_, String>(2)?.into(), row.get::<_, String>(3)?.into(),             ],
            attach_model: [row.get::<_, String>(4)?.into(), row.get::<_, String>(5)?.into(), row.get::<_, String>(6)?.into(), row.get::<_, String>(7)?.into(),             ],
        });
    }
    Ok(game_object_art_kit::GameObjectArtKit { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GameObjectDisplayInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GameObjectDisplayInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        model_name TEXT  NOT NULL,
        sound_0 INTEGER NOT NULL,
        sound_1 INTEGER NOT NULL,
        sound_2 INTEGER NOT NULL,
        sound_3 INTEGER NOT NULL,
        sound_4 INTEGER NOT NULL,
        sound_5 INTEGER NOT NULL,
        sound_6 INTEGER NOT NULL,
        sound_7 INTEGER NOT NULL,
        sound_8 INTEGER NOT NULL,
        sound_9 INTEGER NOT NULL,
        geo_box_min_0 REAL NOT NULL,
        geo_box_min_1 REAL NOT NULL,
        geo_box_min_2 REAL NOT NULL,
        geo_box_max_0 REAL NOT NULL,
        geo_box_max_1 REAL NOT NULL,
        geo_box_max_2 REAL NOT NULL,
        object_effect_package_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GameObjectDisplayInfo (
        id,
        model_name,
        sound_0,
        sound_1,
        sound_2,
        sound_3,
        sound_4,
        sound_5,
        sound_6,
        sound_7,
        sound_8,
        sound_9,
        geo_box_min_0,
        geo_box_min_1,
        geo_box_min_2,
        geo_box_max_0,
        geo_box_max_1,
        geo_box_max_2,
        object_effect_package_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        model_name,
        sound_0,
        sound_1,
        sound_2,
        sound_3,
        sound_4,
        sound_5,
        sound_6,
        sound_7,
        sound_8,
        sound_9,
        geo_box_min_0,
        geo_box_min_1,
        geo_box_min_2,
        geo_box_max_0,
        geo_box_max_1,
        geo_box_max_2,
        object_effect_package_id
    FROM `GameObjectDisplayInfo`;"
    )
}


pub(crate) fn game_object_display_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<game_object_display_info::GameObjectDisplayInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(game_object_display_info::GameObjectDisplayInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            model_name: row.get::<_, String>(1)?.into(),
            sound: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(),             ],
            geo_box_min: [row.get::<_, f32>(12)?.into(), row.get::<_, f32>(13)?.into(), row.get::<_, f32>(14)?.into(),             ],
            geo_box_max: [row.get::<_, f32>(15)?.into(), row.get::<_, f32>(16)?.into(), row.get::<_, f32>(17)?.into(),             ],
            object_effect_package_id: row.get::<_, i32>(18)?.into(),
        });
    }
    Ok(game_object_display_info::GameObjectDisplayInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GameTables() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GameTables (
        name TEXT  NOT NULL,
        num_rows INTEGER  NOT NULL,
        num_columns INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GameTables (
        name,
        num_rows,
        num_columns
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        name,
        num_rows,
        num_columns
    FROM `GameTables`;"
    )
}


pub(crate) fn game_tables_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<game_tables::GameTables, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(game_tables::GameTablesRow {
            name: row.get::<_, String>(0)?.into(),
            num_rows: row.get::<_, i32>(1)?.into(),
            num_columns: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(game_tables::GameTables { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GameTips() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GameTips (
        id INTEGER PRIMARY KEY NOT NULL,
        text_lang_en_gb TEXT NOT NULL,
        text_lang_ko_kr TEXT NOT NULL,
        text_lang_fr_fr TEXT NOT NULL,
        text_lang_de_de TEXT NOT NULL,
        text_lang_en_cn TEXT NOT NULL,
        text_lang_en_tw TEXT NOT NULL,
        text_lang_es_es TEXT NOT NULL,
        text_lang_es_mx TEXT NOT NULL,
        text_lang_ru_ru TEXT NOT NULL,
        text_lang_ja_jp TEXT NOT NULL,
        text_lang_pt_pt TEXT NOT NULL,
        text_lang_it_it TEXT NOT NULL,
        text_lang_unknown_12 TEXT NOT NULL,
        text_lang_unknown_13 TEXT NOT NULL,
        text_lang_unknown_14 TEXT NOT NULL,
        text_lang_unknown_15 TEXT NOT NULL,
        text_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO GameTips (
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
    FROM `GameTips`;"
    )
}


pub(crate) fn game_tips_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<game_tips::GameTips, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(game_tips::GameTipsRow {
            id: row.get::<_, i32>(0)?.into(),
            text_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(game_tips::GameTips { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GemProperties() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GemProperties (
        id INTEGER PRIMARY KEY NOT NULL,
        enchant_id INTEGER  NOT NULL,
        maxcount_inv INTEGER  NOT NULL,
        maxcount_item INTEGER  NOT NULL,
        ty INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GemProperties (
        id,
        enchant_id,
        maxcount_inv,
        maxcount_item,
        ty
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        enchant_id,
        maxcount_inv,
        maxcount_item,
        ty
    FROM `GemProperties`;"
    )
}


pub(crate) fn gem_properties_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gem_properties::GemProperties, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gem_properties::GemPropertiesRow {
            id: row.get::<_, i32>(0)?.into(),
            enchant_id: row.get::<_, i32>(1)?.into(),
            maxcount_inv: row.get::<_, i32>(2)?.into(),
            maxcount_item: row.get::<_, i32>(3)?.into(),
            ty: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(gem_properties::GemProperties { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GlyphProperties() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GlyphProperties (
        id INTEGER PRIMARY KEY NOT NULL,
        spell_id INTEGER  NOT NULL,
        glyph_slot_flags INTEGER  NOT NULL,
        spell_icon_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GlyphProperties (
        id,
        spell_id,
        glyph_slot_flags,
        spell_icon_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        spell_id,
        glyph_slot_flags,
        spell_icon_id
    FROM `GlyphProperties`;"
    )
}


pub(crate) fn glyph_properties_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<glyph_properties::GlyphProperties, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(glyph_properties::GlyphPropertiesRow {
            id: row.get::<_, i32>(0)?.into(),
            spell_id: row.get::<_, i32>(1)?.into(),
            glyph_slot_flags: row.get::<_, i32>(2)?.into(),
            spell_icon_id: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(glyph_properties::GlyphProperties { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GlyphSlot() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GlyphSlot (
        id INTEGER PRIMARY KEY NOT NULL,
        ty INTEGER  NOT NULL,
        tooltip INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GlyphSlot (
        id,
        ty,
        tooltip
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        ty,
        tooltip
    FROM `GlyphSlot`;"
    )
}


pub(crate) fn glyph_slot_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<glyph_slot::GlyphSlot, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(glyph_slot::GlyphSlotRow {
            id: row.get::<_, i32>(0)?.into(),
            ty: row.get::<_, i32>(1)?.into(),
            tooltip: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(glyph_slot::GlyphSlot { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GroundEffectDoodad() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GroundEffectDoodad (
        id INTEGER PRIMARY KEY NOT NULL,
        doodadpath TEXT  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GroundEffectDoodad (
        id,
        doodadpath,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        doodadpath,
        flags
    FROM `GroundEffectDoodad`;"
    )
}


pub(crate) fn ground_effect_doodad_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<ground_effect_doodad::GroundEffectDoodad, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(ground_effect_doodad::GroundEffectDoodadRow {
            id: row.get::<_, i32>(0)?.into(),
            doodadpath: row.get::<_, String>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(ground_effect_doodad::GroundEffectDoodad { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn GroundEffectTexture() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS GroundEffectTexture (
        id INTEGER PRIMARY KEY NOT NULL,
        doodad_id_0 INTEGER NOT NULL,
        doodad_id_1 INTEGER NOT NULL,
        doodad_id_2 INTEGER NOT NULL,
        doodad_id_3 INTEGER NOT NULL,
        doodad_weight_0 INTEGER NOT NULL,
        doodad_weight_1 INTEGER NOT NULL,
        doodad_weight_2 INTEGER NOT NULL,
        doodad_weight_3 INTEGER NOT NULL,
        density INTEGER  NOT NULL,
        sound INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO GroundEffectTexture (
        id,
        doodad_id_0,
        doodad_id_1,
        doodad_id_2,
        doodad_id_3,
        doodad_weight_0,
        doodad_weight_1,
        doodad_weight_2,
        doodad_weight_3,
        density,
        sound
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        doodad_id_0,
        doodad_id_1,
        doodad_id_2,
        doodad_id_3,
        doodad_weight_0,
        doodad_weight_1,
        doodad_weight_2,
        doodad_weight_3,
        density,
        sound
    FROM `GroundEffectTexture`;"
    )
}


pub(crate) fn ground_effect_texture_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<ground_effect_texture::GroundEffectTexture, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(ground_effect_texture::GroundEffectTextureRow {
            id: row.get::<_, i32>(0)?.into(),
            doodad_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            doodad_weight: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            density: row.get::<_, i32>(9)?.into(),
            sound: row.get::<_, i32>(10)?.into(),
        });
    }
    Ok(ground_effect_texture::GroundEffectTexture { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn HelmetGeosetVisData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS HelmetGeosetVisData (
        id INTEGER PRIMARY KEY NOT NULL,
        hide_geoset_0 INTEGER NOT NULL,
        hide_geoset_1 INTEGER NOT NULL,
        hide_geoset_2 INTEGER NOT NULL,
        hide_geoset_3 INTEGER NOT NULL,
        hide_geoset_4 INTEGER NOT NULL,
        hide_geoset_5 INTEGER NOT NULL,
        hide_geoset_6 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO HelmetGeosetVisData (
        id,
        hide_geoset_0,
        hide_geoset_1,
        hide_geoset_2,
        hide_geoset_3,
        hide_geoset_4,
        hide_geoset_5,
        hide_geoset_6
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        hide_geoset_0,
        hide_geoset_1,
        hide_geoset_2,
        hide_geoset_3,
        hide_geoset_4,
        hide_geoset_5,
        hide_geoset_6
    FROM `HelmetGeosetVisData`;"
    )
}


pub(crate) fn helmet_geoset_vis_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<helmet_geoset_vis_data::HelmetGeosetVisData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(helmet_geoset_vis_data::HelmetGeosetVisDataRow {
            id: row.get::<_, i32>(0)?.into(),
            hide_geoset: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(),             ],
        });
    }
    Ok(helmet_geoset_vis_data::HelmetGeosetVisData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn HolidayDescriptions() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS HolidayDescriptions (
        id INTEGER PRIMARY KEY NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO HolidayDescriptions (
        id,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
    FROM `HolidayDescriptions`;"
    )
}


pub(crate) fn holiday_descriptions_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<holiday_descriptions::HolidayDescriptions, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(holiday_descriptions::HolidayDescriptionsRow {
            id: row.get::<_, i32>(0)?.into(),
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(holiday_descriptions::HolidayDescriptions { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn HolidayNames() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS HolidayNames (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO HolidayNames (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `HolidayNames`;"
    )
}


pub(crate) fn holiday_names_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<holiday_names::HolidayNames, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(holiday_names::HolidayNamesRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(holiday_names::HolidayNames { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Holidays() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Holidays (
        id INTEGER PRIMARY KEY NOT NULL,
        duration_0 INTEGER NOT NULL,
        duration_1 INTEGER NOT NULL,
        duration_2 INTEGER NOT NULL,
        duration_3 INTEGER NOT NULL,
        duration_4 INTEGER NOT NULL,
        duration_5 INTEGER NOT NULL,
        duration_6 INTEGER NOT NULL,
        duration_7 INTEGER NOT NULL,
        duration_8 INTEGER NOT NULL,
        duration_9 INTEGER NOT NULL,
        date_0 INTEGER NOT NULL,
        date_1 INTEGER NOT NULL,
        date_2 INTEGER NOT NULL,
        date_3 INTEGER NOT NULL,
        date_4 INTEGER NOT NULL,
        date_5 INTEGER NOT NULL,
        date_6 INTEGER NOT NULL,
        date_7 INTEGER NOT NULL,
        date_8 INTEGER NOT NULL,
        date_9 INTEGER NOT NULL,
        date_10 INTEGER NOT NULL,
        date_11 INTEGER NOT NULL,
        date_12 INTEGER NOT NULL,
        date_13 INTEGER NOT NULL,
        date_14 INTEGER NOT NULL,
        date_15 INTEGER NOT NULL,
        date_16 INTEGER NOT NULL,
        date_17 INTEGER NOT NULL,
        date_18 INTEGER NOT NULL,
        date_19 INTEGER NOT NULL,
        date_20 INTEGER NOT NULL,
        date_21 INTEGER NOT NULL,
        date_22 INTEGER NOT NULL,
        date_23 INTEGER NOT NULL,
        date_24 INTEGER NOT NULL,
        date_25 INTEGER NOT NULL,
        region INTEGER  NOT NULL,
        looping INTEGER  NOT NULL,
        calendar_flags_0 INTEGER NOT NULL,
        calendar_flags_1 INTEGER NOT NULL,
        calendar_flags_2 INTEGER NOT NULL,
        calendar_flags_3 INTEGER NOT NULL,
        calendar_flags_4 INTEGER NOT NULL,
        calendar_flags_5 INTEGER NOT NULL,
        calendar_flags_6 INTEGER NOT NULL,
        calendar_flags_7 INTEGER NOT NULL,
        calendar_flags_8 INTEGER NOT NULL,
        calendar_flags_9 INTEGER NOT NULL,
        holiday_name_id INTEGER  NOT NULL,
        holiday_description_id INTEGER  NOT NULL,
        texture_file_name TEXT  NOT NULL,
        priority INTEGER  NOT NULL,
        calendar_filter_type INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Holidays (
        id,
        duration_0,
        duration_1,
        duration_2,
        duration_3,
        duration_4,
        duration_5,
        duration_6,
        duration_7,
        duration_8,
        duration_9,
        date_0,
        date_1,
        date_2,
        date_3,
        date_4,
        date_5,
        date_6,
        date_7,
        date_8,
        date_9,
        date_10,
        date_11,
        date_12,
        date_13,
        date_14,
        date_15,
        date_16,
        date_17,
        date_18,
        date_19,
        date_20,
        date_21,
        date_22,
        date_23,
        date_24,
        date_25,
        region,
        looping,
        calendar_flags_0,
        calendar_flags_1,
        calendar_flags_2,
        calendar_flags_3,
        calendar_flags_4,
        calendar_flags_5,
        calendar_flags_6,
        calendar_flags_7,
        calendar_flags_8,
        calendar_flags_9,
        holiday_name_id,
        holiday_description_id,
        texture_file_name,
        priority,
        calendar_filter_type,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55
    );"
    ,
    "SELECT
        id,
        duration_0,
        duration_1,
        duration_2,
        duration_3,
        duration_4,
        duration_5,
        duration_6,
        duration_7,
        duration_8,
        duration_9,
        date_0,
        date_1,
        date_2,
        date_3,
        date_4,
        date_5,
        date_6,
        date_7,
        date_8,
        date_9,
        date_10,
        date_11,
        date_12,
        date_13,
        date_14,
        date_15,
        date_16,
        date_17,
        date_18,
        date_19,
        date_20,
        date_21,
        date_22,
        date_23,
        date_24,
        date_25,
        region,
        looping,
        calendar_flags_0,
        calendar_flags_1,
        calendar_flags_2,
        calendar_flags_3,
        calendar_flags_4,
        calendar_flags_5,
        calendar_flags_6,
        calendar_flags_7,
        calendar_flags_8,
        calendar_flags_9,
        holiday_name_id,
        holiday_description_id,
        texture_file_name,
        priority,
        calendar_filter_type,
        flags
    FROM `Holidays`;"
    )
}


pub(crate) fn holidays_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<holidays::Holidays, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(holidays::HolidaysRow {
            id: row.get::<_, i32>(0)?.into(),
            duration: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            date: [row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(), row.get::<_, i32>(33)?.into(), row.get::<_, i32>(34)?.into(), row.get::<_, i32>(35)?.into(), row.get::<_, i32>(36)?.into(),             ],
            region: row.get::<_, i32>(37)?.into(),
            looping: row.get::<_, i32>(38)?.into(),
            calendar_flags: [row.get::<_, i32>(39)?.into(), row.get::<_, i32>(40)?.into(), row.get::<_, i32>(41)?.into(), row.get::<_, i32>(42)?.into(), row.get::<_, i32>(43)?.into(), row.get::<_, i32>(44)?.into(), row.get::<_, i32>(45)?.into(), row.get::<_, i32>(46)?.into(), row.get::<_, i32>(47)?.into(), row.get::<_, i32>(48)?.into(),             ],
            holiday_name_id: row.get::<_, i32>(49)?.into(),
            holiday_description_id: row.get::<_, i32>(50)?.into(),
            texture_file_name: row.get::<_, String>(51)?.into(),
            priority: row.get::<_, i32>(52)?.into(),
            calendar_filter_type: row.get::<_, i32>(53)?.into(),
            flags: row.get::<_, i32>(54)?.into(),
        });
    }
    Ok(holidays::Holidays { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Item() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Item (
        id INTEGER PRIMARY KEY NOT NULL,
        class_id INTEGER  NOT NULL,
        subclass_id INTEGER  NOT NULL,
        sound_override_subclass_id INTEGER  NOT NULL,
        material INTEGER  NOT NULL,
        display_info_id INTEGER  NOT NULL,
        inventory_type INTEGER  NOT NULL,
        sheathe_type INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Item (
        id,
        class_id,
        subclass_id,
        sound_override_subclass_id,
        material,
        display_info_id,
        inventory_type,
        sheathe_type
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        class_id,
        subclass_id,
        sound_override_subclass_id,
        material,
        display_info_id,
        inventory_type,
        sheathe_type
    FROM `Item`;"
    )
}


pub(crate) fn item_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item::Item, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item::ItemRow {
            id: row.get::<_, i32>(0)?.into(),
            class_id: row.get::<_, i32>(1)?.into(),
            subclass_id: row.get::<_, i32>(2)?.into(),
            sound_override_subclass_id: row.get::<_, i32>(3)?.into(),
            material: row.get::<_, i32>(4)?.into(),
            display_info_id: row.get::<_, i32>(5)?.into(),
            inventory_type: row.get::<_, i32>(6)?.into(),
            sheathe_type: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(item::Item { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemBagFamily() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemBagFamily (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemBagFamily (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `ItemBagFamily`;"
    )
}


pub(crate) fn item_bag_family_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_bag_family::ItemBagFamily, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_bag_family::ItemBagFamilyRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(item_bag_family::ItemBagFamily { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemClass() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemClass (
        class_id INTEGER  NOT NULL,
        subclass_map_id INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        class_name_lang_en_gb TEXT NOT NULL,
        class_name_lang_ko_kr TEXT NOT NULL,
        class_name_lang_fr_fr TEXT NOT NULL,
        class_name_lang_de_de TEXT NOT NULL,
        class_name_lang_en_cn TEXT NOT NULL,
        class_name_lang_en_tw TEXT NOT NULL,
        class_name_lang_es_es TEXT NOT NULL,
        class_name_lang_es_mx TEXT NOT NULL,
        class_name_lang_ru_ru TEXT NOT NULL,
        class_name_lang_ja_jp TEXT NOT NULL,
        class_name_lang_pt_pt TEXT NOT NULL,
        class_name_lang_it_it TEXT NOT NULL,
        class_name_lang_unknown_12 TEXT NOT NULL,
        class_name_lang_unknown_13 TEXT NOT NULL,
        class_name_lang_unknown_14 TEXT NOT NULL,
        class_name_lang_unknown_15 TEXT NOT NULL,
        class_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemClass (
        class_id,
        subclass_map_id,
        flags,
        class_name_lang_en_gb,
        class_name_lang_ko_kr,
        class_name_lang_fr_fr,
        class_name_lang_de_de,
        class_name_lang_en_cn,
        class_name_lang_en_tw,
        class_name_lang_es_es,
        class_name_lang_es_mx,
        class_name_lang_ru_ru,
        class_name_lang_ja_jp,
        class_name_lang_pt_pt,
        class_name_lang_it_it,
        class_name_lang_unknown_12,
        class_name_lang_unknown_13,
        class_name_lang_unknown_14,
        class_name_lang_unknown_15,
        class_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        class_id,
        subclass_map_id,
        flags,
        class_name_lang_en_gb,
        class_name_lang_ko_kr,
        class_name_lang_fr_fr,
        class_name_lang_de_de,
        class_name_lang_en_cn,
        class_name_lang_en_tw,
        class_name_lang_es_es,
        class_name_lang_es_mx,
        class_name_lang_ru_ru,
        class_name_lang_ja_jp,
        class_name_lang_pt_pt,
        class_name_lang_it_it,
        class_name_lang_unknown_12,
        class_name_lang_unknown_13,
        class_name_lang_unknown_14,
        class_name_lang_unknown_15,
        class_name_lang_flags
    FROM `ItemClass`;"
    )
}


pub(crate) fn item_class_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_class::ItemClass, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_class::ItemClassRow {
            class_id: row.get::<_, i32>(0)?.into(),
            subclass_map_id: row.get::<_, i32>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
            class_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
        });
    }
    Ok(item_class::ItemClass { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemCondExtCosts() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemCondExtCosts (
        id INTEGER PRIMARY KEY NOT NULL,
        cond_extended_cost INTEGER  NOT NULL,
        item_extended_cost_entry INTEGER  NOT NULL,
        arena_season INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ItemCondExtCosts (
        id,
        cond_extended_cost,
        item_extended_cost_entry,
        arena_season
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        cond_extended_cost,
        item_extended_cost_entry,
        arena_season
    FROM `ItemCondExtCosts`;"
    )
}


pub(crate) fn item_cond_ext_costs_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_cond_ext_costs::ItemCondExtCosts, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_cond_ext_costs::ItemCondExtCostsRow {
            id: row.get::<_, i32>(0)?.into(),
            cond_extended_cost: row.get::<_, i32>(1)?.into(),
            item_extended_cost_entry: row.get::<_, i32>(2)?.into(),
            arena_season: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(item_cond_ext_costs::ItemCondExtCosts { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemDisplayInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemDisplayInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        model_name_0 TEXT NOT NULL,
        model_name_1 TEXT NOT NULL,
        model_texture_0 TEXT NOT NULL,
        model_texture_1 TEXT NOT NULL,
        inventory_icon_0 TEXT NOT NULL,
        inventory_icon_1 TEXT NOT NULL,
        geoset_group_0 INTEGER NOT NULL,
        geoset_group_1 INTEGER NOT NULL,
        geoset_group_2 INTEGER NOT NULL,
        flags INTEGER  NOT NULL,
        spell_visual_id INTEGER  NOT NULL,
        group_sound_index INTEGER  NOT NULL,
        helmet_geoset_vis_id_0 INTEGER NOT NULL,
        helmet_geoset_vis_id_1 INTEGER NOT NULL,
        texture_0 TEXT NOT NULL,
        texture_1 TEXT NOT NULL,
        texture_2 TEXT NOT NULL,
        texture_3 TEXT NOT NULL,
        texture_4 TEXT NOT NULL,
        texture_5 TEXT NOT NULL,
        texture_6 TEXT NOT NULL,
        texture_7 TEXT NOT NULL,
        item_visual INTEGER  NOT NULL,
        particle_color_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ItemDisplayInfo (
        id,
        model_name_0,
        model_name_1,
        model_texture_0,
        model_texture_1,
        inventory_icon_0,
        inventory_icon_1,
        geoset_group_0,
        geoset_group_1,
        geoset_group_2,
        flags,
        spell_visual_id,
        group_sound_index,
        helmet_geoset_vis_id_0,
        helmet_geoset_vis_id_1,
        texture_0,
        texture_1,
        texture_2,
        texture_3,
        texture_4,
        texture_5,
        texture_6,
        texture_7,
        item_visual,
        particle_color_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25
    );"
    ,
    "SELECT
        id,
        model_name_0,
        model_name_1,
        model_texture_0,
        model_texture_1,
        inventory_icon_0,
        inventory_icon_1,
        geoset_group_0,
        geoset_group_1,
        geoset_group_2,
        flags,
        spell_visual_id,
        group_sound_index,
        helmet_geoset_vis_id_0,
        helmet_geoset_vis_id_1,
        texture_0,
        texture_1,
        texture_2,
        texture_3,
        texture_4,
        texture_5,
        texture_6,
        texture_7,
        item_visual,
        particle_color_id
    FROM `ItemDisplayInfo`;"
    )
}


pub(crate) fn item_display_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_display_info::ItemDisplayInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_display_info::ItemDisplayInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            model_name: [row.get::<_, String>(1)?.into(), row.get::<_, String>(2)?.into(),             ],
            model_texture: [row.get::<_, String>(3)?.into(), row.get::<_, String>(4)?.into(),             ],
            inventory_icon: [row.get::<_, String>(5)?.into(), row.get::<_, String>(6)?.into(),             ],
            geoset_group: [row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(),             ],
            flags: row.get::<_, i32>(10)?.into(),
            spell_visual_id: row.get::<_, i32>(11)?.into(),
            group_sound_index: row.get::<_, i32>(12)?.into(),
            helmet_geoset_vis_id: [row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(),             ],
            texture: [row.get::<_, String>(15)?.into(), row.get::<_, String>(16)?.into(), row.get::<_, String>(17)?.into(), row.get::<_, String>(18)?.into(), row.get::<_, String>(19)?.into(), row.get::<_, String>(20)?.into(), row.get::<_, String>(21)?.into(), row.get::<_, String>(22)?.into(),             ],
            item_visual: row.get::<_, i32>(23)?.into(),
            particle_color_id: row.get::<_, i32>(24)?.into(),
        });
    }
    Ok(item_display_info::ItemDisplayInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemExtendedCost() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemExtendedCost (
        id INTEGER PRIMARY KEY NOT NULL,
        honor_points INTEGER  NOT NULL,
        arena_points INTEGER  NOT NULL,
        arena_bracket INTEGER  NOT NULL,
        item_id_0 INTEGER NOT NULL,
        item_id_1 INTEGER NOT NULL,
        item_id_2 INTEGER NOT NULL,
        item_id_3 INTEGER NOT NULL,
        item_id_4 INTEGER NOT NULL,
        item_count_0 INTEGER NOT NULL,
        item_count_1 INTEGER NOT NULL,
        item_count_2 INTEGER NOT NULL,
        item_count_3 INTEGER NOT NULL,
        item_count_4 INTEGER NOT NULL,
        required_arena_rating INTEGER  NOT NULL,
        item_purchase_group INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ItemExtendedCost (
        id,
        honor_points,
        arena_points,
        arena_bracket,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_count_0,
        item_count_1,
        item_count_2,
        item_count_3,
        item_count_4,
        required_arena_rating,
        item_purchase_group
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16
    );"
    ,
    "SELECT
        id,
        honor_points,
        arena_points,
        arena_bracket,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_count_0,
        item_count_1,
        item_count_2,
        item_count_3,
        item_count_4,
        required_arena_rating,
        item_purchase_group
    FROM `ItemExtendedCost`;"
    )
}


pub(crate) fn item_extended_cost_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_extended_cost::ItemExtendedCost, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_extended_cost::ItemExtendedCostRow {
            id: row.get::<_, i32>(0)?.into(),
            honor_points: row.get::<_, i32>(1)?.into(),
            arena_points: row.get::<_, i32>(2)?.into(),
            arena_bracket: row.get::<_, i32>(3)?.into(),
            item_id: [row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            item_count: [row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            required_arena_rating: row.get::<_, i32>(14)?.into(),
            item_purchase_group: row.get::<_, i32>(15)?.into(),
        });
    }
    Ok(item_extended_cost::ItemExtendedCost { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemGroupSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemGroupSounds (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_0 INTEGER NOT NULL,
        sound_1 INTEGER NOT NULL,
        sound_2 INTEGER NOT NULL,
        sound_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemGroupSounds (
        id,
        sound_0,
        sound_1,
        sound_2,
        sound_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        sound_0,
        sound_1,
        sound_2,
        sound_3
    FROM `ItemGroupSounds`;"
    )
}


pub(crate) fn item_group_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_group_sounds::ItemGroupSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_group_sounds::ItemGroupSoundsRow {
            id: row.get::<_, i32>(0)?.into(),
            sound: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
        });
    }
    Ok(item_group_sounds::ItemGroupSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemLimitCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemLimitCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        quantity INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ItemLimitCategory (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        quantity,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        quantity,
        flags
    FROM `ItemLimitCategory`;"
    )
}


pub(crate) fn item_limit_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_limit_category::ItemLimitCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_limit_category::ItemLimitCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            quantity: row.get::<_, i32>(18)?.into(),
            flags: row.get::<_, i32>(19)?.into(),
        });
    }
    Ok(item_limit_category::ItemLimitCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemPetFood() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemPetFood (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemPetFood (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `ItemPetFood`;"
    )
}


pub(crate) fn item_pet_food_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_pet_food::ItemPetFood, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_pet_food::ItemPetFoodRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(item_pet_food::ItemPetFood { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemPurchaseGroup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemPurchaseGroup (
        id INTEGER PRIMARY KEY NOT NULL,
        item_id_0 INTEGER NOT NULL,
        item_id_1 INTEGER NOT NULL,
        item_id_2 INTEGER NOT NULL,
        item_id_3 INTEGER NOT NULL,
        item_id_4 INTEGER NOT NULL,
        item_id_5 INTEGER NOT NULL,
        item_id_6 INTEGER NOT NULL,
        item_id_7 INTEGER NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemPurchaseGroup (
        id,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26
    );"
    ,
    "SELECT
        id,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `ItemPurchaseGroup`;"
    )
}


pub(crate) fn item_purchase_group_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_purchase_group::ItemPurchaseGroup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_purchase_group::ItemPurchaseGroupRow {
            id: row.get::<_, i32>(0)?.into(),
            item_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(9)?.into(),
                ko_kr: row.get::<_, String>(10)?.into(),
                fr_fr: row.get::<_, String>(11)?.into(),
                de_de: row.get::<_, String>(12)?.into(),
                en_cn: row.get::<_, String>(13)?.into(),
                en_tw: row.get::<_, String>(14)?.into(),
                es_es: row.get::<_, String>(15)?.into(),
                es_mx: row.get::<_, String>(16)?.into(),
                ru_ru: row.get::<_, String>(17)?.into(),
                ja_jp: row.get::<_, String>(18)?.into(),
                pt_pt: row.get::<_, String>(19)?.into(),
                it_it: row.get::<_, String>(20)?.into(),
                unknown_12: row.get::<_, String>(21)?.into(),
                unknown_13: row.get::<_, String>(22)?.into(),
                unknown_14: row.get::<_, String>(23)?.into(),
                unknown_15: row.get::<_, String>(24)?.into(),
                flags: row.get::<_, u32>(25)?.into(),
            },
        });
    }
    Ok(item_purchase_group::ItemPurchaseGroup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemRandomProperties() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemRandomProperties (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        enchantment_0 INTEGER NOT NULL,
        enchantment_1 INTEGER NOT NULL,
        enchantment_2 INTEGER NOT NULL,
        enchantment_3 INTEGER NOT NULL,
        enchantment_4 INTEGER NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemRandomProperties (
        id,
        name,
        enchantment_0,
        enchantment_1,
        enchantment_2,
        enchantment_3,
        enchantment_4,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        name,
        enchantment_0,
        enchantment_1,
        enchantment_2,
        enchantment_3,
        enchantment_4,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `ItemRandomProperties`;"
    )
}


pub(crate) fn item_random_properties_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_random_properties::ItemRandomProperties, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_random_properties::ItemRandomPropertiesRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            enchantment: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(7)?.into(),
                ko_kr: row.get::<_, String>(8)?.into(),
                fr_fr: row.get::<_, String>(9)?.into(),
                de_de: row.get::<_, String>(10)?.into(),
                en_cn: row.get::<_, String>(11)?.into(),
                en_tw: row.get::<_, String>(12)?.into(),
                es_es: row.get::<_, String>(13)?.into(),
                es_mx: row.get::<_, String>(14)?.into(),
                ru_ru: row.get::<_, String>(15)?.into(),
                ja_jp: row.get::<_, String>(16)?.into(),
                pt_pt: row.get::<_, String>(17)?.into(),
                it_it: row.get::<_, String>(18)?.into(),
                unknown_12: row.get::<_, String>(19)?.into(),
                unknown_13: row.get::<_, String>(20)?.into(),
                unknown_14: row.get::<_, String>(21)?.into(),
                unknown_15: row.get::<_, String>(22)?.into(),
                flags: row.get::<_, u32>(23)?.into(),
            },
        });
    }
    Ok(item_random_properties::ItemRandomProperties { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemRandomSuffix() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemRandomSuffix (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        internal_name TEXT  NOT NULL,
        enchantment_0 INTEGER NOT NULL,
        enchantment_1 INTEGER NOT NULL,
        enchantment_2 INTEGER NOT NULL,
        enchantment_3 INTEGER NOT NULL,
        enchantment_4 INTEGER NOT NULL,
        allocation_pct_0 INTEGER NOT NULL,
        allocation_pct_1 INTEGER NOT NULL,
        allocation_pct_2 INTEGER NOT NULL,
        allocation_pct_3 INTEGER NOT NULL,
        allocation_pct_4 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemRandomSuffix (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        internal_name,
        enchantment_0,
        enchantment_1,
        enchantment_2,
        enchantment_3,
        enchantment_4,
        allocation_pct_0,
        allocation_pct_1,
        allocation_pct_2,
        allocation_pct_3,
        allocation_pct_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        internal_name,
        enchantment_0,
        enchantment_1,
        enchantment_2,
        enchantment_3,
        enchantment_4,
        allocation_pct_0,
        allocation_pct_1,
        allocation_pct_2,
        allocation_pct_3,
        allocation_pct_4
    FROM `ItemRandomSuffix`;"
    )
}


pub(crate) fn item_random_suffix_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_random_suffix::ItemRandomSuffix, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_random_suffix::ItemRandomSuffixRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            internal_name: row.get::<_, String>(18)?.into(),
            enchantment: [row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(),             ],
            allocation_pct: [row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(),             ],
        });
    }
    Ok(item_random_suffix::ItemRandomSuffix { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemSet() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemSet (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        item_id_0 INTEGER NOT NULL,
        item_id_1 INTEGER NOT NULL,
        item_id_2 INTEGER NOT NULL,
        item_id_3 INTEGER NOT NULL,
        item_id_4 INTEGER NOT NULL,
        item_id_5 INTEGER NOT NULL,
        item_id_6 INTEGER NOT NULL,
        item_id_7 INTEGER NOT NULL,
        item_id_8 INTEGER NOT NULL,
        item_id_9 INTEGER NOT NULL,
        item_id_10 INTEGER NOT NULL,
        item_id_11 INTEGER NOT NULL,
        item_id_12 INTEGER NOT NULL,
        item_id_13 INTEGER NOT NULL,
        item_id_14 INTEGER NOT NULL,
        item_id_15 INTEGER NOT NULL,
        item_id_16 INTEGER NOT NULL,
        set_spell_id_0 INTEGER NOT NULL,
        set_spell_id_1 INTEGER NOT NULL,
        set_spell_id_2 INTEGER NOT NULL,
        set_spell_id_3 INTEGER NOT NULL,
        set_spell_id_4 INTEGER NOT NULL,
        set_spell_id_5 INTEGER NOT NULL,
        set_spell_id_6 INTEGER NOT NULL,
        set_spell_id_7 INTEGER NOT NULL,
        set_threshold_0 INTEGER NOT NULL,
        set_threshold_1 INTEGER NOT NULL,
        set_threshold_2 INTEGER NOT NULL,
        set_threshold_3 INTEGER NOT NULL,
        set_threshold_4 INTEGER NOT NULL,
        set_threshold_5 INTEGER NOT NULL,
        set_threshold_6 INTEGER NOT NULL,
        set_threshold_7 INTEGER NOT NULL,
        required_skill INTEGER  NOT NULL,
        required_skill_rank INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ItemSet (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        item_id_8,
        item_id_9,
        item_id_10,
        item_id_11,
        item_id_12,
        item_id_13,
        item_id_14,
        item_id_15,
        item_id_16,
        set_spell_id_0,
        set_spell_id_1,
        set_spell_id_2,
        set_spell_id_3,
        set_spell_id_4,
        set_spell_id_5,
        set_spell_id_6,
        set_spell_id_7,
        set_threshold_0,
        set_threshold_1,
        set_threshold_2,
        set_threshold_3,
        set_threshold_4,
        set_threshold_5,
        set_threshold_6,
        set_threshold_7,
        required_skill,
        required_skill_rank
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        item_id_0,
        item_id_1,
        item_id_2,
        item_id_3,
        item_id_4,
        item_id_5,
        item_id_6,
        item_id_7,
        item_id_8,
        item_id_9,
        item_id_10,
        item_id_11,
        item_id_12,
        item_id_13,
        item_id_14,
        item_id_15,
        item_id_16,
        set_spell_id_0,
        set_spell_id_1,
        set_spell_id_2,
        set_spell_id_3,
        set_spell_id_4,
        set_spell_id_5,
        set_spell_id_6,
        set_spell_id_7,
        set_threshold_0,
        set_threshold_1,
        set_threshold_2,
        set_threshold_3,
        set_threshold_4,
        set_threshold_5,
        set_threshold_6,
        set_threshold_7,
        required_skill,
        required_skill_rank
    FROM `ItemSet`;"
    )
}


pub(crate) fn item_set_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_set::ItemSet, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_set::ItemSetRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            item_id: [row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(), row.get::<_, i32>(33)?.into(), row.get::<_, i32>(34)?.into(),             ],
            set_spell_id: [row.get::<_, i32>(35)?.into(), row.get::<_, i32>(36)?.into(), row.get::<_, i32>(37)?.into(), row.get::<_, i32>(38)?.into(), row.get::<_, i32>(39)?.into(), row.get::<_, i32>(40)?.into(), row.get::<_, i32>(41)?.into(), row.get::<_, i32>(42)?.into(),             ],
            set_threshold: [row.get::<_, i32>(43)?.into(), row.get::<_, i32>(44)?.into(), row.get::<_, i32>(45)?.into(), row.get::<_, i32>(46)?.into(), row.get::<_, i32>(47)?.into(), row.get::<_, i32>(48)?.into(), row.get::<_, i32>(49)?.into(), row.get::<_, i32>(50)?.into(),             ],
            required_skill: row.get::<_, i32>(51)?.into(),
            required_skill_rank: row.get::<_, i32>(52)?.into(),
        });
    }
    Ok(item_set::ItemSet { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemSubClass() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemSubClass (
        class_id INTEGER  NOT NULL,
        sub_class_id INTEGER  NOT NULL,
        prerequisite_proficiency INTEGER  NOT NULL,
        postrequisite_proficiency INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        display_flags INTEGER  NOT NULL,
        weapon_parry_seq INTEGER  NOT NULL,
        weapon_ready_seq INTEGER  NOT NULL,
        weapon_attack_seq INTEGER  NOT NULL,
        weapon_swing_size INTEGER  NOT NULL,
        display_name_lang_en_gb TEXT NOT NULL,
        display_name_lang_ko_kr TEXT NOT NULL,
        display_name_lang_fr_fr TEXT NOT NULL,
        display_name_lang_de_de TEXT NOT NULL,
        display_name_lang_en_cn TEXT NOT NULL,
        display_name_lang_en_tw TEXT NOT NULL,
        display_name_lang_es_es TEXT NOT NULL,
        display_name_lang_es_mx TEXT NOT NULL,
        display_name_lang_ru_ru TEXT NOT NULL,
        display_name_lang_ja_jp TEXT NOT NULL,
        display_name_lang_pt_pt TEXT NOT NULL,
        display_name_lang_it_it TEXT NOT NULL,
        display_name_lang_unknown_12 TEXT NOT NULL,
        display_name_lang_unknown_13 TEXT NOT NULL,
        display_name_lang_unknown_14 TEXT NOT NULL,
        display_name_lang_unknown_15 TEXT NOT NULL,
        display_name_lang_flags INTEGER NOT NULL,
        verbose_name_lang_en_gb TEXT NOT NULL,
        verbose_name_lang_ko_kr TEXT NOT NULL,
        verbose_name_lang_fr_fr TEXT NOT NULL,
        verbose_name_lang_de_de TEXT NOT NULL,
        verbose_name_lang_en_cn TEXT NOT NULL,
        verbose_name_lang_en_tw TEXT NOT NULL,
        verbose_name_lang_es_es TEXT NOT NULL,
        verbose_name_lang_es_mx TEXT NOT NULL,
        verbose_name_lang_ru_ru TEXT NOT NULL,
        verbose_name_lang_ja_jp TEXT NOT NULL,
        verbose_name_lang_pt_pt TEXT NOT NULL,
        verbose_name_lang_it_it TEXT NOT NULL,
        verbose_name_lang_unknown_12 TEXT NOT NULL,
        verbose_name_lang_unknown_13 TEXT NOT NULL,
        verbose_name_lang_unknown_14 TEXT NOT NULL,
        verbose_name_lang_unknown_15 TEXT NOT NULL,
        verbose_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemSubClass (
        class_id,
        sub_class_id,
        prerequisite_proficiency,
        postrequisite_proficiency,
        flags,
        display_flags,
        weapon_parry_seq,
        weapon_ready_seq,
        weapon_attack_seq,
        weapon_swing_size,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        verbose_name_lang_en_gb,
        verbose_name_lang_ko_kr,
        verbose_name_lang_fr_fr,
        verbose_name_lang_de_de,
        verbose_name_lang_en_cn,
        verbose_name_lang_en_tw,
        verbose_name_lang_es_es,
        verbose_name_lang_es_mx,
        verbose_name_lang_ru_ru,
        verbose_name_lang_ja_jp,
        verbose_name_lang_pt_pt,
        verbose_name_lang_it_it,
        verbose_name_lang_unknown_12,
        verbose_name_lang_unknown_13,
        verbose_name_lang_unknown_14,
        verbose_name_lang_unknown_15,
        verbose_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44
    );"
    ,
    "SELECT
        class_id,
        sub_class_id,
        prerequisite_proficiency,
        postrequisite_proficiency,
        flags,
        display_flags,
        weapon_parry_seq,
        weapon_ready_seq,
        weapon_attack_seq,
        weapon_swing_size,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        verbose_name_lang_en_gb,
        verbose_name_lang_ko_kr,
        verbose_name_lang_fr_fr,
        verbose_name_lang_de_de,
        verbose_name_lang_en_cn,
        verbose_name_lang_en_tw,
        verbose_name_lang_es_es,
        verbose_name_lang_es_mx,
        verbose_name_lang_ru_ru,
        verbose_name_lang_ja_jp,
        verbose_name_lang_pt_pt,
        verbose_name_lang_it_it,
        verbose_name_lang_unknown_12,
        verbose_name_lang_unknown_13,
        verbose_name_lang_unknown_14,
        verbose_name_lang_unknown_15,
        verbose_name_lang_flags
    FROM `ItemSubClass`;"
    )
}


pub(crate) fn item_sub_class_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_sub_class::ItemSubClass, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_sub_class::ItemSubClassRow {
            class_id: row.get::<_, i32>(0)?.into(),
            sub_class_id: row.get::<_, i32>(1)?.into(),
            prerequisite_proficiency: row.get::<_, i32>(2)?.into(),
            postrequisite_proficiency: row.get::<_, i32>(3)?.into(),
            flags: row.get::<_, i32>(4)?.into(),
            display_flags: row.get::<_, i32>(5)?.into(),
            weapon_parry_seq: row.get::<_, i32>(6)?.into(),
            weapon_ready_seq: row.get::<_, i32>(7)?.into(),
            weapon_attack_seq: row.get::<_, i32>(8)?.into(),
            weapon_swing_size: row.get::<_, i32>(9)?.into(),
            display_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(10)?.into(),
                ko_kr: row.get::<_, String>(11)?.into(),
                fr_fr: row.get::<_, String>(12)?.into(),
                de_de: row.get::<_, String>(13)?.into(),
                en_cn: row.get::<_, String>(14)?.into(),
                en_tw: row.get::<_, String>(15)?.into(),
                es_es: row.get::<_, String>(16)?.into(),
                es_mx: row.get::<_, String>(17)?.into(),
                ru_ru: row.get::<_, String>(18)?.into(),
                ja_jp: row.get::<_, String>(19)?.into(),
                pt_pt: row.get::<_, String>(20)?.into(),
                it_it: row.get::<_, String>(21)?.into(),
                unknown_12: row.get::<_, String>(22)?.into(),
                unknown_13: row.get::<_, String>(23)?.into(),
                unknown_14: row.get::<_, String>(24)?.into(),
                unknown_15: row.get::<_, String>(25)?.into(),
                flags: row.get::<_, u32>(26)?.into(),
            },
            verbose_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(27)?.into(),
                ko_kr: row.get::<_, String>(28)?.into(),
                fr_fr: row.get::<_, String>(29)?.into(),
                de_de: row.get::<_, String>(30)?.into(),
                en_cn: row.get::<_, String>(31)?.into(),
                en_tw: row.get::<_, String>(32)?.into(),
                es_es: row.get::<_, String>(33)?.into(),
                es_mx: row.get::<_, String>(34)?.into(),
                ru_ru: row.get::<_, String>(35)?.into(),
                ja_jp: row.get::<_, String>(36)?.into(),
                pt_pt: row.get::<_, String>(37)?.into(),
                it_it: row.get::<_, String>(38)?.into(),
                unknown_12: row.get::<_, String>(39)?.into(),
                unknown_13: row.get::<_, String>(40)?.into(),
                unknown_14: row.get::<_, String>(41)?.into(),
                unknown_15: row.get::<_, String>(42)?.into(),
                flags: row.get::<_, u32>(43)?.into(),
            },
        });
    }
    Ok(item_sub_class::ItemSubClass { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemSubClassMask() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemSubClassMask (
        class_id INTEGER  NOT NULL,
        mask INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemSubClassMask (
        class_id,
        mask,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        class_id,
        mask,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `ItemSubClassMask`;"
    )
}


pub(crate) fn item_sub_class_mask_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_sub_class_mask::ItemSubClassMask, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_sub_class_mask::ItemSubClassMaskRow {
            class_id: row.get::<_, i32>(0)?.into(),
            mask: row.get::<_, i32>(1)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
        });
    }
    Ok(item_sub_class_mask::ItemSubClassMask { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemVisualEffects() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemVisualEffects (
        id INTEGER PRIMARY KEY NOT NULL,
        model TEXT  NOT NULL
    );"
    ,
    "INSERT INTO ItemVisualEffects (
        id,
        model
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        model
    FROM `ItemVisualEffects`;"
    )
}


pub(crate) fn item_visual_effects_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_visual_effects::ItemVisualEffects, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_visual_effects::ItemVisualEffectsRow {
            id: row.get::<_, i32>(0)?.into(),
            model: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(item_visual_effects::ItemVisualEffects { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ItemVisuals() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ItemVisuals (
        id INTEGER PRIMARY KEY NOT NULL,
        slot_0 INTEGER NOT NULL,
        slot_1 INTEGER NOT NULL,
        slot_2 INTEGER NOT NULL,
        slot_3 INTEGER NOT NULL,
        slot_4 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ItemVisuals (
        id,
        slot_0,
        slot_1,
        slot_2,
        slot_3,
        slot_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        id,
        slot_0,
        slot_1,
        slot_2,
        slot_3,
        slot_4
    FROM `ItemVisuals`;"
    )
}


pub(crate) fn item_visuals_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<item_visuals::ItemVisuals, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(item_visuals::ItemVisualsRow {
            id: row.get::<_, i32>(0)?.into(),
            slot: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
        });
    }
    Ok(item_visuals::ItemVisuals { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LFGDungeonExpansion() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LFGDungeonExpansion (
        id INTEGER PRIMARY KEY NOT NULL,
        lfg_id INTEGER  NOT NULL,
        expansion_level INTEGER  NOT NULL,
        random_id INTEGER  NOT NULL,
        hard_level_min INTEGER  NOT NULL,
        hard_level_max INTEGER  NOT NULL,
        target_level_min INTEGER  NOT NULL,
        target_level_max INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LFGDungeonExpansion (
        id,
        lfg_id,
        expansion_level,
        random_id,
        hard_level_min,
        hard_level_max,
        target_level_min,
        target_level_max
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        lfg_id,
        expansion_level,
        random_id,
        hard_level_min,
        hard_level_max,
        target_level_min,
        target_level_max
    FROM `LFGDungeonExpansion`;"
    )
}


pub(crate) fn lfg_dungeon_expansion_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<lfg_dungeon_expansion::LFGDungeonExpansion, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(lfg_dungeon_expansion::LFGDungeonExpansionRow {
            id: row.get::<_, i32>(0)?.into(),
            lfg_id: row.get::<_, i32>(1)?.into(),
            expansion_level: row.get::<_, i32>(2)?.into(),
            random_id: row.get::<_, i32>(3)?.into(),
            hard_level_min: row.get::<_, i32>(4)?.into(),
            hard_level_max: row.get::<_, i32>(5)?.into(),
            target_level_min: row.get::<_, i32>(6)?.into(),
            target_level_max: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(lfg_dungeon_expansion::LFGDungeonExpansion { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LFGDungeonGroup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LFGDungeonGroup (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        order_index INTEGER  NOT NULL,
        parent_group_id INTEGER  NOT NULL,
        type_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LFGDungeonGroup (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        order_index,
        parent_group_id,
        type_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        order_index,
        parent_group_id,
        type_id
    FROM `LFGDungeonGroup`;"
    )
}


pub(crate) fn lfg_dungeon_group_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<lfg_dungeon_group::LFGDungeonGroup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(lfg_dungeon_group::LFGDungeonGroupRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            order_index: row.get::<_, i32>(18)?.into(),
            parent_group_id: row.get::<_, i32>(19)?.into(),
            type_id: row.get::<_, i32>(20)?.into(),
        });
    }
    Ok(lfg_dungeon_group::LFGDungeonGroup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LFGDungeons() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LFGDungeons (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        min_level INTEGER  NOT NULL,
        max_level INTEGER  NOT NULL,
        target_level INTEGER  NOT NULL,
        target_level_min INTEGER  NOT NULL,
        target_level_max INTEGER  NOT NULL,
        map_id INTEGER  NOT NULL,
        difficulty INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        type_id INTEGER  NOT NULL,
        faction INTEGER  NOT NULL,
        texture_filename TEXT  NOT NULL,
        expansion_level INTEGER  NOT NULL,
        order_index INTEGER  NOT NULL,
        group_id INTEGER  NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO LFGDungeons (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        min_level,
        max_level,
        target_level,
        target_level_min,
        target_level_max,
        map_id,
        difficulty,
        flags,
        type_id,
        faction,
        texture_filename,
        expansion_level,
        order_index,
        group_id,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        min_level,
        max_level,
        target_level,
        target_level_min,
        target_level_max,
        map_id,
        difficulty,
        flags,
        type_id,
        faction,
        texture_filename,
        expansion_level,
        order_index,
        group_id,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
    FROM `LFGDungeons`;"
    )
}


pub(crate) fn lfg_dungeons_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<lfg_dungeons::LFGDungeons, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(lfg_dungeons::LFGDungeonsRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            min_level: row.get::<_, i32>(18)?.into(),
            max_level: row.get::<_, i32>(19)?.into(),
            target_level: row.get::<_, i32>(20)?.into(),
            target_level_min: row.get::<_, i32>(21)?.into(),
            target_level_max: row.get::<_, i32>(22)?.into(),
            map_id: row.get::<_, i32>(23)?.into(),
            difficulty: row.get::<_, i32>(24)?.into(),
            flags: row.get::<_, i32>(25)?.into(),
            type_id: row.get::<_, i32>(26)?.into(),
            faction: row.get::<_, i32>(27)?.into(),
            texture_filename: row.get::<_, String>(28)?.into(),
            expansion_level: row.get::<_, i32>(29)?.into(),
            order_index: row.get::<_, i32>(30)?.into(),
            group_id: row.get::<_, i32>(31)?.into(),
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(32)?.into(),
                ko_kr: row.get::<_, String>(33)?.into(),
                fr_fr: row.get::<_, String>(34)?.into(),
                de_de: row.get::<_, String>(35)?.into(),
                en_cn: row.get::<_, String>(36)?.into(),
                en_tw: row.get::<_, String>(37)?.into(),
                es_es: row.get::<_, String>(38)?.into(),
                es_mx: row.get::<_, String>(39)?.into(),
                ru_ru: row.get::<_, String>(40)?.into(),
                ja_jp: row.get::<_, String>(41)?.into(),
                pt_pt: row.get::<_, String>(42)?.into(),
                it_it: row.get::<_, String>(43)?.into(),
                unknown_12: row.get::<_, String>(44)?.into(),
                unknown_13: row.get::<_, String>(45)?.into(),
                unknown_14: row.get::<_, String>(46)?.into(),
                unknown_15: row.get::<_, String>(47)?.into(),
                flags: row.get::<_, u32>(48)?.into(),
            },
        });
    }
    Ok(lfg_dungeons::LFGDungeons { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LanguageWords() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LanguageWords (
        id INTEGER PRIMARY KEY NOT NULL,
        language_id INTEGER  NOT NULL,
        word TEXT  NOT NULL
    );"
    ,
    "INSERT INTO LanguageWords (
        id,
        language_id,
        word
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        language_id,
        word
    FROM `LanguageWords`;"
    )
}


pub(crate) fn language_words_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<language_words::LanguageWords, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(language_words::LanguageWordsRow {
            id: row.get::<_, i32>(0)?.into(),
            language_id: row.get::<_, i32>(1)?.into(),
            word: row.get::<_, String>(2)?.into(),
        });
    }
    Ok(language_words::LanguageWords { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Languages() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Languages (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Languages (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `Languages`;"
    )
}


pub(crate) fn languages_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<languages::Languages, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(languages::LanguagesRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(languages::Languages { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Light() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Light (
        id INTEGER PRIMARY KEY NOT NULL,
        continent_id INTEGER  NOT NULL,
        game_coords_0 REAL NOT NULL,
        game_coords_1 REAL NOT NULL,
        game_coords_2 REAL NOT NULL,
        game_falloff_start REAL  NOT NULL,
        game_falloff_end REAL  NOT NULL,
        light_params_id_0 INTEGER NOT NULL,
        light_params_id_1 INTEGER NOT NULL,
        light_params_id_2 INTEGER NOT NULL,
        light_params_id_3 INTEGER NOT NULL,
        light_params_id_4 INTEGER NOT NULL,
        light_params_id_5 INTEGER NOT NULL,
        light_params_id_6 INTEGER NOT NULL,
        light_params_id_7 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Light (
        id,
        continent_id,
        game_coords_0,
        game_coords_1,
        game_coords_2,
        game_falloff_start,
        game_falloff_end,
        light_params_id_0,
        light_params_id_1,
        light_params_id_2,
        light_params_id_3,
        light_params_id_4,
        light_params_id_5,
        light_params_id_6,
        light_params_id_7
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15
    );"
    ,
    "SELECT
        id,
        continent_id,
        game_coords_0,
        game_coords_1,
        game_coords_2,
        game_falloff_start,
        game_falloff_end,
        light_params_id_0,
        light_params_id_1,
        light_params_id_2,
        light_params_id_3,
        light_params_id_4,
        light_params_id_5,
        light_params_id_6,
        light_params_id_7
    FROM `Light`;"
    )
}


pub(crate) fn light_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<light::Light, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(light::LightRow {
            id: row.get::<_, i32>(0)?.into(),
            continent_id: row.get::<_, i32>(1)?.into(),
            game_coords: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(),             ],
            game_falloff_start: row.get::<_, f32>(5)?.into(),
            game_falloff_end: row.get::<_, f32>(6)?.into(),
            light_params_id: [row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(),             ],
        });
    }
    Ok(light::Light { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LightFloatBand() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LightFloatBand (
        id INTEGER PRIMARY KEY NOT NULL,
        num INTEGER  NOT NULL,
        time_0 INTEGER NOT NULL,
        time_1 INTEGER NOT NULL,
        time_2 INTEGER NOT NULL,
        time_3 INTEGER NOT NULL,
        time_4 INTEGER NOT NULL,
        time_5 INTEGER NOT NULL,
        time_6 INTEGER NOT NULL,
        time_7 INTEGER NOT NULL,
        time_8 INTEGER NOT NULL,
        time_9 INTEGER NOT NULL,
        time_10 INTEGER NOT NULL,
        time_11 INTEGER NOT NULL,
        time_12 INTEGER NOT NULL,
        time_13 INTEGER NOT NULL,
        time_14 INTEGER NOT NULL,
        time_15 INTEGER NOT NULL,
        data_0 REAL NOT NULL,
        data_1 REAL NOT NULL,
        data_2 REAL NOT NULL,
        data_3 REAL NOT NULL,
        data_4 REAL NOT NULL,
        data_5 REAL NOT NULL,
        data_6 REAL NOT NULL,
        data_7 REAL NOT NULL,
        data_8 REAL NOT NULL,
        data_9 REAL NOT NULL,
        data_10 REAL NOT NULL,
        data_11 REAL NOT NULL,
        data_12 REAL NOT NULL,
        data_13 REAL NOT NULL,
        data_14 REAL NOT NULL,
        data_15 REAL NOT NULL
    );"
    ,
    "INSERT INTO LightFloatBand (
        id,
        num,
        time_0,
        time_1,
        time_2,
        time_3,
        time_4,
        time_5,
        time_6,
        time_7,
        time_8,
        time_9,
        time_10,
        time_11,
        time_12,
        time_13,
        time_14,
        time_15,
        data_0,
        data_1,
        data_2,
        data_3,
        data_4,
        data_5,
        data_6,
        data_7,
        data_8,
        data_9,
        data_10,
        data_11,
        data_12,
        data_13,
        data_14,
        data_15
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34
    );"
    ,
    "SELECT
        id,
        num,
        time_0,
        time_1,
        time_2,
        time_3,
        time_4,
        time_5,
        time_6,
        time_7,
        time_8,
        time_9,
        time_10,
        time_11,
        time_12,
        time_13,
        time_14,
        time_15,
        data_0,
        data_1,
        data_2,
        data_3,
        data_4,
        data_5,
        data_6,
        data_7,
        data_8,
        data_9,
        data_10,
        data_11,
        data_12,
        data_13,
        data_14,
        data_15
    FROM `LightFloatBand`;"
    )
}


pub(crate) fn light_float_band_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<light_float_band::LightFloatBand, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(light_float_band::LightFloatBandRow {
            id: row.get::<_, i32>(0)?.into(),
            num: row.get::<_, i32>(1)?.into(),
            time: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(),             ],
            data: [row.get::<_, f32>(18)?.into(), row.get::<_, f32>(19)?.into(), row.get::<_, f32>(20)?.into(), row.get::<_, f32>(21)?.into(), row.get::<_, f32>(22)?.into(), row.get::<_, f32>(23)?.into(), row.get::<_, f32>(24)?.into(), row.get::<_, f32>(25)?.into(), row.get::<_, f32>(26)?.into(), row.get::<_, f32>(27)?.into(), row.get::<_, f32>(28)?.into(), row.get::<_, f32>(29)?.into(), row.get::<_, f32>(30)?.into(), row.get::<_, f32>(31)?.into(), row.get::<_, f32>(32)?.into(), row.get::<_, f32>(33)?.into(),             ],
        });
    }
    Ok(light_float_band::LightFloatBand { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LightIntBand() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LightIntBand (
        id INTEGER PRIMARY KEY NOT NULL,
        num INTEGER  NOT NULL,
        time_0 INTEGER NOT NULL,
        time_1 INTEGER NOT NULL,
        time_2 INTEGER NOT NULL,
        time_3 INTEGER NOT NULL,
        time_4 INTEGER NOT NULL,
        time_5 INTEGER NOT NULL,
        time_6 INTEGER NOT NULL,
        time_7 INTEGER NOT NULL,
        time_8 INTEGER NOT NULL,
        time_9 INTEGER NOT NULL,
        time_10 INTEGER NOT NULL,
        time_11 INTEGER NOT NULL,
        time_12 INTEGER NOT NULL,
        time_13 INTEGER NOT NULL,
        time_14 INTEGER NOT NULL,
        time_15 INTEGER NOT NULL,
        data_0 INTEGER NOT NULL,
        data_1 INTEGER NOT NULL,
        data_2 INTEGER NOT NULL,
        data_3 INTEGER NOT NULL,
        data_4 INTEGER NOT NULL,
        data_5 INTEGER NOT NULL,
        data_6 INTEGER NOT NULL,
        data_7 INTEGER NOT NULL,
        data_8 INTEGER NOT NULL,
        data_9 INTEGER NOT NULL,
        data_10 INTEGER NOT NULL,
        data_11 INTEGER NOT NULL,
        data_12 INTEGER NOT NULL,
        data_13 INTEGER NOT NULL,
        data_14 INTEGER NOT NULL,
        data_15 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO LightIntBand (
        id,
        num,
        time_0,
        time_1,
        time_2,
        time_3,
        time_4,
        time_5,
        time_6,
        time_7,
        time_8,
        time_9,
        time_10,
        time_11,
        time_12,
        time_13,
        time_14,
        time_15,
        data_0,
        data_1,
        data_2,
        data_3,
        data_4,
        data_5,
        data_6,
        data_7,
        data_8,
        data_9,
        data_10,
        data_11,
        data_12,
        data_13,
        data_14,
        data_15
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34
    );"
    ,
    "SELECT
        id,
        num,
        time_0,
        time_1,
        time_2,
        time_3,
        time_4,
        time_5,
        time_6,
        time_7,
        time_8,
        time_9,
        time_10,
        time_11,
        time_12,
        time_13,
        time_14,
        time_15,
        data_0,
        data_1,
        data_2,
        data_3,
        data_4,
        data_5,
        data_6,
        data_7,
        data_8,
        data_9,
        data_10,
        data_11,
        data_12,
        data_13,
        data_14,
        data_15
    FROM `LightIntBand`;"
    )
}


pub(crate) fn light_int_band_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<light_int_band::LightIntBand, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(light_int_band::LightIntBandRow {
            id: row.get::<_, i32>(0)?.into(),
            num: row.get::<_, i32>(1)?.into(),
            time: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(),             ],
            data: [row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(), row.get::<_, i32>(33)?.into(),             ],
        });
    }
    Ok(light_int_band::LightIntBand { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LightParams() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LightParams (
        id INTEGER PRIMARY KEY NOT NULL,
        highlight_sky INTEGER  NOT NULL,
        light_skybox_id INTEGER  NOT NULL,
        glow REAL  NOT NULL,
        water_shallow_alpha REAL  NOT NULL,
        water_deep_alpha REAL  NOT NULL,
        ocean_shallow_alpha REAL  NOT NULL,
        ocean_deep_alpha REAL  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LightParams (
        id,
        highlight_sky,
        light_skybox_id,
        glow,
        water_shallow_alpha,
        water_deep_alpha,
        ocean_shallow_alpha,
        ocean_deep_alpha,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9
    );"
    ,
    "SELECT
        id,
        highlight_sky,
        light_skybox_id,
        glow,
        water_shallow_alpha,
        water_deep_alpha,
        ocean_shallow_alpha,
        ocean_deep_alpha,
        flags
    FROM `LightParams`;"
    )
}


pub(crate) fn light_params_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<light_params::LightParams, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(light_params::LightParamsRow {
            id: row.get::<_, i32>(0)?.into(),
            highlight_sky: row.get::<_, i32>(1)?.into(),
            light_skybox_id: row.get::<_, i32>(2)?.into(),
            glow: row.get::<_, f32>(3)?.into(),
            water_shallow_alpha: row.get::<_, f32>(4)?.into(),
            water_deep_alpha: row.get::<_, f32>(5)?.into(),
            ocean_shallow_alpha: row.get::<_, f32>(6)?.into(),
            ocean_deep_alpha: row.get::<_, f32>(7)?.into(),
            flags: row.get::<_, i32>(8)?.into(),
        });
    }
    Ok(light_params::LightParams { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LightSkybox() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LightSkybox (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LightSkybox (
        id,
        name,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        name,
        flags
    FROM `LightSkybox`;"
    )
}


pub(crate) fn light_skybox_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<light_skybox::LightSkybox, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(light_skybox::LightSkyboxRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(light_skybox::LightSkybox { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LiquidMaterial() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LiquidMaterial (
        id INTEGER PRIMARY KEY NOT NULL,
        l_v_f INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LiquidMaterial (
        id,
        l_v_f,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        l_v_f,
        flags
    FROM `LiquidMaterial`;"
    )
}


pub(crate) fn liquid_material_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<liquid_material::LiquidMaterial, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(liquid_material::LiquidMaterialRow {
            id: row.get::<_, i32>(0)?.into(),
            l_v_f: row.get::<_, i32>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(liquid_material::LiquidMaterial { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LiquidType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LiquidType (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        flags INTEGER  NOT NULL,
        sound_bank INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        spell_id INTEGER  NOT NULL,
        max_darken_depth REAL  NOT NULL,
        fog_darken_intensity REAL  NOT NULL,
        amb_darken_intensity REAL  NOT NULL,
        dir_darken_intensity REAL  NOT NULL,
        light_id INTEGER  NOT NULL,
        particle_scale REAL  NOT NULL,
        particle_movement INTEGER  NOT NULL,
        particle_tex_slots INTEGER  NOT NULL,
        material_id INTEGER  NOT NULL,
        texture_0 TEXT NOT NULL,
        texture_1 TEXT NOT NULL,
        texture_2 TEXT NOT NULL,
        texture_3 TEXT NOT NULL,
        texture_4 TEXT NOT NULL,
        texture_5 TEXT NOT NULL,
        color_0 INTEGER NOT NULL,
        color_1 INTEGER NOT NULL,
        float_0 REAL NOT NULL,
        float_1 REAL NOT NULL,
        float_2 REAL NOT NULL,
        float_3 REAL NOT NULL,
        float_4 REAL NOT NULL,
        float_5 REAL NOT NULL,
        float_6 REAL NOT NULL,
        float_7 REAL NOT NULL,
        float_8 REAL NOT NULL,
        float_9 REAL NOT NULL,
        float_10 REAL NOT NULL,
        float_11 REAL NOT NULL,
        float_12 REAL NOT NULL,
        float_13 REAL NOT NULL,
        float_14 REAL NOT NULL,
        float_15 REAL NOT NULL,
        float_16 REAL NOT NULL,
        float_17 REAL NOT NULL,
        int_0 INTEGER NOT NULL,
        int_1 INTEGER NOT NULL,
        int_2 INTEGER NOT NULL,
        int_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO LiquidType (
        id,
        name,
        flags,
        sound_bank,
        sound_id,
        spell_id,
        max_darken_depth,
        fog_darken_intensity,
        amb_darken_intensity,
        dir_darken_intensity,
        light_id,
        particle_scale,
        particle_movement,
        particle_tex_slots,
        material_id,
        texture_0,
        texture_1,
        texture_2,
        texture_3,
        texture_4,
        texture_5,
        color_0,
        color_1,
        float_0,
        float_1,
        float_2,
        float_3,
        float_4,
        float_5,
        float_6,
        float_7,
        float_8,
        float_9,
        float_10,
        float_11,
        float_12,
        float_13,
        float_14,
        float_15,
        float_16,
        float_17,
        int_0,
        int_1,
        int_2,
        int_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45
    );"
    ,
    "SELECT
        id,
        name,
        flags,
        sound_bank,
        sound_id,
        spell_id,
        max_darken_depth,
        fog_darken_intensity,
        amb_darken_intensity,
        dir_darken_intensity,
        light_id,
        particle_scale,
        particle_movement,
        particle_tex_slots,
        material_id,
        texture_0,
        texture_1,
        texture_2,
        texture_3,
        texture_4,
        texture_5,
        color_0,
        color_1,
        float_0,
        float_1,
        float_2,
        float_3,
        float_4,
        float_5,
        float_6,
        float_7,
        float_8,
        float_9,
        float_10,
        float_11,
        float_12,
        float_13,
        float_14,
        float_15,
        float_16,
        float_17,
        int_0,
        int_1,
        int_2,
        int_3
    FROM `LiquidType`;"
    )
}


pub(crate) fn liquid_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<liquid_type::LiquidType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(liquid_type::LiquidTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
            sound_bank: row.get::<_, i32>(3)?.into(),
            sound_id: row.get::<_, i32>(4)?.into(),
            spell_id: row.get::<_, i32>(5)?.into(),
            max_darken_depth: row.get::<_, f32>(6)?.into(),
            fog_darken_intensity: row.get::<_, f32>(7)?.into(),
            amb_darken_intensity: row.get::<_, f32>(8)?.into(),
            dir_darken_intensity: row.get::<_, f32>(9)?.into(),
            light_id: row.get::<_, i32>(10)?.into(),
            particle_scale: row.get::<_, f32>(11)?.into(),
            particle_movement: row.get::<_, i32>(12)?.into(),
            particle_tex_slots: row.get::<_, i32>(13)?.into(),
            material_id: row.get::<_, i32>(14)?.into(),
            texture: [row.get::<_, String>(15)?.into(), row.get::<_, String>(16)?.into(), row.get::<_, String>(17)?.into(), row.get::<_, String>(18)?.into(), row.get::<_, String>(19)?.into(), row.get::<_, String>(20)?.into(),             ],
            color: [row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
            float: [row.get::<_, f32>(23)?.into(), row.get::<_, f32>(24)?.into(), row.get::<_, f32>(25)?.into(), row.get::<_, f32>(26)?.into(), row.get::<_, f32>(27)?.into(), row.get::<_, f32>(28)?.into(), row.get::<_, f32>(29)?.into(), row.get::<_, f32>(30)?.into(), row.get::<_, f32>(31)?.into(), row.get::<_, f32>(32)?.into(), row.get::<_, f32>(33)?.into(), row.get::<_, f32>(34)?.into(), row.get::<_, f32>(35)?.into(), row.get::<_, f32>(36)?.into(), row.get::<_, f32>(37)?.into(), row.get::<_, f32>(38)?.into(), row.get::<_, f32>(39)?.into(), row.get::<_, f32>(40)?.into(),             ],
            int: [row.get::<_, i32>(41)?.into(), row.get::<_, i32>(42)?.into(), row.get::<_, i32>(43)?.into(), row.get::<_, i32>(44)?.into(),             ],
        });
    }
    Ok(liquid_type::LiquidType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LoadingScreenTaxiSplines() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LoadingScreenTaxiSplines (
        id INTEGER PRIMARY KEY NOT NULL,
        path_id INTEGER  NOT NULL,
        locx_0 REAL NOT NULL,
        locx_1 REAL NOT NULL,
        locx_2 REAL NOT NULL,
        locx_3 REAL NOT NULL,
        locx_4 REAL NOT NULL,
        locx_5 REAL NOT NULL,
        locx_6 REAL NOT NULL,
        locx_7 REAL NOT NULL,
        locy_0 REAL NOT NULL,
        locy_1 REAL NOT NULL,
        locy_2 REAL NOT NULL,
        locy_3 REAL NOT NULL,
        locy_4 REAL NOT NULL,
        locy_5 REAL NOT NULL,
        locy_6 REAL NOT NULL,
        locy_7 REAL NOT NULL,
        leg_index INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LoadingScreenTaxiSplines (
        id,
        path_id,
        locx_0,
        locx_1,
        locx_2,
        locx_3,
        locx_4,
        locx_5,
        locx_6,
        locx_7,
        locy_0,
        locy_1,
        locy_2,
        locy_3,
        locy_4,
        locy_5,
        locy_6,
        locy_7,
        leg_index
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        path_id,
        locx_0,
        locx_1,
        locx_2,
        locx_3,
        locx_4,
        locx_5,
        locx_6,
        locx_7,
        locy_0,
        locy_1,
        locy_2,
        locy_3,
        locy_4,
        locy_5,
        locy_6,
        locy_7,
        leg_index
    FROM `LoadingScreenTaxiSplines`;"
    )
}


pub(crate) fn loading_screen_taxi_splines_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<loading_screen_taxi_splines::LoadingScreenTaxiSplines, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(loading_screen_taxi_splines::LoadingScreenTaxiSplinesRow {
            id: row.get::<_, i32>(0)?.into(),
            path_id: row.get::<_, i32>(1)?.into(),
            locx: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(), row.get::<_, f32>(7)?.into(), row.get::<_, f32>(8)?.into(), row.get::<_, f32>(9)?.into(),             ],
            locy: [row.get::<_, f32>(10)?.into(), row.get::<_, f32>(11)?.into(), row.get::<_, f32>(12)?.into(), row.get::<_, f32>(13)?.into(), row.get::<_, f32>(14)?.into(), row.get::<_, f32>(15)?.into(), row.get::<_, f32>(16)?.into(), row.get::<_, f32>(17)?.into(),             ],
            leg_index: row.get::<_, i32>(18)?.into(),
        });
    }
    Ok(loading_screen_taxi_splines::LoadingScreenTaxiSplines { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LoadingScreens() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LoadingScreens (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        file_name TEXT  NOT NULL,
        has_wide_screen INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO LoadingScreens (
        id,
        name,
        file_name,
        has_wide_screen
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        name,
        file_name,
        has_wide_screen
    FROM `LoadingScreens`;"
    )
}


pub(crate) fn loading_screens_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<loading_screens::LoadingScreens, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(loading_screens::LoadingScreensRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            file_name: row.get::<_, String>(2)?.into(),
            has_wide_screen: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(loading_screens::LoadingScreens { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Lock() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Lock (
        id INTEGER PRIMARY KEY NOT NULL,
        ty_0 INTEGER NOT NULL,
        ty_1 INTEGER NOT NULL,
        ty_2 INTEGER NOT NULL,
        ty_3 INTEGER NOT NULL,
        ty_4 INTEGER NOT NULL,
        ty_5 INTEGER NOT NULL,
        ty_6 INTEGER NOT NULL,
        ty_7 INTEGER NOT NULL,
        index_0 INTEGER NOT NULL,
        index_1 INTEGER NOT NULL,
        index_2 INTEGER NOT NULL,
        index_3 INTEGER NOT NULL,
        index_4 INTEGER NOT NULL,
        index_5 INTEGER NOT NULL,
        index_6 INTEGER NOT NULL,
        index_7 INTEGER NOT NULL,
        skill_0 INTEGER NOT NULL,
        skill_1 INTEGER NOT NULL,
        skill_2 INTEGER NOT NULL,
        skill_3 INTEGER NOT NULL,
        skill_4 INTEGER NOT NULL,
        skill_5 INTEGER NOT NULL,
        skill_6 INTEGER NOT NULL,
        skill_7 INTEGER NOT NULL,
        action_0 INTEGER NOT NULL,
        action_1 INTEGER NOT NULL,
        action_2 INTEGER NOT NULL,
        action_3 INTEGER NOT NULL,
        action_4 INTEGER NOT NULL,
        action_5 INTEGER NOT NULL,
        action_6 INTEGER NOT NULL,
        action_7 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Lock (
        id,
        ty_0,
        ty_1,
        ty_2,
        ty_3,
        ty_4,
        ty_5,
        ty_6,
        ty_7,
        index_0,
        index_1,
        index_2,
        index_3,
        index_4,
        index_5,
        index_6,
        index_7,
        skill_0,
        skill_1,
        skill_2,
        skill_3,
        skill_4,
        skill_5,
        skill_6,
        skill_7,
        action_0,
        action_1,
        action_2,
        action_3,
        action_4,
        action_5,
        action_6,
        action_7
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33
    );"
    ,
    "SELECT
        id,
        ty_0,
        ty_1,
        ty_2,
        ty_3,
        ty_4,
        ty_5,
        ty_6,
        ty_7,
        index_0,
        index_1,
        index_2,
        index_3,
        index_4,
        index_5,
        index_6,
        index_7,
        skill_0,
        skill_1,
        skill_2,
        skill_3,
        skill_4,
        skill_5,
        skill_6,
        skill_7,
        action_0,
        action_1,
        action_2,
        action_3,
        action_4,
        action_5,
        action_6,
        action_7
    FROM `Lock`;"
    )
}


pub(crate) fn lock_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<lock::Lock, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(lock::LockRow {
            id: row.get::<_, i32>(0)?.into(),
            ty: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(),             ],
            index: [row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(),             ],
            skill: [row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(),             ],
            action: [row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(),             ],
        });
    }
    Ok(lock::Lock { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn LockType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS LockType (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        resource_name_lang_en_gb TEXT NOT NULL,
        resource_name_lang_ko_kr TEXT NOT NULL,
        resource_name_lang_fr_fr TEXT NOT NULL,
        resource_name_lang_de_de TEXT NOT NULL,
        resource_name_lang_en_cn TEXT NOT NULL,
        resource_name_lang_en_tw TEXT NOT NULL,
        resource_name_lang_es_es TEXT NOT NULL,
        resource_name_lang_es_mx TEXT NOT NULL,
        resource_name_lang_ru_ru TEXT NOT NULL,
        resource_name_lang_ja_jp TEXT NOT NULL,
        resource_name_lang_pt_pt TEXT NOT NULL,
        resource_name_lang_it_it TEXT NOT NULL,
        resource_name_lang_unknown_12 TEXT NOT NULL,
        resource_name_lang_unknown_13 TEXT NOT NULL,
        resource_name_lang_unknown_14 TEXT NOT NULL,
        resource_name_lang_unknown_15 TEXT NOT NULL,
        resource_name_lang_flags INTEGER NOT NULL,
        verb_lang_en_gb TEXT NOT NULL,
        verb_lang_ko_kr TEXT NOT NULL,
        verb_lang_fr_fr TEXT NOT NULL,
        verb_lang_de_de TEXT NOT NULL,
        verb_lang_en_cn TEXT NOT NULL,
        verb_lang_en_tw TEXT NOT NULL,
        verb_lang_es_es TEXT NOT NULL,
        verb_lang_es_mx TEXT NOT NULL,
        verb_lang_ru_ru TEXT NOT NULL,
        verb_lang_ja_jp TEXT NOT NULL,
        verb_lang_pt_pt TEXT NOT NULL,
        verb_lang_it_it TEXT NOT NULL,
        verb_lang_unknown_12 TEXT NOT NULL,
        verb_lang_unknown_13 TEXT NOT NULL,
        verb_lang_unknown_14 TEXT NOT NULL,
        verb_lang_unknown_15 TEXT NOT NULL,
        verb_lang_flags INTEGER NOT NULL,
        cursor_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO LockType (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        resource_name_lang_en_gb,
        resource_name_lang_ko_kr,
        resource_name_lang_fr_fr,
        resource_name_lang_de_de,
        resource_name_lang_en_cn,
        resource_name_lang_en_tw,
        resource_name_lang_es_es,
        resource_name_lang_es_mx,
        resource_name_lang_ru_ru,
        resource_name_lang_ja_jp,
        resource_name_lang_pt_pt,
        resource_name_lang_it_it,
        resource_name_lang_unknown_12,
        resource_name_lang_unknown_13,
        resource_name_lang_unknown_14,
        resource_name_lang_unknown_15,
        resource_name_lang_flags,
        verb_lang_en_gb,
        verb_lang_ko_kr,
        verb_lang_fr_fr,
        verb_lang_de_de,
        verb_lang_en_cn,
        verb_lang_en_tw,
        verb_lang_es_es,
        verb_lang_es_mx,
        verb_lang_ru_ru,
        verb_lang_ja_jp,
        verb_lang_pt_pt,
        verb_lang_it_it,
        verb_lang_unknown_12,
        verb_lang_unknown_13,
        verb_lang_unknown_14,
        verb_lang_unknown_15,
        verb_lang_flags,
        cursor_name
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        resource_name_lang_en_gb,
        resource_name_lang_ko_kr,
        resource_name_lang_fr_fr,
        resource_name_lang_de_de,
        resource_name_lang_en_cn,
        resource_name_lang_en_tw,
        resource_name_lang_es_es,
        resource_name_lang_es_mx,
        resource_name_lang_ru_ru,
        resource_name_lang_ja_jp,
        resource_name_lang_pt_pt,
        resource_name_lang_it_it,
        resource_name_lang_unknown_12,
        resource_name_lang_unknown_13,
        resource_name_lang_unknown_14,
        resource_name_lang_unknown_15,
        resource_name_lang_flags,
        verb_lang_en_gb,
        verb_lang_ko_kr,
        verb_lang_fr_fr,
        verb_lang_de_de,
        verb_lang_en_cn,
        verb_lang_en_tw,
        verb_lang_es_es,
        verb_lang_es_mx,
        verb_lang_ru_ru,
        verb_lang_ja_jp,
        verb_lang_pt_pt,
        verb_lang_it_it,
        verb_lang_unknown_12,
        verb_lang_unknown_13,
        verb_lang_unknown_14,
        verb_lang_unknown_15,
        verb_lang_flags,
        cursor_name
    FROM `LockType`;"
    )
}


pub(crate) fn lock_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<lock_type::LockType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(lock_type::LockTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            resource_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(18)?.into(),
                ko_kr: row.get::<_, String>(19)?.into(),
                fr_fr: row.get::<_, String>(20)?.into(),
                de_de: row.get::<_, String>(21)?.into(),
                en_cn: row.get::<_, String>(22)?.into(),
                en_tw: row.get::<_, String>(23)?.into(),
                es_es: row.get::<_, String>(24)?.into(),
                es_mx: row.get::<_, String>(25)?.into(),
                ru_ru: row.get::<_, String>(26)?.into(),
                ja_jp: row.get::<_, String>(27)?.into(),
                pt_pt: row.get::<_, String>(28)?.into(),
                it_it: row.get::<_, String>(29)?.into(),
                unknown_12: row.get::<_, String>(30)?.into(),
                unknown_13: row.get::<_, String>(31)?.into(),
                unknown_14: row.get::<_, String>(32)?.into(),
                unknown_15: row.get::<_, String>(33)?.into(),
                flags: row.get::<_, u32>(34)?.into(),
            },
            verb_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(35)?.into(),
                ko_kr: row.get::<_, String>(36)?.into(),
                fr_fr: row.get::<_, String>(37)?.into(),
                de_de: row.get::<_, String>(38)?.into(),
                en_cn: row.get::<_, String>(39)?.into(),
                en_tw: row.get::<_, String>(40)?.into(),
                es_es: row.get::<_, String>(41)?.into(),
                es_mx: row.get::<_, String>(42)?.into(),
                ru_ru: row.get::<_, String>(43)?.into(),
                ja_jp: row.get::<_, String>(44)?.into(),
                pt_pt: row.get::<_, String>(45)?.into(),
                it_it: row.get::<_, String>(46)?.into(),
                unknown_12: row.get::<_, String>(47)?.into(),
                unknown_13: row.get::<_, String>(48)?.into(),
                unknown_14: row.get::<_, String>(49)?.into(),
                unknown_15: row.get::<_, String>(50)?.into(),
                flags: row.get::<_, u32>(51)?.into(),
            },
            cursor_name: row.get::<_, String>(52)?.into(),
        });
    }
    Ok(lock_type::LockType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn MailTemplate() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS MailTemplate (
        id INTEGER PRIMARY KEY NOT NULL,
        subject_lang_en_gb TEXT NOT NULL,
        subject_lang_ko_kr TEXT NOT NULL,
        subject_lang_fr_fr TEXT NOT NULL,
        subject_lang_de_de TEXT NOT NULL,
        subject_lang_en_cn TEXT NOT NULL,
        subject_lang_en_tw TEXT NOT NULL,
        subject_lang_es_es TEXT NOT NULL,
        subject_lang_es_mx TEXT NOT NULL,
        subject_lang_ru_ru TEXT NOT NULL,
        subject_lang_ja_jp TEXT NOT NULL,
        subject_lang_pt_pt TEXT NOT NULL,
        subject_lang_it_it TEXT NOT NULL,
        subject_lang_unknown_12 TEXT NOT NULL,
        subject_lang_unknown_13 TEXT NOT NULL,
        subject_lang_unknown_14 TEXT NOT NULL,
        subject_lang_unknown_15 TEXT NOT NULL,
        subject_lang_flags INTEGER NOT NULL,
        body_lang_en_gb TEXT NOT NULL,
        body_lang_ko_kr TEXT NOT NULL,
        body_lang_fr_fr TEXT NOT NULL,
        body_lang_de_de TEXT NOT NULL,
        body_lang_en_cn TEXT NOT NULL,
        body_lang_en_tw TEXT NOT NULL,
        body_lang_es_es TEXT NOT NULL,
        body_lang_es_mx TEXT NOT NULL,
        body_lang_ru_ru TEXT NOT NULL,
        body_lang_ja_jp TEXT NOT NULL,
        body_lang_pt_pt TEXT NOT NULL,
        body_lang_it_it TEXT NOT NULL,
        body_lang_unknown_12 TEXT NOT NULL,
        body_lang_unknown_13 TEXT NOT NULL,
        body_lang_unknown_14 TEXT NOT NULL,
        body_lang_unknown_15 TEXT NOT NULL,
        body_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO MailTemplate (
        id,
        subject_lang_en_gb,
        subject_lang_ko_kr,
        subject_lang_fr_fr,
        subject_lang_de_de,
        subject_lang_en_cn,
        subject_lang_en_tw,
        subject_lang_es_es,
        subject_lang_es_mx,
        subject_lang_ru_ru,
        subject_lang_ja_jp,
        subject_lang_pt_pt,
        subject_lang_it_it,
        subject_lang_unknown_12,
        subject_lang_unknown_13,
        subject_lang_unknown_14,
        subject_lang_unknown_15,
        subject_lang_flags,
        body_lang_en_gb,
        body_lang_ko_kr,
        body_lang_fr_fr,
        body_lang_de_de,
        body_lang_en_cn,
        body_lang_en_tw,
        body_lang_es_es,
        body_lang_es_mx,
        body_lang_ru_ru,
        body_lang_ja_jp,
        body_lang_pt_pt,
        body_lang_it_it,
        body_lang_unknown_12,
        body_lang_unknown_13,
        body_lang_unknown_14,
        body_lang_unknown_15,
        body_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35
    );"
    ,
    "SELECT
        id,
        subject_lang_en_gb,
        subject_lang_ko_kr,
        subject_lang_fr_fr,
        subject_lang_de_de,
        subject_lang_en_cn,
        subject_lang_en_tw,
        subject_lang_es_es,
        subject_lang_es_mx,
        subject_lang_ru_ru,
        subject_lang_ja_jp,
        subject_lang_pt_pt,
        subject_lang_it_it,
        subject_lang_unknown_12,
        subject_lang_unknown_13,
        subject_lang_unknown_14,
        subject_lang_unknown_15,
        subject_lang_flags,
        body_lang_en_gb,
        body_lang_ko_kr,
        body_lang_fr_fr,
        body_lang_de_de,
        body_lang_en_cn,
        body_lang_en_tw,
        body_lang_es_es,
        body_lang_es_mx,
        body_lang_ru_ru,
        body_lang_ja_jp,
        body_lang_pt_pt,
        body_lang_it_it,
        body_lang_unknown_12,
        body_lang_unknown_13,
        body_lang_unknown_14,
        body_lang_unknown_15,
        body_lang_flags
    FROM `MailTemplate`;"
    )
}


pub(crate) fn mail_template_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<mail_template::MailTemplate, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(mail_template::MailTemplateRow {
            id: row.get::<_, i32>(0)?.into(),
            subject_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            body_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(18)?.into(),
                ko_kr: row.get::<_, String>(19)?.into(),
                fr_fr: row.get::<_, String>(20)?.into(),
                de_de: row.get::<_, String>(21)?.into(),
                en_cn: row.get::<_, String>(22)?.into(),
                en_tw: row.get::<_, String>(23)?.into(),
                es_es: row.get::<_, String>(24)?.into(),
                es_mx: row.get::<_, String>(25)?.into(),
                ru_ru: row.get::<_, String>(26)?.into(),
                ja_jp: row.get::<_, String>(27)?.into(),
                pt_pt: row.get::<_, String>(28)?.into(),
                it_it: row.get::<_, String>(29)?.into(),
                unknown_12: row.get::<_, String>(30)?.into(),
                unknown_13: row.get::<_, String>(31)?.into(),
                unknown_14: row.get::<_, String>(32)?.into(),
                unknown_15: row.get::<_, String>(33)?.into(),
                flags: row.get::<_, u32>(34)?.into(),
            },
        });
    }
    Ok(mail_template::MailTemplate { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Map() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Map (
        id INTEGER PRIMARY KEY NOT NULL,
        directory TEXT  NOT NULL,
        instance_type INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        p_v_p INTEGER  NOT NULL,
        map_name_lang_en_gb TEXT NOT NULL,
        map_name_lang_ko_kr TEXT NOT NULL,
        map_name_lang_fr_fr TEXT NOT NULL,
        map_name_lang_de_de TEXT NOT NULL,
        map_name_lang_en_cn TEXT NOT NULL,
        map_name_lang_en_tw TEXT NOT NULL,
        map_name_lang_es_es TEXT NOT NULL,
        map_name_lang_es_mx TEXT NOT NULL,
        map_name_lang_ru_ru TEXT NOT NULL,
        map_name_lang_ja_jp TEXT NOT NULL,
        map_name_lang_pt_pt TEXT NOT NULL,
        map_name_lang_it_it TEXT NOT NULL,
        map_name_lang_unknown_12 TEXT NOT NULL,
        map_name_lang_unknown_13 TEXT NOT NULL,
        map_name_lang_unknown_14 TEXT NOT NULL,
        map_name_lang_unknown_15 TEXT NOT NULL,
        map_name_lang_flags INTEGER NOT NULL,
        area_table_id INTEGER  NOT NULL,
        map_description0_lang_en_gb TEXT NOT NULL,
        map_description0_lang_ko_kr TEXT NOT NULL,
        map_description0_lang_fr_fr TEXT NOT NULL,
        map_description0_lang_de_de TEXT NOT NULL,
        map_description0_lang_en_cn TEXT NOT NULL,
        map_description0_lang_en_tw TEXT NOT NULL,
        map_description0_lang_es_es TEXT NOT NULL,
        map_description0_lang_es_mx TEXT NOT NULL,
        map_description0_lang_ru_ru TEXT NOT NULL,
        map_description0_lang_ja_jp TEXT NOT NULL,
        map_description0_lang_pt_pt TEXT NOT NULL,
        map_description0_lang_it_it TEXT NOT NULL,
        map_description0_lang_unknown_12 TEXT NOT NULL,
        map_description0_lang_unknown_13 TEXT NOT NULL,
        map_description0_lang_unknown_14 TEXT NOT NULL,
        map_description0_lang_unknown_15 TEXT NOT NULL,
        map_description0_lang_flags INTEGER NOT NULL,
        map_description1_lang_en_gb TEXT NOT NULL,
        map_description1_lang_ko_kr TEXT NOT NULL,
        map_description1_lang_fr_fr TEXT NOT NULL,
        map_description1_lang_de_de TEXT NOT NULL,
        map_description1_lang_en_cn TEXT NOT NULL,
        map_description1_lang_en_tw TEXT NOT NULL,
        map_description1_lang_es_es TEXT NOT NULL,
        map_description1_lang_es_mx TEXT NOT NULL,
        map_description1_lang_ru_ru TEXT NOT NULL,
        map_description1_lang_ja_jp TEXT NOT NULL,
        map_description1_lang_pt_pt TEXT NOT NULL,
        map_description1_lang_it_it TEXT NOT NULL,
        map_description1_lang_unknown_12 TEXT NOT NULL,
        map_description1_lang_unknown_13 TEXT NOT NULL,
        map_description1_lang_unknown_14 TEXT NOT NULL,
        map_description1_lang_unknown_15 TEXT NOT NULL,
        map_description1_lang_flags INTEGER NOT NULL,
        loading_screen_id INTEGER  NOT NULL,
        minimap_icon_scale REAL  NOT NULL,
        corpse_map_id INTEGER  NOT NULL,
        corpse_0 REAL NOT NULL,
        corpse_1 REAL NOT NULL,
        time_of_day_override INTEGER  NOT NULL,
        expansion_id INTEGER  NOT NULL,
        raid_offset INTEGER  NOT NULL,
        max_players INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Map (
        id,
        directory,
        instance_type,
        flags,
        p_v_p,
        map_name_lang_en_gb,
        map_name_lang_ko_kr,
        map_name_lang_fr_fr,
        map_name_lang_de_de,
        map_name_lang_en_cn,
        map_name_lang_en_tw,
        map_name_lang_es_es,
        map_name_lang_es_mx,
        map_name_lang_ru_ru,
        map_name_lang_ja_jp,
        map_name_lang_pt_pt,
        map_name_lang_it_it,
        map_name_lang_unknown_12,
        map_name_lang_unknown_13,
        map_name_lang_unknown_14,
        map_name_lang_unknown_15,
        map_name_lang_flags,
        area_table_id,
        map_description0_lang_en_gb,
        map_description0_lang_ko_kr,
        map_description0_lang_fr_fr,
        map_description0_lang_de_de,
        map_description0_lang_en_cn,
        map_description0_lang_en_tw,
        map_description0_lang_es_es,
        map_description0_lang_es_mx,
        map_description0_lang_ru_ru,
        map_description0_lang_ja_jp,
        map_description0_lang_pt_pt,
        map_description0_lang_it_it,
        map_description0_lang_unknown_12,
        map_description0_lang_unknown_13,
        map_description0_lang_unknown_14,
        map_description0_lang_unknown_15,
        map_description0_lang_flags,
        map_description1_lang_en_gb,
        map_description1_lang_ko_kr,
        map_description1_lang_fr_fr,
        map_description1_lang_de_de,
        map_description1_lang_en_cn,
        map_description1_lang_en_tw,
        map_description1_lang_es_es,
        map_description1_lang_es_mx,
        map_description1_lang_ru_ru,
        map_description1_lang_ja_jp,
        map_description1_lang_pt_pt,
        map_description1_lang_it_it,
        map_description1_lang_unknown_12,
        map_description1_lang_unknown_13,
        map_description1_lang_unknown_14,
        map_description1_lang_unknown_15,
        map_description1_lang_flags,
        loading_screen_id,
        minimap_icon_scale,
        corpse_map_id,
        corpse_0,
        corpse_1,
        time_of_day_override,
        expansion_id,
        raid_offset,
        max_players
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62,
        ?63,
        ?64,
        ?65,
        ?66
    );"
    ,
    "SELECT
        id,
        directory,
        instance_type,
        flags,
        p_v_p,
        map_name_lang_en_gb,
        map_name_lang_ko_kr,
        map_name_lang_fr_fr,
        map_name_lang_de_de,
        map_name_lang_en_cn,
        map_name_lang_en_tw,
        map_name_lang_es_es,
        map_name_lang_es_mx,
        map_name_lang_ru_ru,
        map_name_lang_ja_jp,
        map_name_lang_pt_pt,
        map_name_lang_it_it,
        map_name_lang_unknown_12,
        map_name_lang_unknown_13,
        map_name_lang_unknown_14,
        map_name_lang_unknown_15,
        map_name_lang_flags,
        area_table_id,
        map_description0_lang_en_gb,
        map_description0_lang_ko_kr,
        map_description0_lang_fr_fr,
        map_description0_lang_de_de,
        map_description0_lang_en_cn,
        map_description0_lang_en_tw,
        map_description0_lang_es_es,
        map_description0_lang_es_mx,
        map_description0_lang_ru_ru,
        map_description0_lang_ja_jp,
        map_description0_lang_pt_pt,
        map_description0_lang_it_it,
        map_description0_lang_unknown_12,
        map_description0_lang_unknown_13,
        map_description0_lang_unknown_14,
        map_description0_lang_unknown_15,
        map_description0_lang_flags,
        map_description1_lang_en_gb,
        map_description1_lang_ko_kr,
        map_description1_lang_fr_fr,
        map_description1_lang_de_de,
        map_description1_lang_en_cn,
        map_description1_lang_en_tw,
        map_description1_lang_es_es,
        map_description1_lang_es_mx,
        map_description1_lang_ru_ru,
        map_description1_lang_ja_jp,
        map_description1_lang_pt_pt,
        map_description1_lang_it_it,
        map_description1_lang_unknown_12,
        map_description1_lang_unknown_13,
        map_description1_lang_unknown_14,
        map_description1_lang_unknown_15,
        map_description1_lang_flags,
        loading_screen_id,
        minimap_icon_scale,
        corpse_map_id,
        corpse_0,
        corpse_1,
        time_of_day_override,
        expansion_id,
        raid_offset,
        max_players
    FROM `Map`;"
    )
}


pub(crate) fn map_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<map::Map, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(map::MapRow {
            id: row.get::<_, i32>(0)?.into(),
            directory: row.get::<_, String>(1)?.into(),
            instance_type: row.get::<_, i32>(2)?.into(),
            flags: row.get::<_, i32>(3)?.into(),
            p_v_p: row.get::<_, i32>(4)?.into(),
            map_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
            area_table_id: row.get::<_, i32>(22)?.into(),
            map_description0_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(23)?.into(),
                ko_kr: row.get::<_, String>(24)?.into(),
                fr_fr: row.get::<_, String>(25)?.into(),
                de_de: row.get::<_, String>(26)?.into(),
                en_cn: row.get::<_, String>(27)?.into(),
                en_tw: row.get::<_, String>(28)?.into(),
                es_es: row.get::<_, String>(29)?.into(),
                es_mx: row.get::<_, String>(30)?.into(),
                ru_ru: row.get::<_, String>(31)?.into(),
                ja_jp: row.get::<_, String>(32)?.into(),
                pt_pt: row.get::<_, String>(33)?.into(),
                it_it: row.get::<_, String>(34)?.into(),
                unknown_12: row.get::<_, String>(35)?.into(),
                unknown_13: row.get::<_, String>(36)?.into(),
                unknown_14: row.get::<_, String>(37)?.into(),
                unknown_15: row.get::<_, String>(38)?.into(),
                flags: row.get::<_, u32>(39)?.into(),
            },
            map_description1_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(40)?.into(),
                ko_kr: row.get::<_, String>(41)?.into(),
                fr_fr: row.get::<_, String>(42)?.into(),
                de_de: row.get::<_, String>(43)?.into(),
                en_cn: row.get::<_, String>(44)?.into(),
                en_tw: row.get::<_, String>(45)?.into(),
                es_es: row.get::<_, String>(46)?.into(),
                es_mx: row.get::<_, String>(47)?.into(),
                ru_ru: row.get::<_, String>(48)?.into(),
                ja_jp: row.get::<_, String>(49)?.into(),
                pt_pt: row.get::<_, String>(50)?.into(),
                it_it: row.get::<_, String>(51)?.into(),
                unknown_12: row.get::<_, String>(52)?.into(),
                unknown_13: row.get::<_, String>(53)?.into(),
                unknown_14: row.get::<_, String>(54)?.into(),
                unknown_15: row.get::<_, String>(55)?.into(),
                flags: row.get::<_, u32>(56)?.into(),
            },
            loading_screen_id: row.get::<_, i32>(57)?.into(),
            minimap_icon_scale: row.get::<_, f32>(58)?.into(),
            corpse_map_id: row.get::<_, i32>(59)?.into(),
            corpse: [row.get::<_, f32>(60)?.into(), row.get::<_, f32>(61)?.into(),             ],
            time_of_day_override: row.get::<_, i32>(62)?.into(),
            expansion_id: row.get::<_, i32>(63)?.into(),
            raid_offset: row.get::<_, i32>(64)?.into(),
            max_players: row.get::<_, i32>(65)?.into(),
        });
    }
    Ok(map::Map { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn MapDifficulty() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS MapDifficulty (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        difficulty INTEGER  NOT NULL,
        message_lang_en_gb TEXT NOT NULL,
        message_lang_ko_kr TEXT NOT NULL,
        message_lang_fr_fr TEXT NOT NULL,
        message_lang_de_de TEXT NOT NULL,
        message_lang_en_cn TEXT NOT NULL,
        message_lang_en_tw TEXT NOT NULL,
        message_lang_es_es TEXT NOT NULL,
        message_lang_es_mx TEXT NOT NULL,
        message_lang_ru_ru TEXT NOT NULL,
        message_lang_ja_jp TEXT NOT NULL,
        message_lang_pt_pt TEXT NOT NULL,
        message_lang_it_it TEXT NOT NULL,
        message_lang_unknown_12 TEXT NOT NULL,
        message_lang_unknown_13 TEXT NOT NULL,
        message_lang_unknown_14 TEXT NOT NULL,
        message_lang_unknown_15 TEXT NOT NULL,
        message_lang_flags INTEGER NOT NULL,
        raid_duration INTEGER  NOT NULL,
        max_players INTEGER  NOT NULL,
        difficultystring TEXT  NOT NULL
    );"
    ,
    "INSERT INTO MapDifficulty (
        id,
        map_id,
        difficulty,
        message_lang_en_gb,
        message_lang_ko_kr,
        message_lang_fr_fr,
        message_lang_de_de,
        message_lang_en_cn,
        message_lang_en_tw,
        message_lang_es_es,
        message_lang_es_mx,
        message_lang_ru_ru,
        message_lang_ja_jp,
        message_lang_pt_pt,
        message_lang_it_it,
        message_lang_unknown_12,
        message_lang_unknown_13,
        message_lang_unknown_14,
        message_lang_unknown_15,
        message_lang_flags,
        raid_duration,
        max_players,
        difficultystring
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        map_id,
        difficulty,
        message_lang_en_gb,
        message_lang_ko_kr,
        message_lang_fr_fr,
        message_lang_de_de,
        message_lang_en_cn,
        message_lang_en_tw,
        message_lang_es_es,
        message_lang_es_mx,
        message_lang_ru_ru,
        message_lang_ja_jp,
        message_lang_pt_pt,
        message_lang_it_it,
        message_lang_unknown_12,
        message_lang_unknown_13,
        message_lang_unknown_14,
        message_lang_unknown_15,
        message_lang_flags,
        raid_duration,
        max_players,
        difficultystring
    FROM `MapDifficulty`;"
    )
}


pub(crate) fn map_difficulty_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<map_difficulty::MapDifficulty, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(map_difficulty::MapDifficultyRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            difficulty: row.get::<_, i32>(2)?.into(),
            message_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
            raid_duration: row.get::<_, i32>(20)?.into(),
            max_players: row.get::<_, i32>(21)?.into(),
            difficultystring: row.get::<_, String>(22)?.into(),
        });
    }
    Ok(map_difficulty::MapDifficulty { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Material() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Material (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        foley_sound_id INTEGER  NOT NULL,
        sheathe_sound_id INTEGER  NOT NULL,
        unsheathe_sound_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Material (
        id,
        flags,
        foley_sound_id,
        sheathe_sound_id,
        unsheathe_sound_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        flags,
        foley_sound_id,
        sheathe_sound_id,
        unsheathe_sound_id
    FROM `Material`;"
    )
}


pub(crate) fn material_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<material::Material, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(material::MaterialRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            foley_sound_id: row.get::<_, i32>(2)?.into(),
            sheathe_sound_id: row.get::<_, i32>(3)?.into(),
            unsheathe_sound_id: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(material::Material { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Movie() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Movie (
        id INTEGER PRIMARY KEY NOT NULL,
        filename TEXT  NOT NULL,
        volume INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Movie (
        id,
        filename,
        volume
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        filename,
        volume
    FROM `Movie`;"
    )
}


pub(crate) fn movie_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<movie::Movie, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(movie::MovieRow {
            id: row.get::<_, i32>(0)?.into(),
            filename: row.get::<_, String>(1)?.into(),
            volume: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(movie::Movie { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn MovieFileData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS MovieFileData (
        file_data_id INTEGER  NOT NULL,
        resolution INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO MovieFileData (
        file_data_id,
        resolution
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        file_data_id,
        resolution
    FROM `MovieFileData`;"
    )
}


pub(crate) fn movie_file_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<movie_file_data::MovieFileData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(movie_file_data::MovieFileDataRow {
            file_data_id: row.get::<_, i32>(0)?.into(),
            resolution: row.get::<_, i32>(1)?.into(),
        });
    }
    Ok(movie_file_data::MovieFileData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn MovieVariation() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS MovieVariation (
        id INTEGER PRIMARY KEY NOT NULL,
        movie_id INTEGER  NOT NULL,
        file_data_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO MovieVariation (
        id,
        movie_id,
        file_data_id
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        movie_id,
        file_data_id
    FROM `MovieVariation`;"
    )
}


pub(crate) fn movie_variation_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<movie_variation::MovieVariation, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(movie_variation::MovieVariationRow {
            id: row.get::<_, i32>(0)?.into(),
            movie_id: row.get::<_, i32>(1)?.into(),
            file_data_id: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(movie_variation::MovieVariation { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn NPCSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS NPCSounds (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_id_0 INTEGER NOT NULL,
        sound_id_1 INTEGER NOT NULL,
        sound_id_2 INTEGER NOT NULL,
        sound_id_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO NPCSounds (
        id,
        sound_id_0,
        sound_id_1,
        sound_id_2,
        sound_id_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        sound_id_0,
        sound_id_1,
        sound_id_2,
        sound_id_3
    FROM `NPCSounds`;"
    )
}


pub(crate) fn npc_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<npc_sounds::NPCSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(npc_sounds::NPCSoundsRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
        });
    }
    Ok(npc_sounds::NPCSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn NameGen() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS NameGen (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        race_id INTEGER  NOT NULL,
        sex INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO NameGen (
        id,
        name,
        race_id,
        sex
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        name,
        race_id,
        sex
    FROM `NameGen`;"
    )
}


pub(crate) fn name_gen_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<name_gen::NameGen, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(name_gen::NameGenRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            race_id: row.get::<_, i32>(2)?.into(),
            sex: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(name_gen::NameGen { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn NamesProfanity() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS NamesProfanity (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        language INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO NamesProfanity (
        id,
        name,
        language
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        name,
        language
    FROM `NamesProfanity`;"
    )
}


pub(crate) fn names_profanity_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<names_profanity::NamesProfanity, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(names_profanity::NamesProfanityRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            language: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(names_profanity::NamesProfanity { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn NamesReserved() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS NamesReserved (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        language INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO NamesReserved (
        id,
        name,
        language
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        name,
        language
    FROM `NamesReserved`;"
    )
}


pub(crate) fn names_reserved_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<names_reserved::NamesReserved, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(names_reserved::NamesReservedRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            language: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(names_reserved::NamesReserved { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ObjectEffect() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ObjectEffect (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        object_effect_group_id INTEGER  NOT NULL,
        trigger_type INTEGER  NOT NULL,
        event_type INTEGER  NOT NULL,
        effect_rec_type INTEGER  NOT NULL,
        effect_rec_id INTEGER  NOT NULL,
        attachment INTEGER  NOT NULL,
        offset_0 REAL NOT NULL,
        offset_1 REAL NOT NULL,
        offset_2 REAL NOT NULL,
        object_effect_modifier_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ObjectEffect (
        id,
        name,
        object_effect_group_id,
        trigger_type,
        event_type,
        effect_rec_type,
        effect_rec_id,
        attachment,
        offset_0,
        offset_1,
        offset_2,
        object_effect_modifier_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12
    );"
    ,
    "SELECT
        id,
        name,
        object_effect_group_id,
        trigger_type,
        event_type,
        effect_rec_type,
        effect_rec_id,
        attachment,
        offset_0,
        offset_1,
        offset_2,
        object_effect_modifier_id
    FROM `ObjectEffect`;"
    )
}


pub(crate) fn object_effect_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<object_effect::ObjectEffect, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(object_effect::ObjectEffectRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            object_effect_group_id: row.get::<_, i32>(2)?.into(),
            trigger_type: row.get::<_, i32>(3)?.into(),
            event_type: row.get::<_, i32>(4)?.into(),
            effect_rec_type: row.get::<_, i32>(5)?.into(),
            effect_rec_id: row.get::<_, i32>(6)?.into(),
            attachment: row.get::<_, i32>(7)?.into(),
            offset: [row.get::<_, f32>(8)?.into(), row.get::<_, f32>(9)?.into(), row.get::<_, f32>(10)?.into(),             ],
            object_effect_modifier_id: row.get::<_, i32>(11)?.into(),
        });
    }
    Ok(object_effect::ObjectEffect { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ObjectEffectGroup() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ObjectEffectGroup (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO ObjectEffectGroup (
        id,
        name
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        name
    FROM `ObjectEffectGroup`;"
    )
}


pub(crate) fn object_effect_group_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<object_effect_group::ObjectEffectGroup, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(object_effect_group::ObjectEffectGroupRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(object_effect_group::ObjectEffectGroup { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ObjectEffectModifier() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ObjectEffectModifier (
        id INTEGER PRIMARY KEY NOT NULL,
        input_type INTEGER  NOT NULL,
        map_type INTEGER  NOT NULL,
        output_type INTEGER  NOT NULL,
        param_0 REAL NOT NULL,
        param_1 REAL NOT NULL,
        param_2 REAL NOT NULL,
        param_3 REAL NOT NULL
    );"
    ,
    "INSERT INTO ObjectEffectModifier (
        id,
        input_type,
        map_type,
        output_type,
        param_0,
        param_1,
        param_2,
        param_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        input_type,
        map_type,
        output_type,
        param_0,
        param_1,
        param_2,
        param_3
    FROM `ObjectEffectModifier`;"
    )
}


pub(crate) fn object_effect_modifier_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<object_effect_modifier::ObjectEffectModifier, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(object_effect_modifier::ObjectEffectModifierRow {
            id: row.get::<_, i32>(0)?.into(),
            input_type: row.get::<_, i32>(1)?.into(),
            map_type: row.get::<_, i32>(2)?.into(),
            output_type: row.get::<_, i32>(3)?.into(),
            param: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(), row.get::<_, f32>(7)?.into(),             ],
        });
    }
    Ok(object_effect_modifier::ObjectEffectModifier { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ObjectEffectPackage() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ObjectEffectPackage (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO ObjectEffectPackage (
        id,
        name
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        name
    FROM `ObjectEffectPackage`;"
    )
}


pub(crate) fn object_effect_package_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<object_effect_package::ObjectEffectPackage, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(object_effect_package::ObjectEffectPackageRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(object_effect_package::ObjectEffectPackage { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ObjectEffectPackageElem() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ObjectEffectPackageElem (
        id INTEGER PRIMARY KEY NOT NULL,
        object_effect_package_id INTEGER  NOT NULL,
        object_effect_group_id INTEGER  NOT NULL,
        state_type INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ObjectEffectPackageElem (
        id,
        object_effect_package_id,
        object_effect_group_id,
        state_type
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        object_effect_package_id,
        object_effect_group_id,
        state_type
    FROM `ObjectEffectPackageElem`;"
    )
}


pub(crate) fn object_effect_package_elem_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<object_effect_package_elem::ObjectEffectPackageElem, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(object_effect_package_elem::ObjectEffectPackageElemRow {
            id: row.get::<_, i32>(0)?.into(),
            object_effect_package_id: row.get::<_, i32>(1)?.into(),
            object_effect_group_id: row.get::<_, i32>(2)?.into(),
            state_type: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(object_effect_package_elem::ObjectEffectPackageElem { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn OverrideSpellData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS OverrideSpellData (
        id INTEGER PRIMARY KEY NOT NULL,
        spells_0 INTEGER NOT NULL,
        spells_1 INTEGER NOT NULL,
        spells_2 INTEGER NOT NULL,
        spells_3 INTEGER NOT NULL,
        spells_4 INTEGER NOT NULL,
        spells_5 INTEGER NOT NULL,
        spells_6 INTEGER NOT NULL,
        spells_7 INTEGER NOT NULL,
        spells_8 INTEGER NOT NULL,
        spells_9 INTEGER NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO OverrideSpellData (
        id,
        spells_0,
        spells_1,
        spells_2,
        spells_3,
        spells_4,
        spells_5,
        spells_6,
        spells_7,
        spells_8,
        spells_9,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12
    );"
    ,
    "SELECT
        id,
        spells_0,
        spells_1,
        spells_2,
        spells_3,
        spells_4,
        spells_5,
        spells_6,
        spells_7,
        spells_8,
        spells_9,
        flags
    FROM `OverrideSpellData`;"
    )
}


pub(crate) fn override_spell_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<override_spell_data::OverrideSpellData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(override_spell_data::OverrideSpellDataRow {
            id: row.get::<_, i32>(0)?.into(),
            spells: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            flags: row.get::<_, i32>(11)?.into(),
        });
    }
    Ok(override_spell_data::OverrideSpellData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Package() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Package (
        id INTEGER PRIMARY KEY NOT NULL,
        icon TEXT  NOT NULL,
        cost INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Package (
        id,
        icon,
        cost,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        icon,
        cost,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `Package`;"
    )
}


pub(crate) fn package_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<package::Package, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(package::PackageRow {
            id: row.get::<_, i32>(0)?.into(),
            icon: row.get::<_, String>(1)?.into(),
            cost: row.get::<_, i32>(2)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
        });
    }
    Ok(package::Package { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PageTextMaterial() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PageTextMaterial (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO PageTextMaterial (
        id,
        name
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        name
    FROM `PageTextMaterial`;"
    )
}


pub(crate) fn page_text_material_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<page_text_material::PageTextMaterial, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(page_text_material::PageTextMaterialRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(page_text_material::PageTextMaterial { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PaperDollItemFrame() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PaperDollItemFrame (
        item_button_name TEXT  NOT NULL,
        slot_icon TEXT  NOT NULL,
        slot_number INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO PaperDollItemFrame (
        item_button_name,
        slot_icon,
        slot_number
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        item_button_name,
        slot_icon,
        slot_number
    FROM `PaperDollItemFrame`;"
    )
}


pub(crate) fn paper_doll_item_frame_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<paper_doll_item_frame::PaperDollItemFrame, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(paper_doll_item_frame::PaperDollItemFrameRow {
            item_button_name: row.get::<_, String>(0)?.into(),
            slot_icon: row.get::<_, String>(1)?.into(),
            slot_number: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(paper_doll_item_frame::PaperDollItemFrame { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ParticleColor() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ParticleColor (
        id INTEGER PRIMARY KEY NOT NULL,
        start_0 INTEGER NOT NULL,
        start_1 INTEGER NOT NULL,
        start_2 INTEGER NOT NULL,
        m_id_0 INTEGER NOT NULL,
        m_id_1 INTEGER NOT NULL,
        m_id_2 INTEGER NOT NULL,
        end_0 INTEGER NOT NULL,
        end_1 INTEGER NOT NULL,
        end_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ParticleColor (
        id,
        start_0,
        start_1,
        start_2,
        m_id_0,
        m_id_1,
        m_id_2,
        end_0,
        end_1,
        end_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        start_0,
        start_1,
        start_2,
        m_id_0,
        m_id_1,
        m_id_2,
        end_0,
        end_1,
        end_2
    FROM `ParticleColor`;"
    )
}


pub(crate) fn particle_color_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<particle_color::ParticleColor, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(particle_color::ParticleColorRow {
            id: row.get::<_, i32>(0)?.into(),
            start: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(),             ],
            m_id: [row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
            end: [row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(),             ],
        });
    }
    Ok(particle_color::ParticleColor { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PetPersonality() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PetPersonality (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        happiness_threshold_0 INTEGER NOT NULL,
        happiness_threshold_1 INTEGER NOT NULL,
        happiness_threshold_2 INTEGER NOT NULL,
        happiness_damage_0 REAL NOT NULL,
        happiness_damage_1 REAL NOT NULL,
        happiness_damage_2 REAL NOT NULL
    );"
    ,
    "INSERT INTO PetPersonality (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        happiness_threshold_0,
        happiness_threshold_1,
        happiness_threshold_2,
        happiness_damage_0,
        happiness_damage_1,
        happiness_damage_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        happiness_threshold_0,
        happiness_threshold_1,
        happiness_threshold_2,
        happiness_damage_0,
        happiness_damage_1,
        happiness_damage_2
    FROM `PetPersonality`;"
    )
}


pub(crate) fn pet_personality_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<pet_personality::PetPersonality, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(pet_personality::PetPersonalityRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            happiness_threshold: [row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(),             ],
            happiness_damage: [row.get::<_, f32>(21)?.into(), row.get::<_, f32>(22)?.into(), row.get::<_, f32>(23)?.into(),             ],
        });
    }
    Ok(pet_personality::PetPersonality { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PetitionType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PetitionType (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        ty INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO PetitionType (
        id,
        name,
        ty
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        name,
        ty
    FROM `PetitionType`;"
    )
}


pub(crate) fn petition_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<petition_type::PetitionType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(petition_type::PetitionTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            ty: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(petition_type::PetitionType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PowerDisplay() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PowerDisplay (
        id INTEGER PRIMARY KEY NOT NULL,
        actual_type INTEGER  NOT NULL,
        global_string_base_tag TEXT  NOT NULL,
        red INTEGER  NOT NULL,
        green INTEGER  NOT NULL,
        blue INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO PowerDisplay (
        id,
        actual_type,
        global_string_base_tag,
        red,
        green,
        blue
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        id,
        actual_type,
        global_string_base_tag,
        red,
        green,
        blue
    FROM `PowerDisplay`;"
    )
}


pub(crate) fn power_display_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<power_display::PowerDisplay, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(power_display::PowerDisplayRow {
            id: row.get::<_, i32>(0)?.into(),
            actual_type: row.get::<_, i32>(1)?.into(),
            global_string_base_tag: row.get::<_, String>(2)?.into(),
            red: row.get::<_, i8>(3)?.into(),
            green: row.get::<_, i8>(4)?.into(),
            blue: row.get::<_, i8>(5)?.into(),
        });
    }
    Ok(power_display::PowerDisplay { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn PvpDifficulty() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS PvpDifficulty (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        range_index INTEGER  NOT NULL,
        min_level INTEGER  NOT NULL,
        max_level INTEGER  NOT NULL,
        difficulty INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO PvpDifficulty (
        id,
        map_id,
        range_index,
        min_level,
        max_level,
        difficulty
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        id,
        map_id,
        range_index,
        min_level,
        max_level,
        difficulty
    FROM `PvpDifficulty`;"
    )
}


pub(crate) fn pvp_difficulty_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<pvp_difficulty::PvpDifficulty, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(pvp_difficulty::PvpDifficultyRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            range_index: row.get::<_, i32>(2)?.into(),
            min_level: row.get::<_, i32>(3)?.into(),
            max_level: row.get::<_, i32>(4)?.into(),
            difficulty: row.get::<_, i32>(5)?.into(),
        });
    }
    Ok(pvp_difficulty::PvpDifficulty { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn QuestFactionReward() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS QuestFactionReward (
        id INTEGER PRIMARY KEY NOT NULL,
        difficulty_0 INTEGER NOT NULL,
        difficulty_1 INTEGER NOT NULL,
        difficulty_2 INTEGER NOT NULL,
        difficulty_3 INTEGER NOT NULL,
        difficulty_4 INTEGER NOT NULL,
        difficulty_5 INTEGER NOT NULL,
        difficulty_6 INTEGER NOT NULL,
        difficulty_7 INTEGER NOT NULL,
        difficulty_8 INTEGER NOT NULL,
        difficulty_9 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO QuestFactionReward (
        id,
        difficulty_0,
        difficulty_1,
        difficulty_2,
        difficulty_3,
        difficulty_4,
        difficulty_5,
        difficulty_6,
        difficulty_7,
        difficulty_8,
        difficulty_9
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        difficulty_0,
        difficulty_1,
        difficulty_2,
        difficulty_3,
        difficulty_4,
        difficulty_5,
        difficulty_6,
        difficulty_7,
        difficulty_8,
        difficulty_9
    FROM `QuestFactionReward`;"
    )
}


pub(crate) fn quest_faction_reward_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<quest_faction_reward::QuestFactionReward, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(quest_faction_reward::QuestFactionRewardRow {
            id: row.get::<_, i32>(0)?.into(),
            difficulty: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
        });
    }
    Ok(quest_faction_reward::QuestFactionReward { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn QuestInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS QuestInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        info_name_lang_en_gb TEXT NOT NULL,
        info_name_lang_ko_kr TEXT NOT NULL,
        info_name_lang_fr_fr TEXT NOT NULL,
        info_name_lang_de_de TEXT NOT NULL,
        info_name_lang_en_cn TEXT NOT NULL,
        info_name_lang_en_tw TEXT NOT NULL,
        info_name_lang_es_es TEXT NOT NULL,
        info_name_lang_es_mx TEXT NOT NULL,
        info_name_lang_ru_ru TEXT NOT NULL,
        info_name_lang_ja_jp TEXT NOT NULL,
        info_name_lang_pt_pt TEXT NOT NULL,
        info_name_lang_it_it TEXT NOT NULL,
        info_name_lang_unknown_12 TEXT NOT NULL,
        info_name_lang_unknown_13 TEXT NOT NULL,
        info_name_lang_unknown_14 TEXT NOT NULL,
        info_name_lang_unknown_15 TEXT NOT NULL,
        info_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO QuestInfo (
        id,
        info_name_lang_en_gb,
        info_name_lang_ko_kr,
        info_name_lang_fr_fr,
        info_name_lang_de_de,
        info_name_lang_en_cn,
        info_name_lang_en_tw,
        info_name_lang_es_es,
        info_name_lang_es_mx,
        info_name_lang_ru_ru,
        info_name_lang_ja_jp,
        info_name_lang_pt_pt,
        info_name_lang_it_it,
        info_name_lang_unknown_12,
        info_name_lang_unknown_13,
        info_name_lang_unknown_14,
        info_name_lang_unknown_15,
        info_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        info_name_lang_en_gb,
        info_name_lang_ko_kr,
        info_name_lang_fr_fr,
        info_name_lang_de_de,
        info_name_lang_en_cn,
        info_name_lang_en_tw,
        info_name_lang_es_es,
        info_name_lang_es_mx,
        info_name_lang_ru_ru,
        info_name_lang_ja_jp,
        info_name_lang_pt_pt,
        info_name_lang_it_it,
        info_name_lang_unknown_12,
        info_name_lang_unknown_13,
        info_name_lang_unknown_14,
        info_name_lang_unknown_15,
        info_name_lang_flags
    FROM `QuestInfo`;"
    )
}


pub(crate) fn quest_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<quest_info::QuestInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(quest_info::QuestInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            info_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(quest_info::QuestInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn QuestSort() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS QuestSort (
        id INTEGER PRIMARY KEY NOT NULL,
        sort_name_lang_en_gb TEXT NOT NULL,
        sort_name_lang_ko_kr TEXT NOT NULL,
        sort_name_lang_fr_fr TEXT NOT NULL,
        sort_name_lang_de_de TEXT NOT NULL,
        sort_name_lang_en_cn TEXT NOT NULL,
        sort_name_lang_en_tw TEXT NOT NULL,
        sort_name_lang_es_es TEXT NOT NULL,
        sort_name_lang_es_mx TEXT NOT NULL,
        sort_name_lang_ru_ru TEXT NOT NULL,
        sort_name_lang_ja_jp TEXT NOT NULL,
        sort_name_lang_pt_pt TEXT NOT NULL,
        sort_name_lang_it_it TEXT NOT NULL,
        sort_name_lang_unknown_12 TEXT NOT NULL,
        sort_name_lang_unknown_13 TEXT NOT NULL,
        sort_name_lang_unknown_14 TEXT NOT NULL,
        sort_name_lang_unknown_15 TEXT NOT NULL,
        sort_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO QuestSort (
        id,
        sort_name_lang_en_gb,
        sort_name_lang_ko_kr,
        sort_name_lang_fr_fr,
        sort_name_lang_de_de,
        sort_name_lang_en_cn,
        sort_name_lang_en_tw,
        sort_name_lang_es_es,
        sort_name_lang_es_mx,
        sort_name_lang_ru_ru,
        sort_name_lang_ja_jp,
        sort_name_lang_pt_pt,
        sort_name_lang_it_it,
        sort_name_lang_unknown_12,
        sort_name_lang_unknown_13,
        sort_name_lang_unknown_14,
        sort_name_lang_unknown_15,
        sort_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        sort_name_lang_en_gb,
        sort_name_lang_ko_kr,
        sort_name_lang_fr_fr,
        sort_name_lang_de_de,
        sort_name_lang_en_cn,
        sort_name_lang_en_tw,
        sort_name_lang_es_es,
        sort_name_lang_es_mx,
        sort_name_lang_ru_ru,
        sort_name_lang_ja_jp,
        sort_name_lang_pt_pt,
        sort_name_lang_it_it,
        sort_name_lang_unknown_12,
        sort_name_lang_unknown_13,
        sort_name_lang_unknown_14,
        sort_name_lang_unknown_15,
        sort_name_lang_flags
    FROM `QuestSort`;"
    )
}


pub(crate) fn quest_sort_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<quest_sort::QuestSort, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(quest_sort::QuestSortRow {
            id: row.get::<_, i32>(0)?.into(),
            sort_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(quest_sort::QuestSort { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn QuestXP() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS QuestXP (
        id INTEGER PRIMARY KEY NOT NULL,
        difficulty_0 INTEGER NOT NULL,
        difficulty_1 INTEGER NOT NULL,
        difficulty_2 INTEGER NOT NULL,
        difficulty_3 INTEGER NOT NULL,
        difficulty_4 INTEGER NOT NULL,
        difficulty_5 INTEGER NOT NULL,
        difficulty_6 INTEGER NOT NULL,
        difficulty_7 INTEGER NOT NULL,
        difficulty_8 INTEGER NOT NULL,
        difficulty_9 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO QuestXP (
        id,
        difficulty_0,
        difficulty_1,
        difficulty_2,
        difficulty_3,
        difficulty_4,
        difficulty_5,
        difficulty_6,
        difficulty_7,
        difficulty_8,
        difficulty_9
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        difficulty_0,
        difficulty_1,
        difficulty_2,
        difficulty_3,
        difficulty_4,
        difficulty_5,
        difficulty_6,
        difficulty_7,
        difficulty_8,
        difficulty_9
    FROM `QuestXP`;"
    )
}


pub(crate) fn quest_xp_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<quest_xp::QuestXP, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(quest_xp::QuestXPRow {
            id: row.get::<_, i32>(0)?.into(),
            difficulty: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
        });
    }
    Ok(quest_xp::QuestXP { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn RandPropPoints() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS RandPropPoints (
        id INTEGER PRIMARY KEY NOT NULL,
        epic_0 INTEGER NOT NULL,
        epic_1 INTEGER NOT NULL,
        epic_2 INTEGER NOT NULL,
        epic_3 INTEGER NOT NULL,
        epic_4 INTEGER NOT NULL,
        superior_0 INTEGER NOT NULL,
        superior_1 INTEGER NOT NULL,
        superior_2 INTEGER NOT NULL,
        superior_3 INTEGER NOT NULL,
        superior_4 INTEGER NOT NULL,
        good_0 INTEGER NOT NULL,
        good_1 INTEGER NOT NULL,
        good_2 INTEGER NOT NULL,
        good_3 INTEGER NOT NULL,
        good_4 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO RandPropPoints (
        id,
        epic_0,
        epic_1,
        epic_2,
        epic_3,
        epic_4,
        superior_0,
        superior_1,
        superior_2,
        superior_3,
        superior_4,
        good_0,
        good_1,
        good_2,
        good_3,
        good_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16
    );"
    ,
    "SELECT
        id,
        epic_0,
        epic_1,
        epic_2,
        epic_3,
        epic_4,
        superior_0,
        superior_1,
        superior_2,
        superior_3,
        superior_4,
        good_0,
        good_1,
        good_2,
        good_3,
        good_4
    FROM `RandPropPoints`;"
    )
}


pub(crate) fn rand_prop_points_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<rand_prop_points::RandPropPoints, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(rand_prop_points::RandPropPointsRow {
            id: row.get::<_, i32>(0)?.into(),
            epic: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
            superior: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            good: [row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(),             ],
        });
    }
    Ok(rand_prop_points::RandPropPoints { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Resistances() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Resistances (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        fizzle_sound_id INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Resistances (
        id,
        flags,
        fizzle_sound_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        flags,
        fizzle_sound_id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `Resistances`;"
    )
}


pub(crate) fn resistances_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<resistances::Resistances, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(resistances::ResistancesRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            fizzle_sound_id: row.get::<_, i32>(2)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
        });
    }
    Ok(resistances::Resistances { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ScalingStatDistribution() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ScalingStatDistribution (
        id INTEGER PRIMARY KEY NOT NULL,
        stat_id_0 INTEGER NOT NULL,
        stat_id_1 INTEGER NOT NULL,
        stat_id_2 INTEGER NOT NULL,
        stat_id_3 INTEGER NOT NULL,
        stat_id_4 INTEGER NOT NULL,
        stat_id_5 INTEGER NOT NULL,
        stat_id_6 INTEGER NOT NULL,
        stat_id_7 INTEGER NOT NULL,
        stat_id_8 INTEGER NOT NULL,
        stat_id_9 INTEGER NOT NULL,
        bonus_0 INTEGER NOT NULL,
        bonus_1 INTEGER NOT NULL,
        bonus_2 INTEGER NOT NULL,
        bonus_3 INTEGER NOT NULL,
        bonus_4 INTEGER NOT NULL,
        bonus_5 INTEGER NOT NULL,
        bonus_6 INTEGER NOT NULL,
        bonus_7 INTEGER NOT NULL,
        bonus_8 INTEGER NOT NULL,
        bonus_9 INTEGER NOT NULL,
        maxlevel INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ScalingStatDistribution (
        id,
        stat_id_0,
        stat_id_1,
        stat_id_2,
        stat_id_3,
        stat_id_4,
        stat_id_5,
        stat_id_6,
        stat_id_7,
        stat_id_8,
        stat_id_9,
        bonus_0,
        bonus_1,
        bonus_2,
        bonus_3,
        bonus_4,
        bonus_5,
        bonus_6,
        bonus_7,
        bonus_8,
        bonus_9,
        maxlevel
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22
    );"
    ,
    "SELECT
        id,
        stat_id_0,
        stat_id_1,
        stat_id_2,
        stat_id_3,
        stat_id_4,
        stat_id_5,
        stat_id_6,
        stat_id_7,
        stat_id_8,
        stat_id_9,
        bonus_0,
        bonus_1,
        bonus_2,
        bonus_3,
        bonus_4,
        bonus_5,
        bonus_6,
        bonus_7,
        bonus_8,
        bonus_9,
        maxlevel
    FROM `ScalingStatDistribution`;"
    )
}


pub(crate) fn scaling_stat_distribution_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<scaling_stat_distribution::ScalingStatDistribution, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(scaling_stat_distribution::ScalingStatDistributionRow {
            id: row.get::<_, i32>(0)?.into(),
            stat_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            bonus: [row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(),             ],
            maxlevel: row.get::<_, i32>(21)?.into(),
        });
    }
    Ok(scaling_stat_distribution::ScalingStatDistribution { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ScalingStatValues() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ScalingStatValues (
        id INTEGER PRIMARY KEY NOT NULL,
        charlevel INTEGER  NOT NULL,
        shoulder_budget INTEGER  NOT NULL,
        trinket_budget INTEGER  NOT NULL,
        weapon_budget1_h INTEGER  NOT NULL,
        ranged_budget INTEGER  NOT NULL,
        cloth_shoulder_armor INTEGER  NOT NULL,
        leather_shoulder_armor INTEGER  NOT NULL,
        mail_shoulder_armor INTEGER  NOT NULL,
        plate_shoulder_armor INTEGER  NOT NULL,
        weapon_d_p_s1_h INTEGER  NOT NULL,
        weapon_d_p_s2_h INTEGER  NOT NULL,
        spellcaster_d_p_s1_h INTEGER  NOT NULL,
        spellcaster_d_p_s2_h INTEGER  NOT NULL,
        ranged_d_p_s INTEGER  NOT NULL,
        wand_d_p_s INTEGER  NOT NULL,
        spell_power INTEGER  NOT NULL,
        primary_budget INTEGER  NOT NULL,
        tertiary_budget INTEGER  NOT NULL,
        cloth_cloak_armor INTEGER  NOT NULL,
        cloth_chest_armor INTEGER  NOT NULL,
        leather_chest_armor INTEGER  NOT NULL,
        mail_chest_armor INTEGER  NOT NULL,
        plate_chest_armor INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ScalingStatValues (
        id,
        charlevel,
        shoulder_budget,
        trinket_budget,
        weapon_budget1_h,
        ranged_budget,
        cloth_shoulder_armor,
        leather_shoulder_armor,
        mail_shoulder_armor,
        plate_shoulder_armor,
        weapon_d_p_s1_h,
        weapon_d_p_s2_h,
        spellcaster_d_p_s1_h,
        spellcaster_d_p_s2_h,
        ranged_d_p_s,
        wand_d_p_s,
        spell_power,
        primary_budget,
        tertiary_budget,
        cloth_cloak_armor,
        cloth_chest_armor,
        leather_chest_armor,
        mail_chest_armor,
        plate_chest_armor
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        charlevel,
        shoulder_budget,
        trinket_budget,
        weapon_budget1_h,
        ranged_budget,
        cloth_shoulder_armor,
        leather_shoulder_armor,
        mail_shoulder_armor,
        plate_shoulder_armor,
        weapon_d_p_s1_h,
        weapon_d_p_s2_h,
        spellcaster_d_p_s1_h,
        spellcaster_d_p_s2_h,
        ranged_d_p_s,
        wand_d_p_s,
        spell_power,
        primary_budget,
        tertiary_budget,
        cloth_cloak_armor,
        cloth_chest_armor,
        leather_chest_armor,
        mail_chest_armor,
        plate_chest_armor
    FROM `ScalingStatValues`;"
    )
}


pub(crate) fn scaling_stat_values_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<scaling_stat_values::ScalingStatValues, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(scaling_stat_values::ScalingStatValuesRow {
            id: row.get::<_, i32>(0)?.into(),
            charlevel: row.get::<_, i32>(1)?.into(),
            shoulder_budget: row.get::<_, i32>(2)?.into(),
            trinket_budget: row.get::<_, i32>(3)?.into(),
            weapon_budget1_h: row.get::<_, i32>(4)?.into(),
            ranged_budget: row.get::<_, i32>(5)?.into(),
            cloth_shoulder_armor: row.get::<_, i32>(6)?.into(),
            leather_shoulder_armor: row.get::<_, i32>(7)?.into(),
            mail_shoulder_armor: row.get::<_, i32>(8)?.into(),
            plate_shoulder_armor: row.get::<_, i32>(9)?.into(),
            weapon_d_p_s1_h: row.get::<_, i32>(10)?.into(),
            weapon_d_p_s2_h: row.get::<_, i32>(11)?.into(),
            spellcaster_d_p_s1_h: row.get::<_, i32>(12)?.into(),
            spellcaster_d_p_s2_h: row.get::<_, i32>(13)?.into(),
            ranged_d_p_s: row.get::<_, i32>(14)?.into(),
            wand_d_p_s: row.get::<_, i32>(15)?.into(),
            spell_power: row.get::<_, i32>(16)?.into(),
            primary_budget: row.get::<_, i32>(17)?.into(),
            tertiary_budget: row.get::<_, i32>(18)?.into(),
            cloth_cloak_armor: row.get::<_, i32>(19)?.into(),
            cloth_chest_armor: row.get::<_, i32>(20)?.into(),
            leather_chest_armor: row.get::<_, i32>(21)?.into(),
            mail_chest_armor: row.get::<_, i32>(22)?.into(),
            plate_chest_armor: row.get::<_, i32>(23)?.into(),
        });
    }
    Ok(scaling_stat_values::ScalingStatValues { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ScreenEffect() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ScreenEffect (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        effect INTEGER  NOT NULL,
        param_0 INTEGER NOT NULL,
        param_1 INTEGER NOT NULL,
        param_2 INTEGER NOT NULL,
        param_3 INTEGER NOT NULL,
        light_params_id INTEGER  NOT NULL,
        sound_ambience_id INTEGER  NOT NULL,
        zone_music_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ScreenEffect (
        id,
        name,
        effect,
        param_0,
        param_1,
        param_2,
        param_3,
        light_params_id,
        sound_ambience_id,
        zone_music_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        name,
        effect,
        param_0,
        param_1,
        param_2,
        param_3,
        light_params_id,
        sound_ambience_id,
        zone_music_id
    FROM `ScreenEffect`;"
    )
}


pub(crate) fn screen_effect_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<screen_effect::ScreenEffect, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(screen_effect::ScreenEffectRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            effect: row.get::<_, i32>(2)?.into(),
            param: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
            light_params_id: row.get::<_, i32>(7)?.into(),
            sound_ambience_id: row.get::<_, i32>(8)?.into(),
            zone_music_id: row.get::<_, i32>(9)?.into(),
        });
    }
    Ok(screen_effect::ScreenEffect { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ServerMessages() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ServerMessages (
        id INTEGER PRIMARY KEY NOT NULL,
        text_lang_en_gb TEXT NOT NULL,
        text_lang_ko_kr TEXT NOT NULL,
        text_lang_fr_fr TEXT NOT NULL,
        text_lang_de_de TEXT NOT NULL,
        text_lang_en_cn TEXT NOT NULL,
        text_lang_en_tw TEXT NOT NULL,
        text_lang_es_es TEXT NOT NULL,
        text_lang_es_mx TEXT NOT NULL,
        text_lang_ru_ru TEXT NOT NULL,
        text_lang_ja_jp TEXT NOT NULL,
        text_lang_pt_pt TEXT NOT NULL,
        text_lang_it_it TEXT NOT NULL,
        text_lang_unknown_12 TEXT NOT NULL,
        text_lang_unknown_13 TEXT NOT NULL,
        text_lang_unknown_14 TEXT NOT NULL,
        text_lang_unknown_15 TEXT NOT NULL,
        text_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ServerMessages (
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        text_lang_en_gb,
        text_lang_ko_kr,
        text_lang_fr_fr,
        text_lang_de_de,
        text_lang_en_cn,
        text_lang_en_tw,
        text_lang_es_es,
        text_lang_es_mx,
        text_lang_ru_ru,
        text_lang_ja_jp,
        text_lang_pt_pt,
        text_lang_it_it,
        text_lang_unknown_12,
        text_lang_unknown_13,
        text_lang_unknown_14,
        text_lang_unknown_15,
        text_lang_flags
    FROM `ServerMessages`;"
    )
}


pub(crate) fn server_messages_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<server_messages::ServerMessages, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(server_messages::ServerMessagesRow {
            id: row.get::<_, i32>(0)?.into(),
            text_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(server_messages::ServerMessages { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SheatheSoundLookups() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SheatheSoundLookups (
        id INTEGER PRIMARY KEY NOT NULL,
        class_id INTEGER  NOT NULL,
        subclass_id INTEGER  NOT NULL,
        material INTEGER  NOT NULL,
        check_material INTEGER  NOT NULL,
        sheathe_sound INTEGER  NOT NULL,
        unsheathe_sound INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SheatheSoundLookups (
        id,
        class_id,
        subclass_id,
        material,
        check_material,
        sheathe_sound,
        unsheathe_sound
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        class_id,
        subclass_id,
        material,
        check_material,
        sheathe_sound,
        unsheathe_sound
    FROM `SheatheSoundLookups`;"
    )
}


pub(crate) fn sheathe_sound_lookups_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sheathe_sound_lookups::SheatheSoundLookups, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sheathe_sound_lookups::SheatheSoundLookupsRow {
            id: row.get::<_, i32>(0)?.into(),
            class_id: row.get::<_, i32>(1)?.into(),
            subclass_id: row.get::<_, i32>(2)?.into(),
            material: row.get::<_, i32>(3)?.into(),
            check_material: row.get::<_, i32>(4)?.into(),
            sheathe_sound: row.get::<_, i32>(5)?.into(),
            unsheathe_sound: row.get::<_, i32>(6)?.into(),
        });
    }
    Ok(sheathe_sound_lookups::SheatheSoundLookups { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillCostsData() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillCostsData (
        id INTEGER PRIMARY KEY NOT NULL,
        skill_costs_id INTEGER  NOT NULL,
        cost_0 INTEGER NOT NULL,
        cost_1 INTEGER NOT NULL,
        cost_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SkillCostsData (
        id,
        skill_costs_id,
        cost_0,
        cost_1,
        cost_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        skill_costs_id,
        cost_0,
        cost_1,
        cost_2
    FROM `SkillCostsData`;"
    )
}


pub(crate) fn skill_costs_data_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_costs_data::SkillCostsData, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_costs_data::SkillCostsDataRow {
            id: row.get::<_, i32>(0)?.into(),
            skill_costs_id: row.get::<_, i32>(1)?.into(),
            cost: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
        });
    }
    Ok(skill_costs_data::SkillCostsData { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillLine() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillLine (
        id INTEGER PRIMARY KEY NOT NULL,
        category_id INTEGER  NOT NULL,
        skill_costs_id INTEGER  NOT NULL,
        display_name_lang_en_gb TEXT NOT NULL,
        display_name_lang_ko_kr TEXT NOT NULL,
        display_name_lang_fr_fr TEXT NOT NULL,
        display_name_lang_de_de TEXT NOT NULL,
        display_name_lang_en_cn TEXT NOT NULL,
        display_name_lang_en_tw TEXT NOT NULL,
        display_name_lang_es_es TEXT NOT NULL,
        display_name_lang_es_mx TEXT NOT NULL,
        display_name_lang_ru_ru TEXT NOT NULL,
        display_name_lang_ja_jp TEXT NOT NULL,
        display_name_lang_pt_pt TEXT NOT NULL,
        display_name_lang_it_it TEXT NOT NULL,
        display_name_lang_unknown_12 TEXT NOT NULL,
        display_name_lang_unknown_13 TEXT NOT NULL,
        display_name_lang_unknown_14 TEXT NOT NULL,
        display_name_lang_unknown_15 TEXT NOT NULL,
        display_name_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        spell_icon_id INTEGER  NOT NULL,
        alternate_verb_lang_en_gb TEXT NOT NULL,
        alternate_verb_lang_ko_kr TEXT NOT NULL,
        alternate_verb_lang_fr_fr TEXT NOT NULL,
        alternate_verb_lang_de_de TEXT NOT NULL,
        alternate_verb_lang_en_cn TEXT NOT NULL,
        alternate_verb_lang_en_tw TEXT NOT NULL,
        alternate_verb_lang_es_es TEXT NOT NULL,
        alternate_verb_lang_es_mx TEXT NOT NULL,
        alternate_verb_lang_ru_ru TEXT NOT NULL,
        alternate_verb_lang_ja_jp TEXT NOT NULL,
        alternate_verb_lang_pt_pt TEXT NOT NULL,
        alternate_verb_lang_it_it TEXT NOT NULL,
        alternate_verb_lang_unknown_12 TEXT NOT NULL,
        alternate_verb_lang_unknown_13 TEXT NOT NULL,
        alternate_verb_lang_unknown_14 TEXT NOT NULL,
        alternate_verb_lang_unknown_15 TEXT NOT NULL,
        alternate_verb_lang_flags INTEGER NOT NULL,
        can_link INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SkillLine (
        id,
        category_id,
        skill_costs_id,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        spell_icon_id,
        alternate_verb_lang_en_gb,
        alternate_verb_lang_ko_kr,
        alternate_verb_lang_fr_fr,
        alternate_verb_lang_de_de,
        alternate_verb_lang_en_cn,
        alternate_verb_lang_en_tw,
        alternate_verb_lang_es_es,
        alternate_verb_lang_es_mx,
        alternate_verb_lang_ru_ru,
        alternate_verb_lang_ja_jp,
        alternate_verb_lang_pt_pt,
        alternate_verb_lang_it_it,
        alternate_verb_lang_unknown_12,
        alternate_verb_lang_unknown_13,
        alternate_verb_lang_unknown_14,
        alternate_verb_lang_unknown_15,
        alternate_verb_lang_flags,
        can_link
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56
    );"
    ,
    "SELECT
        id,
        category_id,
        skill_costs_id,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        spell_icon_id,
        alternate_verb_lang_en_gb,
        alternate_verb_lang_ko_kr,
        alternate_verb_lang_fr_fr,
        alternate_verb_lang_de_de,
        alternate_verb_lang_en_cn,
        alternate_verb_lang_en_tw,
        alternate_verb_lang_es_es,
        alternate_verb_lang_es_mx,
        alternate_verb_lang_ru_ru,
        alternate_verb_lang_ja_jp,
        alternate_verb_lang_pt_pt,
        alternate_verb_lang_it_it,
        alternate_verb_lang_unknown_12,
        alternate_verb_lang_unknown_13,
        alternate_verb_lang_unknown_14,
        alternate_verb_lang_unknown_15,
        alternate_verb_lang_flags,
        can_link
    FROM `SkillLine`;"
    )
}


pub(crate) fn skill_line_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_line::SkillLine, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_line::SkillLineRow {
            id: row.get::<_, i32>(0)?.into(),
            category_id: row.get::<_, i32>(1)?.into(),
            skill_costs_id: row.get::<_, i32>(2)?.into(),
            display_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(3)?.into(),
                ko_kr: row.get::<_, String>(4)?.into(),
                fr_fr: row.get::<_, String>(5)?.into(),
                de_de: row.get::<_, String>(6)?.into(),
                en_cn: row.get::<_, String>(7)?.into(),
                en_tw: row.get::<_, String>(8)?.into(),
                es_es: row.get::<_, String>(9)?.into(),
                es_mx: row.get::<_, String>(10)?.into(),
                ru_ru: row.get::<_, String>(11)?.into(),
                ja_jp: row.get::<_, String>(12)?.into(),
                pt_pt: row.get::<_, String>(13)?.into(),
                it_it: row.get::<_, String>(14)?.into(),
                unknown_12: row.get::<_, String>(15)?.into(),
                unknown_13: row.get::<_, String>(16)?.into(),
                unknown_14: row.get::<_, String>(17)?.into(),
                unknown_15: row.get::<_, String>(18)?.into(),
                flags: row.get::<_, u32>(19)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(20)?.into(),
                ko_kr: row.get::<_, String>(21)?.into(),
                fr_fr: row.get::<_, String>(22)?.into(),
                de_de: row.get::<_, String>(23)?.into(),
                en_cn: row.get::<_, String>(24)?.into(),
                en_tw: row.get::<_, String>(25)?.into(),
                es_es: row.get::<_, String>(26)?.into(),
                es_mx: row.get::<_, String>(27)?.into(),
                ru_ru: row.get::<_, String>(28)?.into(),
                ja_jp: row.get::<_, String>(29)?.into(),
                pt_pt: row.get::<_, String>(30)?.into(),
                it_it: row.get::<_, String>(31)?.into(),
                unknown_12: row.get::<_, String>(32)?.into(),
                unknown_13: row.get::<_, String>(33)?.into(),
                unknown_14: row.get::<_, String>(34)?.into(),
                unknown_15: row.get::<_, String>(35)?.into(),
                flags: row.get::<_, u32>(36)?.into(),
            },
            spell_icon_id: row.get::<_, i32>(37)?.into(),
            alternate_verb_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(38)?.into(),
                ko_kr: row.get::<_, String>(39)?.into(),
                fr_fr: row.get::<_, String>(40)?.into(),
                de_de: row.get::<_, String>(41)?.into(),
                en_cn: row.get::<_, String>(42)?.into(),
                en_tw: row.get::<_, String>(43)?.into(),
                es_es: row.get::<_, String>(44)?.into(),
                es_mx: row.get::<_, String>(45)?.into(),
                ru_ru: row.get::<_, String>(46)?.into(),
                ja_jp: row.get::<_, String>(47)?.into(),
                pt_pt: row.get::<_, String>(48)?.into(),
                it_it: row.get::<_, String>(49)?.into(),
                unknown_12: row.get::<_, String>(50)?.into(),
                unknown_13: row.get::<_, String>(51)?.into(),
                unknown_14: row.get::<_, String>(52)?.into(),
                unknown_15: row.get::<_, String>(53)?.into(),
                flags: row.get::<_, u32>(54)?.into(),
            },
            can_link: row.get::<_, i32>(55)?.into(),
        });
    }
    Ok(skill_line::SkillLine { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillLineAbility() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillLineAbility (
        id INTEGER PRIMARY KEY NOT NULL,
        skill_line INTEGER  NOT NULL,
        spell INTEGER  NOT NULL,
        race_mask INTEGER  NOT NULL,
        class_mask INTEGER  NOT NULL,
        exclude_race INTEGER  NOT NULL,
        exclude_class INTEGER  NOT NULL,
        min_skill_line_rank INTEGER  NOT NULL,
        superceded_by_spell INTEGER  NOT NULL,
        acquire_method INTEGER  NOT NULL,
        trivial_skill_line_rank_high INTEGER  NOT NULL,
        trivial_skill_line_rank_low INTEGER  NOT NULL,
        character_points_0 INTEGER NOT NULL,
        character_points_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SkillLineAbility (
        id,
        skill_line,
        spell,
        race_mask,
        class_mask,
        exclude_race,
        exclude_class,
        min_skill_line_rank,
        superceded_by_spell,
        acquire_method,
        trivial_skill_line_rank_high,
        trivial_skill_line_rank_low,
        character_points_0,
        character_points_1
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14
    );"
    ,
    "SELECT
        id,
        skill_line,
        spell,
        race_mask,
        class_mask,
        exclude_race,
        exclude_class,
        min_skill_line_rank,
        superceded_by_spell,
        acquire_method,
        trivial_skill_line_rank_high,
        trivial_skill_line_rank_low,
        character_points_0,
        character_points_1
    FROM `SkillLineAbility`;"
    )
}


pub(crate) fn skill_line_ability_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_line_ability::SkillLineAbility, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_line_ability::SkillLineAbilityRow {
            id: row.get::<_, i32>(0)?.into(),
            skill_line: row.get::<_, i32>(1)?.into(),
            spell: row.get::<_, i32>(2)?.into(),
            race_mask: row.get::<_, i32>(3)?.into(),
            class_mask: row.get::<_, i32>(4)?.into(),
            exclude_race: row.get::<_, i32>(5)?.into(),
            exclude_class: row.get::<_, i32>(6)?.into(),
            min_skill_line_rank: row.get::<_, i32>(7)?.into(),
            superceded_by_spell: row.get::<_, i32>(8)?.into(),
            acquire_method: row.get::<_, i32>(9)?.into(),
            trivial_skill_line_rank_high: row.get::<_, i32>(10)?.into(),
            trivial_skill_line_rank_low: row.get::<_, i32>(11)?.into(),
            character_points: [row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
        });
    }
    Ok(skill_line_ability::SkillLineAbility { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillLineCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillLineCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        sort_index INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SkillLineCategory (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        sort_index
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        sort_index
    FROM `SkillLineCategory`;"
    )
}


pub(crate) fn skill_line_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_line_category::SkillLineCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_line_category::SkillLineCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            sort_index: row.get::<_, i32>(18)?.into(),
        });
    }
    Ok(skill_line_category::SkillLineCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillRaceClassInfo() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillRaceClassInfo (
        id INTEGER PRIMARY KEY NOT NULL,
        skill_id INTEGER  NOT NULL,
        race_mask INTEGER  NOT NULL,
        class_mask INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        min_level INTEGER  NOT NULL,
        skill_tier_id INTEGER  NOT NULL,
        skill_cost_index INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SkillRaceClassInfo (
        id,
        skill_id,
        race_mask,
        class_mask,
        flags,
        min_level,
        skill_tier_id,
        skill_cost_index
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        skill_id,
        race_mask,
        class_mask,
        flags,
        min_level,
        skill_tier_id,
        skill_cost_index
    FROM `SkillRaceClassInfo`;"
    )
}


pub(crate) fn skill_race_class_info_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_race_class_info::SkillRaceClassInfo, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_race_class_info::SkillRaceClassInfoRow {
            id: row.get::<_, i32>(0)?.into(),
            skill_id: row.get::<_, i32>(1)?.into(),
            race_mask: row.get::<_, i32>(2)?.into(),
            class_mask: row.get::<_, i32>(3)?.into(),
            flags: row.get::<_, i32>(4)?.into(),
            min_level: row.get::<_, i32>(5)?.into(),
            skill_tier_id: row.get::<_, i32>(6)?.into(),
            skill_cost_index: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(skill_race_class_info::SkillRaceClassInfo { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SkillTiers() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SkillTiers (
        id INTEGER PRIMARY KEY NOT NULL,
        cost_0 INTEGER NOT NULL,
        cost_1 INTEGER NOT NULL,
        cost_2 INTEGER NOT NULL,
        cost_3 INTEGER NOT NULL,
        cost_4 INTEGER NOT NULL,
        cost_5 INTEGER NOT NULL,
        cost_6 INTEGER NOT NULL,
        cost_7 INTEGER NOT NULL,
        cost_8 INTEGER NOT NULL,
        cost_9 INTEGER NOT NULL,
        cost_10 INTEGER NOT NULL,
        cost_11 INTEGER NOT NULL,
        cost_12 INTEGER NOT NULL,
        cost_13 INTEGER NOT NULL,
        cost_14 INTEGER NOT NULL,
        cost_15 INTEGER NOT NULL,
        value_0 INTEGER NOT NULL,
        value_1 INTEGER NOT NULL,
        value_2 INTEGER NOT NULL,
        value_3 INTEGER NOT NULL,
        value_4 INTEGER NOT NULL,
        value_5 INTEGER NOT NULL,
        value_6 INTEGER NOT NULL,
        value_7 INTEGER NOT NULL,
        value_8 INTEGER NOT NULL,
        value_9 INTEGER NOT NULL,
        value_10 INTEGER NOT NULL,
        value_11 INTEGER NOT NULL,
        value_12 INTEGER NOT NULL,
        value_13 INTEGER NOT NULL,
        value_14 INTEGER NOT NULL,
        value_15 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SkillTiers (
        id,
        cost_0,
        cost_1,
        cost_2,
        cost_3,
        cost_4,
        cost_5,
        cost_6,
        cost_7,
        cost_8,
        cost_9,
        cost_10,
        cost_11,
        cost_12,
        cost_13,
        cost_14,
        cost_15,
        value_0,
        value_1,
        value_2,
        value_3,
        value_4,
        value_5,
        value_6,
        value_7,
        value_8,
        value_9,
        value_10,
        value_11,
        value_12,
        value_13,
        value_14,
        value_15
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33
    );"
    ,
    "SELECT
        id,
        cost_0,
        cost_1,
        cost_2,
        cost_3,
        cost_4,
        cost_5,
        cost_6,
        cost_7,
        cost_8,
        cost_9,
        cost_10,
        cost_11,
        cost_12,
        cost_13,
        cost_14,
        cost_15,
        value_0,
        value_1,
        value_2,
        value_3,
        value_4,
        value_5,
        value_6,
        value_7,
        value_8,
        value_9,
        value_10,
        value_11,
        value_12,
        value_13,
        value_14,
        value_15
    FROM `SkillTiers`;"
    )
}


pub(crate) fn skill_tiers_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<skill_tiers::SkillTiers, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(skill_tiers::SkillTiersRow {
            id: row.get::<_, i32>(0)?.into(),
            cost: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(),             ],
            value: [row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(), row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(),             ],
        });
    }
    Ok(skill_tiers::SkillTiers { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundAmbience() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundAmbience (
        id INTEGER PRIMARY KEY NOT NULL,
        ambience_id_0 INTEGER NOT NULL,
        ambience_id_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SoundAmbience (
        id,
        ambience_id_0,
        ambience_id_1
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        ambience_id_0,
        ambience_id_1
    FROM `SoundAmbience`;"
    )
}


pub(crate) fn sound_ambience_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_ambience::SoundAmbience, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_ambience::SoundAmbienceRow {
            id: row.get::<_, i32>(0)?.into(),
            ambience_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(),             ],
        });
    }
    Ok(sound_ambience::SoundAmbience { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundEmitters() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundEmitters (
        id INTEGER PRIMARY KEY NOT NULL,
        position_0 REAL NOT NULL,
        position_1 REAL NOT NULL,
        position_2 REAL NOT NULL,
        direction_0 REAL NOT NULL,
        direction_1 REAL NOT NULL,
        direction_2 REAL NOT NULL,
        sound_entry_advanced_id INTEGER  NOT NULL,
        map_id INTEGER  NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SoundEmitters (
        id,
        position_0,
        position_1,
        position_2,
        direction_0,
        direction_1,
        direction_2,
        sound_entry_advanced_id,
        map_id,
        name
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        position_0,
        position_1,
        position_2,
        direction_0,
        direction_1,
        direction_2,
        sound_entry_advanced_id,
        map_id,
        name
    FROM `SoundEmitters`;"
    )
}


pub(crate) fn sound_emitters_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_emitters::SoundEmitters, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_emitters::SoundEmittersRow {
            id: row.get::<_, i32>(0)?.into(),
            position: [row.get::<_, f32>(1)?.into(), row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(),             ],
            direction: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(),             ],
            sound_entry_advanced_id: row.get::<_, i32>(7)?.into(),
            map_id: row.get::<_, i32>(8)?.into(),
            name: row.get::<_, String>(9)?.into(),
        });
    }
    Ok(sound_emitters::SoundEmitters { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundEntries() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundEntries (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_type INTEGER  NOT NULL,
        name TEXT  NOT NULL,
        file_0 TEXT NOT NULL,
        file_1 TEXT NOT NULL,
        file_2 TEXT NOT NULL,
        file_3 TEXT NOT NULL,
        file_4 TEXT NOT NULL,
        file_5 TEXT NOT NULL,
        file_6 TEXT NOT NULL,
        file_7 TEXT NOT NULL,
        file_8 TEXT NOT NULL,
        file_9 TEXT NOT NULL,
        freq_0 INTEGER NOT NULL,
        freq_1 INTEGER NOT NULL,
        freq_2 INTEGER NOT NULL,
        freq_3 INTEGER NOT NULL,
        freq_4 INTEGER NOT NULL,
        freq_5 INTEGER NOT NULL,
        freq_6 INTEGER NOT NULL,
        freq_7 INTEGER NOT NULL,
        freq_8 INTEGER NOT NULL,
        freq_9 INTEGER NOT NULL,
        directory_base TEXT  NOT NULL,
        volume_float REAL  NOT NULL,
        flags INTEGER  NOT NULL,
        min_distance REAL  NOT NULL,
        distance_cutoff REAL  NOT NULL,
        e_a_x_def INTEGER  NOT NULL,
        sound_entries_advanced_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SoundEntries (
        id,
        sound_type,
        name,
        file_0,
        file_1,
        file_2,
        file_3,
        file_4,
        file_5,
        file_6,
        file_7,
        file_8,
        file_9,
        freq_0,
        freq_1,
        freq_2,
        freq_3,
        freq_4,
        freq_5,
        freq_6,
        freq_7,
        freq_8,
        freq_9,
        directory_base,
        volume_float,
        flags,
        min_distance,
        distance_cutoff,
        e_a_x_def,
        sound_entries_advanced_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30
    );"
    ,
    "SELECT
        id,
        sound_type,
        name,
        file_0,
        file_1,
        file_2,
        file_3,
        file_4,
        file_5,
        file_6,
        file_7,
        file_8,
        file_9,
        freq_0,
        freq_1,
        freq_2,
        freq_3,
        freq_4,
        freq_5,
        freq_6,
        freq_7,
        freq_8,
        freq_9,
        directory_base,
        volume_float,
        flags,
        min_distance,
        distance_cutoff,
        e_a_x_def,
        sound_entries_advanced_id
    FROM `SoundEntries`;"
    )
}


pub(crate) fn sound_entries_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_entries::SoundEntries, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_entries::SoundEntriesRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_type: row.get::<_, i32>(1)?.into(),
            name: row.get::<_, String>(2)?.into(),
            file: [row.get::<_, String>(3)?.into(), row.get::<_, String>(4)?.into(), row.get::<_, String>(5)?.into(), row.get::<_, String>(6)?.into(), row.get::<_, String>(7)?.into(), row.get::<_, String>(8)?.into(), row.get::<_, String>(9)?.into(), row.get::<_, String>(10)?.into(), row.get::<_, String>(11)?.into(), row.get::<_, String>(12)?.into(),             ],
            freq: [row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
            directory_base: row.get::<_, String>(23)?.into(),
            volume_float: row.get::<_, f32>(24)?.into(),
            flags: row.get::<_, i32>(25)?.into(),
            min_distance: row.get::<_, f32>(26)?.into(),
            distance_cutoff: row.get::<_, f32>(27)?.into(),
            e_a_x_def: row.get::<_, i32>(28)?.into(),
            sound_entries_advanced_id: row.get::<_, i32>(29)?.into(),
        });
    }
    Ok(sound_entries::SoundEntries { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundEntriesAdvanced() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundEntriesAdvanced (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_entry_id INTEGER  NOT NULL,
        inner_radius2_d REAL  NOT NULL,
        time_a INTEGER  NOT NULL,
        time_b INTEGER  NOT NULL,
        time_c INTEGER  NOT NULL,
        time_d INTEGER  NOT NULL,
        random_offset_range INTEGER  NOT NULL,
        usage INTEGER  NOT NULL,
        time_interval_min INTEGER  NOT NULL,
        time_interval_max INTEGER  NOT NULL,
        volume_slider_category INTEGER  NOT NULL,
        duck_to_s_f_x REAL  NOT NULL,
        duck_to_music REAL  NOT NULL,
        duck_to_ambience REAL  NOT NULL,
        inner_radius_of_influence REAL  NOT NULL,
        outer_radius_of_influence REAL  NOT NULL,
        time_to_duck INTEGER  NOT NULL,
        time_to_unduck INTEGER  NOT NULL,
        inside_angle REAL  NOT NULL,
        outside_angle REAL  NOT NULL,
        outside_volume REAL  NOT NULL,
        outer_radius2_d REAL  NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SoundEntriesAdvanced (
        id,
        sound_entry_id,
        inner_radius2_d,
        time_a,
        time_b,
        time_c,
        time_d,
        random_offset_range,
        usage,
        time_interval_min,
        time_interval_max,
        volume_slider_category,
        duck_to_s_f_x,
        duck_to_music,
        duck_to_ambience,
        inner_radius_of_influence,
        outer_radius_of_influence,
        time_to_duck,
        time_to_unduck,
        inside_angle,
        outside_angle,
        outside_volume,
        outer_radius2_d,
        name
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        sound_entry_id,
        inner_radius2_d,
        time_a,
        time_b,
        time_c,
        time_d,
        random_offset_range,
        usage,
        time_interval_min,
        time_interval_max,
        volume_slider_category,
        duck_to_s_f_x,
        duck_to_music,
        duck_to_ambience,
        inner_radius_of_influence,
        outer_radius_of_influence,
        time_to_duck,
        time_to_unduck,
        inside_angle,
        outside_angle,
        outside_volume,
        outer_radius2_d,
        name
    FROM `SoundEntriesAdvanced`;"
    )
}


pub(crate) fn sound_entries_advanced_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_entries_advanced::SoundEntriesAdvanced, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_entries_advanced::SoundEntriesAdvancedRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_entry_id: row.get::<_, i32>(1)?.into(),
            inner_radius2_d: row.get::<_, f32>(2)?.into(),
            time_a: row.get::<_, i32>(3)?.into(),
            time_b: row.get::<_, i32>(4)?.into(),
            time_c: row.get::<_, i32>(5)?.into(),
            time_d: row.get::<_, i32>(6)?.into(),
            random_offset_range: row.get::<_, i32>(7)?.into(),
            usage: row.get::<_, i32>(8)?.into(),
            time_interval_min: row.get::<_, i32>(9)?.into(),
            time_interval_max: row.get::<_, i32>(10)?.into(),
            volume_slider_category: row.get::<_, i32>(11)?.into(),
            duck_to_s_f_x: row.get::<_, f32>(12)?.into(),
            duck_to_music: row.get::<_, f32>(13)?.into(),
            duck_to_ambience: row.get::<_, f32>(14)?.into(),
            inner_radius_of_influence: row.get::<_, f32>(15)?.into(),
            outer_radius_of_influence: row.get::<_, f32>(16)?.into(),
            time_to_duck: row.get::<_, i32>(17)?.into(),
            time_to_unduck: row.get::<_, i32>(18)?.into(),
            inside_angle: row.get::<_, f32>(19)?.into(),
            outside_angle: row.get::<_, f32>(20)?.into(),
            outside_volume: row.get::<_, f32>(21)?.into(),
            outer_radius2_d: row.get::<_, f32>(22)?.into(),
            name: row.get::<_, String>(23)?.into(),
        });
    }
    Ok(sound_entries_advanced::SoundEntriesAdvanced { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundFilter() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundFilter (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SoundFilter (
        id,
        name
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        name
    FROM `SoundFilter`;"
    )
}


pub(crate) fn sound_filter_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_filter::SoundFilter, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_filter::SoundFilterRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(sound_filter::SoundFilter { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundFilterElem() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundFilterElem (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_filter_id INTEGER  NOT NULL,
        order_index INTEGER  NOT NULL,
        filter_type INTEGER  NOT NULL,
        params_0 REAL NOT NULL,
        params_1 REAL NOT NULL,
        params_2 REAL NOT NULL,
        params_3 REAL NOT NULL,
        params_4 REAL NOT NULL,
        params_5 REAL NOT NULL,
        params_6 REAL NOT NULL,
        params_7 REAL NOT NULL,
        params_8 REAL NOT NULL
    );"
    ,
    "INSERT INTO SoundFilterElem (
        id,
        sound_filter_id,
        order_index,
        filter_type,
        params_0,
        params_1,
        params_2,
        params_3,
        params_4,
        params_5,
        params_6,
        params_7,
        params_8
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13
    );"
    ,
    "SELECT
        id,
        sound_filter_id,
        order_index,
        filter_type,
        params_0,
        params_1,
        params_2,
        params_3,
        params_4,
        params_5,
        params_6,
        params_7,
        params_8
    FROM `SoundFilterElem`;"
    )
}


pub(crate) fn sound_filter_elem_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_filter_elem::SoundFilterElem, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_filter_elem::SoundFilterElemRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_filter_id: row.get::<_, i32>(1)?.into(),
            order_index: row.get::<_, i32>(2)?.into(),
            filter_type: row.get::<_, i32>(3)?.into(),
            params: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(), row.get::<_, f32>(7)?.into(), row.get::<_, f32>(8)?.into(), row.get::<_, f32>(9)?.into(), row.get::<_, f32>(10)?.into(), row.get::<_, f32>(11)?.into(), row.get::<_, f32>(12)?.into(),             ],
        });
    }
    Ok(sound_filter_elem::SoundFilterElem { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundProviderPreferences() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundProviderPreferences (
        id INTEGER PRIMARY KEY NOT NULL,
        description TEXT  NOT NULL,
        flags INTEGER  NOT NULL,
        e_a_x_environment_selection INTEGER  NOT NULL,
        e_a_x_decay_time REAL  NOT NULL,
        e_a_x2_environment_size REAL  NOT NULL,
        e_a_x2_environment_diffusion REAL  NOT NULL,
        e_a_x2_room INTEGER  NOT NULL,
        e_a_x2_room_h_f INTEGER  NOT NULL,
        e_a_x2_decay_h_f_ratio REAL  NOT NULL,
        e_a_x2_reflections INTEGER  NOT NULL,
        e_a_x2_reflections_delay REAL  NOT NULL,
        e_a_x2_reverb INTEGER  NOT NULL,
        e_a_x2_reverb_delay REAL  NOT NULL,
        e_a_x2_room_rolloff REAL  NOT NULL,
        e_a_x2_air_absorption REAL  NOT NULL,
        e_a_x3_room_l_f INTEGER  NOT NULL,
        e_a_x3_decay_l_f_ratio REAL  NOT NULL,
        e_a_x3_echo_time REAL  NOT NULL,
        e_a_x3_echo_depth REAL  NOT NULL,
        e_a_x3_modulation_time REAL  NOT NULL,
        e_a_x3_modulation_depth REAL  NOT NULL,
        e_a_x3_h_f_reference REAL  NOT NULL,
        e_a_x3_l_f_reference REAL  NOT NULL
    );"
    ,
    "INSERT INTO SoundProviderPreferences (
        id,
        description,
        flags,
        e_a_x_environment_selection,
        e_a_x_decay_time,
        e_a_x2_environment_size,
        e_a_x2_environment_diffusion,
        e_a_x2_room,
        e_a_x2_room_h_f,
        e_a_x2_decay_h_f_ratio,
        e_a_x2_reflections,
        e_a_x2_reflections_delay,
        e_a_x2_reverb,
        e_a_x2_reverb_delay,
        e_a_x2_room_rolloff,
        e_a_x2_air_absorption,
        e_a_x3_room_l_f,
        e_a_x3_decay_l_f_ratio,
        e_a_x3_echo_time,
        e_a_x3_echo_depth,
        e_a_x3_modulation_time,
        e_a_x3_modulation_depth,
        e_a_x3_h_f_reference,
        e_a_x3_l_f_reference
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        description,
        flags,
        e_a_x_environment_selection,
        e_a_x_decay_time,
        e_a_x2_environment_size,
        e_a_x2_environment_diffusion,
        e_a_x2_room,
        e_a_x2_room_h_f,
        e_a_x2_decay_h_f_ratio,
        e_a_x2_reflections,
        e_a_x2_reflections_delay,
        e_a_x2_reverb,
        e_a_x2_reverb_delay,
        e_a_x2_room_rolloff,
        e_a_x2_air_absorption,
        e_a_x3_room_l_f,
        e_a_x3_decay_l_f_ratio,
        e_a_x3_echo_time,
        e_a_x3_echo_depth,
        e_a_x3_modulation_time,
        e_a_x3_modulation_depth,
        e_a_x3_h_f_reference,
        e_a_x3_l_f_reference
    FROM `SoundProviderPreferences`;"
    )
}


pub(crate) fn sound_provider_preferences_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_provider_preferences::SoundProviderPreferences, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_provider_preferences::SoundProviderPreferencesRow {
            id: row.get::<_, i32>(0)?.into(),
            description: row.get::<_, String>(1)?.into(),
            flags: row.get::<_, i32>(2)?.into(),
            e_a_x_environment_selection: row.get::<_, i32>(3)?.into(),
            e_a_x_decay_time: row.get::<_, f32>(4)?.into(),
            e_a_x2_environment_size: row.get::<_, f32>(5)?.into(),
            e_a_x2_environment_diffusion: row.get::<_, f32>(6)?.into(),
            e_a_x2_room: row.get::<_, i32>(7)?.into(),
            e_a_x2_room_h_f: row.get::<_, i32>(8)?.into(),
            e_a_x2_decay_h_f_ratio: row.get::<_, f32>(9)?.into(),
            e_a_x2_reflections: row.get::<_, i32>(10)?.into(),
            e_a_x2_reflections_delay: row.get::<_, f32>(11)?.into(),
            e_a_x2_reverb: row.get::<_, i32>(12)?.into(),
            e_a_x2_reverb_delay: row.get::<_, f32>(13)?.into(),
            e_a_x2_room_rolloff: row.get::<_, f32>(14)?.into(),
            e_a_x2_air_absorption: row.get::<_, f32>(15)?.into(),
            e_a_x3_room_l_f: row.get::<_, i32>(16)?.into(),
            e_a_x3_decay_l_f_ratio: row.get::<_, f32>(17)?.into(),
            e_a_x3_echo_time: row.get::<_, f32>(18)?.into(),
            e_a_x3_echo_depth: row.get::<_, f32>(19)?.into(),
            e_a_x3_modulation_time: row.get::<_, f32>(20)?.into(),
            e_a_x3_modulation_depth: row.get::<_, f32>(21)?.into(),
            e_a_x3_h_f_reference: row.get::<_, f32>(22)?.into(),
            e_a_x3_l_f_reference: row.get::<_, f32>(23)?.into(),
        });
    }
    Ok(sound_provider_preferences::SoundProviderPreferences { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundSamplePreferences() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundSamplePreferences (
        id INTEGER PRIMARY KEY NOT NULL,
        field_0_6_0_3592_001 INTEGER  NOT NULL,
        field_0_6_0_3592_002 INTEGER  NOT NULL,
        e_a_x2_sample_room INTEGER  NOT NULL,
        field_0_6_0_3592_004 INTEGER  NOT NULL,
        field_0_6_0_3592_005 INTEGER  NOT NULL,
        field_0_6_0_3592_006 REAL  NOT NULL,
        field_0_6_0_3592_007 INTEGER  NOT NULL,
        e_a_x2_sample_occlusion_l_f_ratio REAL  NOT NULL,
        e_a_x2_sample_occlusion_room_ratio REAL  NOT NULL,
        field_0_6_0_3592_010 INTEGER  NOT NULL,
        e_a_x1_effect_level REAL  NOT NULL,
        field_0_6_0_3592_012 INTEGER  NOT NULL,
        field_0_6_0_3592_013 REAL  NOT NULL,
        e_a_x3_sample_exclusion REAL  NOT NULL,
        field_0_6_0_3592_015 REAL  NOT NULL,
        field_0_6_0_3592_016 INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SoundSamplePreferences (
        id,
        field_0_6_0_3592_001,
        field_0_6_0_3592_002,
        e_a_x2_sample_room,
        field_0_6_0_3592_004,
        field_0_6_0_3592_005,
        field_0_6_0_3592_006,
        field_0_6_0_3592_007,
        e_a_x2_sample_occlusion_l_f_ratio,
        e_a_x2_sample_occlusion_room_ratio,
        field_0_6_0_3592_010,
        e_a_x1_effect_level,
        field_0_6_0_3592_012,
        field_0_6_0_3592_013,
        e_a_x3_sample_exclusion,
        field_0_6_0_3592_015,
        field_0_6_0_3592_016
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17
    );"
    ,
    "SELECT
        id,
        field_0_6_0_3592_001,
        field_0_6_0_3592_002,
        e_a_x2_sample_room,
        field_0_6_0_3592_004,
        field_0_6_0_3592_005,
        field_0_6_0_3592_006,
        field_0_6_0_3592_007,
        e_a_x2_sample_occlusion_l_f_ratio,
        e_a_x2_sample_occlusion_room_ratio,
        field_0_6_0_3592_010,
        e_a_x1_effect_level,
        field_0_6_0_3592_012,
        field_0_6_0_3592_013,
        e_a_x3_sample_exclusion,
        field_0_6_0_3592_015,
        field_0_6_0_3592_016
    FROM `SoundSamplePreferences`;"
    )
}


pub(crate) fn sound_sample_preferences_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_sample_preferences::SoundSamplePreferences, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_sample_preferences::SoundSamplePreferencesRow {
            id: row.get::<_, i32>(0)?.into(),
            field_0_6_0_3592_001: row.get::<_, i32>(1)?.into(),
            field_0_6_0_3592_002: row.get::<_, i32>(2)?.into(),
            e_a_x2_sample_room: row.get::<_, i32>(3)?.into(),
            field_0_6_0_3592_004: row.get::<_, i32>(4)?.into(),
            field_0_6_0_3592_005: row.get::<_, i32>(5)?.into(),
            field_0_6_0_3592_006: row.get::<_, f32>(6)?.into(),
            field_0_6_0_3592_007: row.get::<_, i32>(7)?.into(),
            e_a_x2_sample_occlusion_l_f_ratio: row.get::<_, f32>(8)?.into(),
            e_a_x2_sample_occlusion_room_ratio: row.get::<_, f32>(9)?.into(),
            field_0_6_0_3592_010: row.get::<_, i32>(10)?.into(),
            e_a_x1_effect_level: row.get::<_, f32>(11)?.into(),
            field_0_6_0_3592_012: row.get::<_, i32>(12)?.into(),
            field_0_6_0_3592_013: row.get::<_, f32>(13)?.into(),
            e_a_x3_sample_exclusion: row.get::<_, f32>(14)?.into(),
            field_0_6_0_3592_015: row.get::<_, f32>(15)?.into(),
            field_0_6_0_3592_016: row.get::<_, i32>(16)?.into(),
        });
    }
    Ok(sound_sample_preferences::SoundSamplePreferences { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SoundWaterType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SoundWaterType (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_type INTEGER  NOT NULL,
        sound_subtype INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SoundWaterType (
        id,
        sound_type,
        sound_subtype,
        sound_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        sound_type,
        sound_subtype,
        sound_id
    FROM `SoundWaterType`;"
    )
}


pub(crate) fn sound_water_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<sound_water_type::SoundWaterType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(sound_water_type::SoundWaterTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_type: row.get::<_, i32>(1)?.into(),
            sound_subtype: row.get::<_, i32>(2)?.into(),
            sound_id: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(sound_water_type::SoundWaterType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpamMessages() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpamMessages (
        id INTEGER PRIMARY KEY NOT NULL,
        text TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SpamMessages (
        id,
        text
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        text
    FROM `SpamMessages`;"
    )
}


pub(crate) fn spam_messages_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spam_messages::SpamMessages, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spam_messages::SpamMessagesRow {
            id: row.get::<_, i32>(0)?.into(),
            text: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(spam_messages::SpamMessages { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Spell() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Spell (
        id INTEGER PRIMARY KEY NOT NULL,
        category INTEGER  NOT NULL,
        dispel_type INTEGER  NOT NULL,
        mechanic INTEGER  NOT NULL,
        attributes INTEGER  NOT NULL,
        attributes_ex INTEGER  NOT NULL,
        attributes_ex_b INTEGER  NOT NULL,
        attributes_ex_c INTEGER  NOT NULL,
        attributes_ex_d INTEGER  NOT NULL,
        attributes_ex_e INTEGER  NOT NULL,
        attributes_ex_f INTEGER  NOT NULL,
        attributes_ex_g INTEGER  NOT NULL,
        shapeshift_mask_0 INTEGER NOT NULL,
        shapeshift_mask_1 INTEGER NOT NULL,
        shapeshift_exclude_0 INTEGER NOT NULL,
        shapeshift_exclude_1 INTEGER NOT NULL,
        targets INTEGER  NOT NULL,
        target_creature_type INTEGER  NOT NULL,
        requires_spell_focus INTEGER  NOT NULL,
        facing_caster_flags INTEGER  NOT NULL,
        caster_aura_state INTEGER  NOT NULL,
        target_aura_state INTEGER  NOT NULL,
        exclude_caster_aura_state INTEGER  NOT NULL,
        exclude_target_aura_state INTEGER  NOT NULL,
        caster_aura_spell INTEGER  NOT NULL,
        target_aura_spell INTEGER  NOT NULL,
        exclude_caster_aura_spell INTEGER  NOT NULL,
        exclude_target_aura_spell INTEGER  NOT NULL,
        casting_time_index INTEGER  NOT NULL,
        recovery_time INTEGER  NOT NULL,
        category_recovery_time INTEGER  NOT NULL,
        interrupt_flags INTEGER  NOT NULL,
        aura_interrupt_flags INTEGER  NOT NULL,
        channel_interrupt_flags INTEGER  NOT NULL,
        proc_type_mask INTEGER  NOT NULL,
        proc_chance INTEGER  NOT NULL,
        proc_charges INTEGER  NOT NULL,
        max_level INTEGER  NOT NULL,
        base_level INTEGER  NOT NULL,
        spell_level INTEGER  NOT NULL,
        duration_index INTEGER  NOT NULL,
        power_type INTEGER  NOT NULL,
        mana_cost INTEGER  NOT NULL,
        mana_cost_per_level INTEGER  NOT NULL,
        mana_per_second INTEGER  NOT NULL,
        mana_per_second_per_level INTEGER  NOT NULL,
        range_index INTEGER  NOT NULL,
        speed REAL  NOT NULL,
        modal_next_spell INTEGER  NOT NULL,
        cumulative_aura INTEGER  NOT NULL,
        totem_0 INTEGER NOT NULL,
        totem_1 INTEGER NOT NULL,
        reagent_0 INTEGER NOT NULL,
        reagent_1 INTEGER NOT NULL,
        reagent_2 INTEGER NOT NULL,
        reagent_3 INTEGER NOT NULL,
        reagent_4 INTEGER NOT NULL,
        reagent_5 INTEGER NOT NULL,
        reagent_6 INTEGER NOT NULL,
        reagent_7 INTEGER NOT NULL,
        reagent_count_0 INTEGER NOT NULL,
        reagent_count_1 INTEGER NOT NULL,
        reagent_count_2 INTEGER NOT NULL,
        reagent_count_3 INTEGER NOT NULL,
        reagent_count_4 INTEGER NOT NULL,
        reagent_count_5 INTEGER NOT NULL,
        reagent_count_6 INTEGER NOT NULL,
        reagent_count_7 INTEGER NOT NULL,
        equipped_item_class INTEGER  NOT NULL,
        equipped_item_subclass INTEGER  NOT NULL,
        equipped_item_inv_types INTEGER  NOT NULL,
        effect_0 INTEGER NOT NULL,
        effect_1 INTEGER NOT NULL,
        effect_2 INTEGER NOT NULL,
        effect_die_sides_0 INTEGER NOT NULL,
        effect_die_sides_1 INTEGER NOT NULL,
        effect_die_sides_2 INTEGER NOT NULL,
        effect_real_points_per_level_0 REAL NOT NULL,
        effect_real_points_per_level_1 REAL NOT NULL,
        effect_real_points_per_level_2 REAL NOT NULL,
        effect_base_points_0 INTEGER NOT NULL,
        effect_base_points_1 INTEGER NOT NULL,
        effect_base_points_2 INTEGER NOT NULL,
        effect_mechanic_0 INTEGER NOT NULL,
        effect_mechanic_1 INTEGER NOT NULL,
        effect_mechanic_2 INTEGER NOT NULL,
        implicit_target_a_0 INTEGER NOT NULL,
        implicit_target_a_1 INTEGER NOT NULL,
        implicit_target_a_2 INTEGER NOT NULL,
        implicit_target_b_0 INTEGER NOT NULL,
        implicit_target_b_1 INTEGER NOT NULL,
        implicit_target_b_2 INTEGER NOT NULL,
        effect_radius_index_0 INTEGER NOT NULL,
        effect_radius_index_1 INTEGER NOT NULL,
        effect_radius_index_2 INTEGER NOT NULL,
        effect_aura_0 INTEGER NOT NULL,
        effect_aura_1 INTEGER NOT NULL,
        effect_aura_2 INTEGER NOT NULL,
        effect_aura_period_0 INTEGER NOT NULL,
        effect_aura_period_1 INTEGER NOT NULL,
        effect_aura_period_2 INTEGER NOT NULL,
        effect_amplitude_0 REAL NOT NULL,
        effect_amplitude_1 REAL NOT NULL,
        effect_amplitude_2 REAL NOT NULL,
        effect_chain_targets_0 INTEGER NOT NULL,
        effect_chain_targets_1 INTEGER NOT NULL,
        effect_chain_targets_2 INTEGER NOT NULL,
        effect_item_type_0 INTEGER NOT NULL,
        effect_item_type_1 INTEGER NOT NULL,
        effect_item_type_2 INTEGER NOT NULL,
        effect_misc_value_0 INTEGER NOT NULL,
        effect_misc_value_1 INTEGER NOT NULL,
        effect_misc_value_2 INTEGER NOT NULL,
        effect_misc_value_b_0 INTEGER NOT NULL,
        effect_misc_value_b_1 INTEGER NOT NULL,
        effect_misc_value_b_2 INTEGER NOT NULL,
        effect_trigger_spell_0 INTEGER NOT NULL,
        effect_trigger_spell_1 INTEGER NOT NULL,
        effect_trigger_spell_2 INTEGER NOT NULL,
        effect_points_per_combo_0 REAL NOT NULL,
        effect_points_per_combo_1 REAL NOT NULL,
        effect_points_per_combo_2 REAL NOT NULL,
        effect_spell_class_mask_a_0 INTEGER NOT NULL,
        effect_spell_class_mask_a_1 INTEGER NOT NULL,
        effect_spell_class_mask_a_2 INTEGER NOT NULL,
        effect_spell_class_mask_b_0 INTEGER NOT NULL,
        effect_spell_class_mask_b_1 INTEGER NOT NULL,
        effect_spell_class_mask_b_2 INTEGER NOT NULL,
        effect_spell_class_mask_c_0 INTEGER NOT NULL,
        effect_spell_class_mask_c_1 INTEGER NOT NULL,
        effect_spell_class_mask_c_2 INTEGER NOT NULL,
        spell_visual_id_0 INTEGER NOT NULL,
        spell_visual_id_1 INTEGER NOT NULL,
        spell_icon_id INTEGER  NOT NULL,
        active_icon_id INTEGER  NOT NULL,
        spell_priority INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        name_subtext_lang_en_gb TEXT NOT NULL,
        name_subtext_lang_ko_kr TEXT NOT NULL,
        name_subtext_lang_fr_fr TEXT NOT NULL,
        name_subtext_lang_de_de TEXT NOT NULL,
        name_subtext_lang_en_cn TEXT NOT NULL,
        name_subtext_lang_en_tw TEXT NOT NULL,
        name_subtext_lang_es_es TEXT NOT NULL,
        name_subtext_lang_es_mx TEXT NOT NULL,
        name_subtext_lang_ru_ru TEXT NOT NULL,
        name_subtext_lang_ja_jp TEXT NOT NULL,
        name_subtext_lang_pt_pt TEXT NOT NULL,
        name_subtext_lang_it_it TEXT NOT NULL,
        name_subtext_lang_unknown_12 TEXT NOT NULL,
        name_subtext_lang_unknown_13 TEXT NOT NULL,
        name_subtext_lang_unknown_14 TEXT NOT NULL,
        name_subtext_lang_unknown_15 TEXT NOT NULL,
        name_subtext_lang_flags INTEGER NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL,
        aura_description_lang_en_gb TEXT NOT NULL,
        aura_description_lang_ko_kr TEXT NOT NULL,
        aura_description_lang_fr_fr TEXT NOT NULL,
        aura_description_lang_de_de TEXT NOT NULL,
        aura_description_lang_en_cn TEXT NOT NULL,
        aura_description_lang_en_tw TEXT NOT NULL,
        aura_description_lang_es_es TEXT NOT NULL,
        aura_description_lang_es_mx TEXT NOT NULL,
        aura_description_lang_ru_ru TEXT NOT NULL,
        aura_description_lang_ja_jp TEXT NOT NULL,
        aura_description_lang_pt_pt TEXT NOT NULL,
        aura_description_lang_it_it TEXT NOT NULL,
        aura_description_lang_unknown_12 TEXT NOT NULL,
        aura_description_lang_unknown_13 TEXT NOT NULL,
        aura_description_lang_unknown_14 TEXT NOT NULL,
        aura_description_lang_unknown_15 TEXT NOT NULL,
        aura_description_lang_flags INTEGER NOT NULL,
        mana_cost_pct INTEGER  NOT NULL,
        start_recovery_category INTEGER  NOT NULL,
        start_recovery_time INTEGER  NOT NULL,
        max_target_level INTEGER  NOT NULL,
        spell_class_set INTEGER  NOT NULL,
        spell_class_mask_0 INTEGER NOT NULL,
        spell_class_mask_1 INTEGER NOT NULL,
        spell_class_mask_2 INTEGER NOT NULL,
        max_targets INTEGER  NOT NULL,
        defense_type INTEGER  NOT NULL,
        prevention_type INTEGER  NOT NULL,
        stance_bar_order INTEGER  NOT NULL,
        effect_chain_amplitude_0 REAL NOT NULL,
        effect_chain_amplitude_1 REAL NOT NULL,
        effect_chain_amplitude_2 REAL NOT NULL,
        min_faction_id INTEGER  NOT NULL,
        min_reputation INTEGER  NOT NULL,
        required_aura_vision INTEGER  NOT NULL,
        required_totem_category_id_0 INTEGER NOT NULL,
        required_totem_category_id_1 INTEGER NOT NULL,
        required_areas_id INTEGER  NOT NULL,
        school_mask INTEGER  NOT NULL,
        rune_cost_id INTEGER  NOT NULL,
        spell_missile_id INTEGER  NOT NULL,
        power_display_id INTEGER  NOT NULL,
        effect_bonus_coefficient_0 REAL NOT NULL,
        effect_bonus_coefficient_1 REAL NOT NULL,
        effect_bonus_coefficient_2 REAL NOT NULL,
        description_variables_id INTEGER  NOT NULL,
        difficulty INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Spell (
        id,
        category,
        dispel_type,
        mechanic,
        attributes,
        attributes_ex,
        attributes_ex_b,
        attributes_ex_c,
        attributes_ex_d,
        attributes_ex_e,
        attributes_ex_f,
        attributes_ex_g,
        shapeshift_mask_0,
        shapeshift_mask_1,
        shapeshift_exclude_0,
        shapeshift_exclude_1,
        targets,
        target_creature_type,
        requires_spell_focus,
        facing_caster_flags,
        caster_aura_state,
        target_aura_state,
        exclude_caster_aura_state,
        exclude_target_aura_state,
        caster_aura_spell,
        target_aura_spell,
        exclude_caster_aura_spell,
        exclude_target_aura_spell,
        casting_time_index,
        recovery_time,
        category_recovery_time,
        interrupt_flags,
        aura_interrupt_flags,
        channel_interrupt_flags,
        proc_type_mask,
        proc_chance,
        proc_charges,
        max_level,
        base_level,
        spell_level,
        duration_index,
        power_type,
        mana_cost,
        mana_cost_per_level,
        mana_per_second,
        mana_per_second_per_level,
        range_index,
        speed,
        modal_next_spell,
        cumulative_aura,
        totem_0,
        totem_1,
        reagent_0,
        reagent_1,
        reagent_2,
        reagent_3,
        reagent_4,
        reagent_5,
        reagent_6,
        reagent_7,
        reagent_count_0,
        reagent_count_1,
        reagent_count_2,
        reagent_count_3,
        reagent_count_4,
        reagent_count_5,
        reagent_count_6,
        reagent_count_7,
        equipped_item_class,
        equipped_item_subclass,
        equipped_item_inv_types,
        effect_0,
        effect_1,
        effect_2,
        effect_die_sides_0,
        effect_die_sides_1,
        effect_die_sides_2,
        effect_real_points_per_level_0,
        effect_real_points_per_level_1,
        effect_real_points_per_level_2,
        effect_base_points_0,
        effect_base_points_1,
        effect_base_points_2,
        effect_mechanic_0,
        effect_mechanic_1,
        effect_mechanic_2,
        implicit_target_a_0,
        implicit_target_a_1,
        implicit_target_a_2,
        implicit_target_b_0,
        implicit_target_b_1,
        implicit_target_b_2,
        effect_radius_index_0,
        effect_radius_index_1,
        effect_radius_index_2,
        effect_aura_0,
        effect_aura_1,
        effect_aura_2,
        effect_aura_period_0,
        effect_aura_period_1,
        effect_aura_period_2,
        effect_amplitude_0,
        effect_amplitude_1,
        effect_amplitude_2,
        effect_chain_targets_0,
        effect_chain_targets_1,
        effect_chain_targets_2,
        effect_item_type_0,
        effect_item_type_1,
        effect_item_type_2,
        effect_misc_value_0,
        effect_misc_value_1,
        effect_misc_value_2,
        effect_misc_value_b_0,
        effect_misc_value_b_1,
        effect_misc_value_b_2,
        effect_trigger_spell_0,
        effect_trigger_spell_1,
        effect_trigger_spell_2,
        effect_points_per_combo_0,
        effect_points_per_combo_1,
        effect_points_per_combo_2,
        effect_spell_class_mask_a_0,
        effect_spell_class_mask_a_1,
        effect_spell_class_mask_a_2,
        effect_spell_class_mask_b_0,
        effect_spell_class_mask_b_1,
        effect_spell_class_mask_b_2,
        effect_spell_class_mask_c_0,
        effect_spell_class_mask_c_1,
        effect_spell_class_mask_c_2,
        spell_visual_id_0,
        spell_visual_id_1,
        spell_icon_id,
        active_icon_id,
        spell_priority,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_subtext_lang_en_gb,
        name_subtext_lang_ko_kr,
        name_subtext_lang_fr_fr,
        name_subtext_lang_de_de,
        name_subtext_lang_en_cn,
        name_subtext_lang_en_tw,
        name_subtext_lang_es_es,
        name_subtext_lang_es_mx,
        name_subtext_lang_ru_ru,
        name_subtext_lang_ja_jp,
        name_subtext_lang_pt_pt,
        name_subtext_lang_it_it,
        name_subtext_lang_unknown_12,
        name_subtext_lang_unknown_13,
        name_subtext_lang_unknown_14,
        name_subtext_lang_unknown_15,
        name_subtext_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        aura_description_lang_en_gb,
        aura_description_lang_ko_kr,
        aura_description_lang_fr_fr,
        aura_description_lang_de_de,
        aura_description_lang_en_cn,
        aura_description_lang_en_tw,
        aura_description_lang_es_es,
        aura_description_lang_es_mx,
        aura_description_lang_ru_ru,
        aura_description_lang_ja_jp,
        aura_description_lang_pt_pt,
        aura_description_lang_it_it,
        aura_description_lang_unknown_12,
        aura_description_lang_unknown_13,
        aura_description_lang_unknown_14,
        aura_description_lang_unknown_15,
        aura_description_lang_flags,
        mana_cost_pct,
        start_recovery_category,
        start_recovery_time,
        max_target_level,
        spell_class_set,
        spell_class_mask_0,
        spell_class_mask_1,
        spell_class_mask_2,
        max_targets,
        defense_type,
        prevention_type,
        stance_bar_order,
        effect_chain_amplitude_0,
        effect_chain_amplitude_1,
        effect_chain_amplitude_2,
        min_faction_id,
        min_reputation,
        required_aura_vision,
        required_totem_category_id_0,
        required_totem_category_id_1,
        required_areas_id,
        school_mask,
        rune_cost_id,
        spell_missile_id,
        power_display_id,
        effect_bonus_coefficient_0,
        effect_bonus_coefficient_1,
        effect_bonus_coefficient_2,
        description_variables_id,
        difficulty
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62,
        ?63,
        ?64,
        ?65,
        ?66,
        ?67,
        ?68,
        ?69,
        ?70,
        ?71,
        ?72,
        ?73,
        ?74,
        ?75,
        ?76,
        ?77,
        ?78,
        ?79,
        ?80,
        ?81,
        ?82,
        ?83,
        ?84,
        ?85,
        ?86,
        ?87,
        ?88,
        ?89,
        ?90,
        ?91,
        ?92,
        ?93,
        ?94,
        ?95,
        ?96,
        ?97,
        ?98,
        ?99,
        ?100,
        ?101,
        ?102,
        ?103,
        ?104,
        ?105,
        ?106,
        ?107,
        ?108,
        ?109,
        ?110,
        ?111,
        ?112,
        ?113,
        ?114,
        ?115,
        ?116,
        ?117,
        ?118,
        ?119,
        ?120,
        ?121,
        ?122,
        ?123,
        ?124,
        ?125,
        ?126,
        ?127,
        ?128,
        ?129,
        ?130,
        ?131,
        ?132,
        ?133,
        ?134,
        ?135,
        ?136,
        ?137,
        ?138,
        ?139,
        ?140,
        ?141,
        ?142,
        ?143,
        ?144,
        ?145,
        ?146,
        ?147,
        ?148,
        ?149,
        ?150,
        ?151,
        ?152,
        ?153,
        ?154,
        ?155,
        ?156,
        ?157,
        ?158,
        ?159,
        ?160,
        ?161,
        ?162,
        ?163,
        ?164,
        ?165,
        ?166,
        ?167,
        ?168,
        ?169,
        ?170,
        ?171,
        ?172,
        ?173,
        ?174,
        ?175,
        ?176,
        ?177,
        ?178,
        ?179,
        ?180,
        ?181,
        ?182,
        ?183,
        ?184,
        ?185,
        ?186,
        ?187,
        ?188,
        ?189,
        ?190,
        ?191,
        ?192,
        ?193,
        ?194,
        ?195,
        ?196,
        ?197,
        ?198,
        ?199,
        ?200,
        ?201,
        ?202,
        ?203,
        ?204,
        ?205,
        ?206,
        ?207,
        ?208,
        ?209,
        ?210,
        ?211,
        ?212,
        ?213,
        ?214,
        ?215,
        ?216,
        ?217,
        ?218,
        ?219,
        ?220,
        ?221,
        ?222,
        ?223,
        ?224,
        ?225,
        ?226,
        ?227,
        ?228,
        ?229,
        ?230,
        ?231,
        ?232,
        ?233,
        ?234
    );"
    ,
    "SELECT
        id,
        category,
        dispel_type,
        mechanic,
        attributes,
        attributes_ex,
        attributes_ex_b,
        attributes_ex_c,
        attributes_ex_d,
        attributes_ex_e,
        attributes_ex_f,
        attributes_ex_g,
        shapeshift_mask_0,
        shapeshift_mask_1,
        shapeshift_exclude_0,
        shapeshift_exclude_1,
        targets,
        target_creature_type,
        requires_spell_focus,
        facing_caster_flags,
        caster_aura_state,
        target_aura_state,
        exclude_caster_aura_state,
        exclude_target_aura_state,
        caster_aura_spell,
        target_aura_spell,
        exclude_caster_aura_spell,
        exclude_target_aura_spell,
        casting_time_index,
        recovery_time,
        category_recovery_time,
        interrupt_flags,
        aura_interrupt_flags,
        channel_interrupt_flags,
        proc_type_mask,
        proc_chance,
        proc_charges,
        max_level,
        base_level,
        spell_level,
        duration_index,
        power_type,
        mana_cost,
        mana_cost_per_level,
        mana_per_second,
        mana_per_second_per_level,
        range_index,
        speed,
        modal_next_spell,
        cumulative_aura,
        totem_0,
        totem_1,
        reagent_0,
        reagent_1,
        reagent_2,
        reagent_3,
        reagent_4,
        reagent_5,
        reagent_6,
        reagent_7,
        reagent_count_0,
        reagent_count_1,
        reagent_count_2,
        reagent_count_3,
        reagent_count_4,
        reagent_count_5,
        reagent_count_6,
        reagent_count_7,
        equipped_item_class,
        equipped_item_subclass,
        equipped_item_inv_types,
        effect_0,
        effect_1,
        effect_2,
        effect_die_sides_0,
        effect_die_sides_1,
        effect_die_sides_2,
        effect_real_points_per_level_0,
        effect_real_points_per_level_1,
        effect_real_points_per_level_2,
        effect_base_points_0,
        effect_base_points_1,
        effect_base_points_2,
        effect_mechanic_0,
        effect_mechanic_1,
        effect_mechanic_2,
        implicit_target_a_0,
        implicit_target_a_1,
        implicit_target_a_2,
        implicit_target_b_0,
        implicit_target_b_1,
        implicit_target_b_2,
        effect_radius_index_0,
        effect_radius_index_1,
        effect_radius_index_2,
        effect_aura_0,
        effect_aura_1,
        effect_aura_2,
        effect_aura_period_0,
        effect_aura_period_1,
        effect_aura_period_2,
        effect_amplitude_0,
        effect_amplitude_1,
        effect_amplitude_2,
        effect_chain_targets_0,
        effect_chain_targets_1,
        effect_chain_targets_2,
        effect_item_type_0,
        effect_item_type_1,
        effect_item_type_2,
        effect_misc_value_0,
        effect_misc_value_1,
        effect_misc_value_2,
        effect_misc_value_b_0,
        effect_misc_value_b_1,
        effect_misc_value_b_2,
        effect_trigger_spell_0,
        effect_trigger_spell_1,
        effect_trigger_spell_2,
        effect_points_per_combo_0,
        effect_points_per_combo_1,
        effect_points_per_combo_2,
        effect_spell_class_mask_a_0,
        effect_spell_class_mask_a_1,
        effect_spell_class_mask_a_2,
        effect_spell_class_mask_b_0,
        effect_spell_class_mask_b_1,
        effect_spell_class_mask_b_2,
        effect_spell_class_mask_c_0,
        effect_spell_class_mask_c_1,
        effect_spell_class_mask_c_2,
        spell_visual_id_0,
        spell_visual_id_1,
        spell_icon_id,
        active_icon_id,
        spell_priority,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        name_subtext_lang_en_gb,
        name_subtext_lang_ko_kr,
        name_subtext_lang_fr_fr,
        name_subtext_lang_de_de,
        name_subtext_lang_en_cn,
        name_subtext_lang_en_tw,
        name_subtext_lang_es_es,
        name_subtext_lang_es_mx,
        name_subtext_lang_ru_ru,
        name_subtext_lang_ja_jp,
        name_subtext_lang_pt_pt,
        name_subtext_lang_it_it,
        name_subtext_lang_unknown_12,
        name_subtext_lang_unknown_13,
        name_subtext_lang_unknown_14,
        name_subtext_lang_unknown_15,
        name_subtext_lang_flags,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags,
        aura_description_lang_en_gb,
        aura_description_lang_ko_kr,
        aura_description_lang_fr_fr,
        aura_description_lang_de_de,
        aura_description_lang_en_cn,
        aura_description_lang_en_tw,
        aura_description_lang_es_es,
        aura_description_lang_es_mx,
        aura_description_lang_ru_ru,
        aura_description_lang_ja_jp,
        aura_description_lang_pt_pt,
        aura_description_lang_it_it,
        aura_description_lang_unknown_12,
        aura_description_lang_unknown_13,
        aura_description_lang_unknown_14,
        aura_description_lang_unknown_15,
        aura_description_lang_flags,
        mana_cost_pct,
        start_recovery_category,
        start_recovery_time,
        max_target_level,
        spell_class_set,
        spell_class_mask_0,
        spell_class_mask_1,
        spell_class_mask_2,
        max_targets,
        defense_type,
        prevention_type,
        stance_bar_order,
        effect_chain_amplitude_0,
        effect_chain_amplitude_1,
        effect_chain_amplitude_2,
        min_faction_id,
        min_reputation,
        required_aura_vision,
        required_totem_category_id_0,
        required_totem_category_id_1,
        required_areas_id,
        school_mask,
        rune_cost_id,
        spell_missile_id,
        power_display_id,
        effect_bonus_coefficient_0,
        effect_bonus_coefficient_1,
        effect_bonus_coefficient_2,
        description_variables_id,
        difficulty
    FROM `Spell`;"
    )
}


pub(crate) fn spell_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell::Spell, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell::SpellRow {
            id: row.get::<_, i32>(0)?.into(),
            category: row.get::<_, i32>(1)?.into(),
            dispel_type: row.get::<_, i32>(2)?.into(),
            mechanic: row.get::<_, i32>(3)?.into(),
            attributes: row.get::<_, i32>(4)?.into(),
            attributes_ex: row.get::<_, i32>(5)?.into(),
            attributes_ex_b: row.get::<_, i32>(6)?.into(),
            attributes_ex_c: row.get::<_, i32>(7)?.into(),
            attributes_ex_d: row.get::<_, i32>(8)?.into(),
            attributes_ex_e: row.get::<_, i32>(9)?.into(),
            attributes_ex_f: row.get::<_, i32>(10)?.into(),
            attributes_ex_g: row.get::<_, i32>(11)?.into(),
            shapeshift_mask: [row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            shapeshift_exclude: [row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(),             ],
            targets: row.get::<_, i32>(16)?.into(),
            target_creature_type: row.get::<_, i32>(17)?.into(),
            requires_spell_focus: row.get::<_, i32>(18)?.into(),
            facing_caster_flags: row.get::<_, i32>(19)?.into(),
            caster_aura_state: row.get::<_, i32>(20)?.into(),
            target_aura_state: row.get::<_, i32>(21)?.into(),
            exclude_caster_aura_state: row.get::<_, i32>(22)?.into(),
            exclude_target_aura_state: row.get::<_, i32>(23)?.into(),
            caster_aura_spell: row.get::<_, i32>(24)?.into(),
            target_aura_spell: row.get::<_, i32>(25)?.into(),
            exclude_caster_aura_spell: row.get::<_, i32>(26)?.into(),
            exclude_target_aura_spell: row.get::<_, i32>(27)?.into(),
            casting_time_index: row.get::<_, i32>(28)?.into(),
            recovery_time: row.get::<_, i32>(29)?.into(),
            category_recovery_time: row.get::<_, i32>(30)?.into(),
            interrupt_flags: row.get::<_, i32>(31)?.into(),
            aura_interrupt_flags: row.get::<_, i32>(32)?.into(),
            channel_interrupt_flags: row.get::<_, i32>(33)?.into(),
            proc_type_mask: row.get::<_, i32>(34)?.into(),
            proc_chance: row.get::<_, i32>(35)?.into(),
            proc_charges: row.get::<_, i32>(36)?.into(),
            max_level: row.get::<_, i32>(37)?.into(),
            base_level: row.get::<_, i32>(38)?.into(),
            spell_level: row.get::<_, i32>(39)?.into(),
            duration_index: row.get::<_, i32>(40)?.into(),
            power_type: row.get::<_, i32>(41)?.into(),
            mana_cost: row.get::<_, i32>(42)?.into(),
            mana_cost_per_level: row.get::<_, i32>(43)?.into(),
            mana_per_second: row.get::<_, i32>(44)?.into(),
            mana_per_second_per_level: row.get::<_, i32>(45)?.into(),
            range_index: row.get::<_, i32>(46)?.into(),
            speed: row.get::<_, f32>(47)?.into(),
            modal_next_spell: row.get::<_, i32>(48)?.into(),
            cumulative_aura: row.get::<_, i32>(49)?.into(),
            totem: [row.get::<_, i32>(50)?.into(), row.get::<_, i32>(51)?.into(),             ],
            reagent: [row.get::<_, i32>(52)?.into(), row.get::<_, i32>(53)?.into(), row.get::<_, i32>(54)?.into(), row.get::<_, i32>(55)?.into(), row.get::<_, i32>(56)?.into(), row.get::<_, i32>(57)?.into(), row.get::<_, i32>(58)?.into(), row.get::<_, i32>(59)?.into(),             ],
            reagent_count: [row.get::<_, i32>(60)?.into(), row.get::<_, i32>(61)?.into(), row.get::<_, i32>(62)?.into(), row.get::<_, i32>(63)?.into(), row.get::<_, i32>(64)?.into(), row.get::<_, i32>(65)?.into(), row.get::<_, i32>(66)?.into(), row.get::<_, i32>(67)?.into(),             ],
            equipped_item_class: row.get::<_, i32>(68)?.into(),
            equipped_item_subclass: row.get::<_, i32>(69)?.into(),
            equipped_item_inv_types: row.get::<_, i32>(70)?.into(),
            effect: [row.get::<_, i32>(71)?.into(), row.get::<_, i32>(72)?.into(), row.get::<_, i32>(73)?.into(),             ],
            effect_die_sides: [row.get::<_, i32>(74)?.into(), row.get::<_, i32>(75)?.into(), row.get::<_, i32>(76)?.into(),             ],
            effect_real_points_per_level: [row.get::<_, f32>(77)?.into(), row.get::<_, f32>(78)?.into(), row.get::<_, f32>(79)?.into(),             ],
            effect_base_points: [row.get::<_, i32>(80)?.into(), row.get::<_, i32>(81)?.into(), row.get::<_, i32>(82)?.into(),             ],
            effect_mechanic: [row.get::<_, i32>(83)?.into(), row.get::<_, i32>(84)?.into(), row.get::<_, i32>(85)?.into(),             ],
            implicit_target_a: [row.get::<_, i32>(86)?.into(), row.get::<_, i32>(87)?.into(), row.get::<_, i32>(88)?.into(),             ],
            implicit_target_b: [row.get::<_, i32>(89)?.into(), row.get::<_, i32>(90)?.into(), row.get::<_, i32>(91)?.into(),             ],
            effect_radius_index: [row.get::<_, i32>(92)?.into(), row.get::<_, i32>(93)?.into(), row.get::<_, i32>(94)?.into(),             ],
            effect_aura: [            spell::AuraMod::from_int(row.get::<_, i32>(95)? as u32).map_err(|e| SqliteError::EnumError(e.to_string()))?,
            spell::AuraMod::from_int(row.get::<_, i32>(96)? as u32).map_err(|e| SqliteError::EnumError(e.to_string()))?,
            spell::AuraMod::from_int(row.get::<_, i32>(97)? as u32).map_err(|e| SqliteError::EnumError(e.to_string()))?,
            ],
            effect_aura_period: [row.get::<_, i32>(98)?.into(), row.get::<_, i32>(99)?.into(), row.get::<_, i32>(100)?.into(),             ],
            effect_amplitude: [row.get::<_, f32>(101)?.into(), row.get::<_, f32>(102)?.into(), row.get::<_, f32>(103)?.into(),             ],
            effect_chain_targets: [row.get::<_, i32>(104)?.into(), row.get::<_, i32>(105)?.into(), row.get::<_, i32>(106)?.into(),             ],
            effect_item_type: [row.get::<_, i32>(107)?.into(), row.get::<_, i32>(108)?.into(), row.get::<_, i32>(109)?.into(),             ],
            effect_misc_value: [row.get::<_, i32>(110)?.into(), row.get::<_, i32>(111)?.into(), row.get::<_, i32>(112)?.into(),             ],
            effect_misc_value_b: [row.get::<_, i32>(113)?.into(), row.get::<_, i32>(114)?.into(), row.get::<_, i32>(115)?.into(),             ],
            effect_trigger_spell: [row.get::<_, i32>(116)?.into(), row.get::<_, i32>(117)?.into(), row.get::<_, i32>(118)?.into(),             ],
            effect_points_per_combo: [row.get::<_, f32>(119)?.into(), row.get::<_, f32>(120)?.into(), row.get::<_, f32>(121)?.into(),             ],
            effect_spell_class_mask_a: [row.get::<_, i32>(122)?.into(), row.get::<_, i32>(123)?.into(), row.get::<_, i32>(124)?.into(),             ],
            effect_spell_class_mask_b: [row.get::<_, i32>(125)?.into(), row.get::<_, i32>(126)?.into(), row.get::<_, i32>(127)?.into(),             ],
            effect_spell_class_mask_c: [row.get::<_, i32>(128)?.into(), row.get::<_, i32>(129)?.into(), row.get::<_, i32>(130)?.into(),             ],
            spell_visual_id: [row.get::<_, i32>(131)?.into(), row.get::<_, i32>(132)?.into(),             ],
            spell_icon_id: row.get::<_, i32>(133)?.into(),
            active_icon_id: row.get::<_, i32>(134)?.into(),
            spell_priority: row.get::<_, i32>(135)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(136)?.into(),
                ko_kr: row.get::<_, String>(137)?.into(),
                fr_fr: row.get::<_, String>(138)?.into(),
                de_de: row.get::<_, String>(139)?.into(),
                en_cn: row.get::<_, String>(140)?.into(),
                en_tw: row.get::<_, String>(141)?.into(),
                es_es: row.get::<_, String>(142)?.into(),
                es_mx: row.get::<_, String>(143)?.into(),
                ru_ru: row.get::<_, String>(144)?.into(),
                ja_jp: row.get::<_, String>(145)?.into(),
                pt_pt: row.get::<_, String>(146)?.into(),
                it_it: row.get::<_, String>(147)?.into(),
                unknown_12: row.get::<_, String>(148)?.into(),
                unknown_13: row.get::<_, String>(149)?.into(),
                unknown_14: row.get::<_, String>(150)?.into(),
                unknown_15: row.get::<_, String>(151)?.into(),
                flags: row.get::<_, u32>(152)?.into(),
            },
            name_subtext_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(153)?.into(),
                ko_kr: row.get::<_, String>(154)?.into(),
                fr_fr: row.get::<_, String>(155)?.into(),
                de_de: row.get::<_, String>(156)?.into(),
                en_cn: row.get::<_, String>(157)?.into(),
                en_tw: row.get::<_, String>(158)?.into(),
                es_es: row.get::<_, String>(159)?.into(),
                es_mx: row.get::<_, String>(160)?.into(),
                ru_ru: row.get::<_, String>(161)?.into(),
                ja_jp: row.get::<_, String>(162)?.into(),
                pt_pt: row.get::<_, String>(163)?.into(),
                it_it: row.get::<_, String>(164)?.into(),
                unknown_12: row.get::<_, String>(165)?.into(),
                unknown_13: row.get::<_, String>(166)?.into(),
                unknown_14: row.get::<_, String>(167)?.into(),
                unknown_15: row.get::<_, String>(168)?.into(),
                flags: row.get::<_, u32>(169)?.into(),
            },
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(170)?.into(),
                ko_kr: row.get::<_, String>(171)?.into(),
                fr_fr: row.get::<_, String>(172)?.into(),
                de_de: row.get::<_, String>(173)?.into(),
                en_cn: row.get::<_, String>(174)?.into(),
                en_tw: row.get::<_, String>(175)?.into(),
                es_es: row.get::<_, String>(176)?.into(),
                es_mx: row.get::<_, String>(177)?.into(),
                ru_ru: row.get::<_, String>(178)?.into(),
                ja_jp: row.get::<_, String>(179)?.into(),
                pt_pt: row.get::<_, String>(180)?.into(),
                it_it: row.get::<_, String>(181)?.into(),
                unknown_12: row.get::<_, String>(182)?.into(),
                unknown_13: row.get::<_, String>(183)?.into(),
                unknown_14: row.get::<_, String>(184)?.into(),
                unknown_15: row.get::<_, String>(185)?.into(),
                flags: row.get::<_, u32>(186)?.into(),
            },
            aura_description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(187)?.into(),
                ko_kr: row.get::<_, String>(188)?.into(),
                fr_fr: row.get::<_, String>(189)?.into(),
                de_de: row.get::<_, String>(190)?.into(),
                en_cn: row.get::<_, String>(191)?.into(),
                en_tw: row.get::<_, String>(192)?.into(),
                es_es: row.get::<_, String>(193)?.into(),
                es_mx: row.get::<_, String>(194)?.into(),
                ru_ru: row.get::<_, String>(195)?.into(),
                ja_jp: row.get::<_, String>(196)?.into(),
                pt_pt: row.get::<_, String>(197)?.into(),
                it_it: row.get::<_, String>(198)?.into(),
                unknown_12: row.get::<_, String>(199)?.into(),
                unknown_13: row.get::<_, String>(200)?.into(),
                unknown_14: row.get::<_, String>(201)?.into(),
                unknown_15: row.get::<_, String>(202)?.into(),
                flags: row.get::<_, u32>(203)?.into(),
            },
            mana_cost_pct: row.get::<_, i32>(204)?.into(),
            start_recovery_category: row.get::<_, i32>(205)?.into(),
            start_recovery_time: row.get::<_, i32>(206)?.into(),
            max_target_level: row.get::<_, i32>(207)?.into(),
            spell_class_set: row.get::<_, i32>(208)?.into(),
            spell_class_mask: [row.get::<_, i32>(209)?.into(), row.get::<_, i32>(210)?.into(), row.get::<_, i32>(211)?.into(),             ],
            max_targets: row.get::<_, i32>(212)?.into(),
            defense_type: row.get::<_, i32>(213)?.into(),
            prevention_type: row.get::<_, i32>(214)?.into(),
            stance_bar_order: row.get::<_, i32>(215)?.into(),
            effect_chain_amplitude: [row.get::<_, f32>(216)?.into(), row.get::<_, f32>(217)?.into(), row.get::<_, f32>(218)?.into(),             ],
            min_faction_id: row.get::<_, i32>(219)?.into(),
            min_reputation: row.get::<_, i32>(220)?.into(),
            required_aura_vision: row.get::<_, i32>(221)?.into(),
            required_totem_category_id: [row.get::<_, i32>(222)?.into(), row.get::<_, i32>(223)?.into(),             ],
            required_areas_id: row.get::<_, i32>(224)?.into(),
            school_mask: row.get::<_, i32>(225)?.into(),
            rune_cost_id: row.get::<_, i32>(226)?.into(),
            spell_missile_id: row.get::<_, i32>(227)?.into(),
            power_display_id: row.get::<_, i32>(228)?.into(),
            effect_bonus_coefficient: [row.get::<_, f32>(229)?.into(), row.get::<_, f32>(230)?.into(), row.get::<_, f32>(231)?.into(),             ],
            description_variables_id: row.get::<_, i32>(232)?.into(),
            difficulty: row.get::<_, i32>(233)?.into(),
        });
    }
    Ok(spell::Spell { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellCastTimes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellCastTimes (
        id INTEGER PRIMARY KEY NOT NULL,
        base INTEGER  NOT NULL,
        per_level INTEGER  NOT NULL,
        minimum INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellCastTimes (
        id,
        base,
        per_level,
        minimum
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        base,
        per_level,
        minimum
    FROM `SpellCastTimes`;"
    )
}


pub(crate) fn spell_cast_times_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_cast_times::SpellCastTimes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_cast_times::SpellCastTimesRow {
            id: row.get::<_, i32>(0)?.into(),
            base: row.get::<_, i32>(1)?.into(),
            per_level: row.get::<_, i32>(2)?.into(),
            minimum: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(spell_cast_times::SpellCastTimes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellCategory (
        id,
        flags
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        flags
    FROM `SpellCategory`;"
    )
}


pub(crate) fn spell_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_category::SpellCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_category::SpellCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
        });
    }
    Ok(spell_category::SpellCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellChainEffects() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellChainEffects (
        id INTEGER PRIMARY KEY NOT NULL,
        avg_seg_len REAL  NOT NULL,
        width REAL  NOT NULL,
        noise_scale REAL  NOT NULL,
        tex_coord_scale REAL  NOT NULL,
        seg_duration INTEGER  NOT NULL,
        seg_delay INTEGER  NOT NULL,
        texture TEXT  NOT NULL,
        flags INTEGER  NOT NULL,
        joint_count INTEGER  NOT NULL,
        joint_offset_radius REAL  NOT NULL,
        joints_per_minor_joint INTEGER  NOT NULL,
        minor_joints_per_major_joint INTEGER  NOT NULL,
        minor_joint_scale REAL  NOT NULL,
        major_joint_scale REAL  NOT NULL,
        joint_move_speed REAL  NOT NULL,
        joint_smoothness REAL  NOT NULL,
        min_duration_between_joint_jumps REAL  NOT NULL,
        max_duration_between_joint_jumps REAL  NOT NULL,
        wave_height REAL  NOT NULL,
        wave_freq REAL  NOT NULL,
        wave_speed REAL  NOT NULL,
        min_wave_angle REAL  NOT NULL,
        max_wave_angle REAL  NOT NULL,
        min_wave_spin REAL  NOT NULL,
        max_wave_spin REAL  NOT NULL,
        arc_height REAL  NOT NULL,
        min_arc_angle REAL  NOT NULL,
        max_arc_angle REAL  NOT NULL,
        min_arc_spin REAL  NOT NULL,
        max_arc_spin REAL  NOT NULL,
        delay_between_effects REAL  NOT NULL,
        min_flicker_on_duration REAL  NOT NULL,
        max_flicker_on_duration REAL  NOT NULL,
        min_flicker_off_duration REAL  NOT NULL,
        max_flicker_off_duration REAL  NOT NULL,
        pulse_speed REAL  NOT NULL,
        pulse_on_length REAL  NOT NULL,
        pulse_fade_length REAL  NOT NULL,
        alpha INTEGER  NOT NULL,
        red INTEGER  NOT NULL,
        green INTEGER  NOT NULL,
        blue INTEGER  NOT NULL,
        blend_mode INTEGER  NOT NULL,
        combo TEXT  NOT NULL,
        render_layer INTEGER  NOT NULL,
        texture_length REAL  NOT NULL,
        wave_phase REAL  NOT NULL
    );"
    ,
    "INSERT INTO SpellChainEffects (
        id,
        avg_seg_len,
        width,
        noise_scale,
        tex_coord_scale,
        seg_duration,
        seg_delay,
        texture,
        flags,
        joint_count,
        joint_offset_radius,
        joints_per_minor_joint,
        minor_joints_per_major_joint,
        minor_joint_scale,
        major_joint_scale,
        joint_move_speed,
        joint_smoothness,
        min_duration_between_joint_jumps,
        max_duration_between_joint_jumps,
        wave_height,
        wave_freq,
        wave_speed,
        min_wave_angle,
        max_wave_angle,
        min_wave_spin,
        max_wave_spin,
        arc_height,
        min_arc_angle,
        max_arc_angle,
        min_arc_spin,
        max_arc_spin,
        delay_between_effects,
        min_flicker_on_duration,
        max_flicker_on_duration,
        min_flicker_off_duration,
        max_flicker_off_duration,
        pulse_speed,
        pulse_on_length,
        pulse_fade_length,
        alpha,
        red,
        green,
        blue,
        blend_mode,
        combo,
        render_layer,
        texture_length,
        wave_phase
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48
    );"
    ,
    "SELECT
        id,
        avg_seg_len,
        width,
        noise_scale,
        tex_coord_scale,
        seg_duration,
        seg_delay,
        texture,
        flags,
        joint_count,
        joint_offset_radius,
        joints_per_minor_joint,
        minor_joints_per_major_joint,
        minor_joint_scale,
        major_joint_scale,
        joint_move_speed,
        joint_smoothness,
        min_duration_between_joint_jumps,
        max_duration_between_joint_jumps,
        wave_height,
        wave_freq,
        wave_speed,
        min_wave_angle,
        max_wave_angle,
        min_wave_spin,
        max_wave_spin,
        arc_height,
        min_arc_angle,
        max_arc_angle,
        min_arc_spin,
        max_arc_spin,
        delay_between_effects,
        min_flicker_on_duration,
        max_flicker_on_duration,
        min_flicker_off_duration,
        max_flicker_off_duration,
        pulse_speed,
        pulse_on_length,
        pulse_fade_length,
        alpha,
        red,
        green,
        blue,
        blend_mode,
        combo,
        render_layer,
        texture_length,
        wave_phase
    FROM `SpellChainEffects`;"
    )
}


pub(crate) fn spell_chain_effects_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_chain_effects::SpellChainEffects, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_chain_effects::SpellChainEffectsRow {
            id: row.get::<_, i32>(0)?.into(),
            avg_seg_len: row.get::<_, f32>(1)?.into(),
            width: row.get::<_, f32>(2)?.into(),
            noise_scale: row.get::<_, f32>(3)?.into(),
            tex_coord_scale: row.get::<_, f32>(4)?.into(),
            seg_duration: row.get::<_, i32>(5)?.into(),
            seg_delay: row.get::<_, i32>(6)?.into(),
            texture: row.get::<_, String>(7)?.into(),
            flags: row.get::<_, i32>(8)?.into(),
            joint_count: row.get::<_, i32>(9)?.into(),
            joint_offset_radius: row.get::<_, f32>(10)?.into(),
            joints_per_minor_joint: row.get::<_, i32>(11)?.into(),
            minor_joints_per_major_joint: row.get::<_, i32>(12)?.into(),
            minor_joint_scale: row.get::<_, f32>(13)?.into(),
            major_joint_scale: row.get::<_, f32>(14)?.into(),
            joint_move_speed: row.get::<_, f32>(15)?.into(),
            joint_smoothness: row.get::<_, f32>(16)?.into(),
            min_duration_between_joint_jumps: row.get::<_, f32>(17)?.into(),
            max_duration_between_joint_jumps: row.get::<_, f32>(18)?.into(),
            wave_height: row.get::<_, f32>(19)?.into(),
            wave_freq: row.get::<_, f32>(20)?.into(),
            wave_speed: row.get::<_, f32>(21)?.into(),
            min_wave_angle: row.get::<_, f32>(22)?.into(),
            max_wave_angle: row.get::<_, f32>(23)?.into(),
            min_wave_spin: row.get::<_, f32>(24)?.into(),
            max_wave_spin: row.get::<_, f32>(25)?.into(),
            arc_height: row.get::<_, f32>(26)?.into(),
            min_arc_angle: row.get::<_, f32>(27)?.into(),
            max_arc_angle: row.get::<_, f32>(28)?.into(),
            min_arc_spin: row.get::<_, f32>(29)?.into(),
            max_arc_spin: row.get::<_, f32>(30)?.into(),
            delay_between_effects: row.get::<_, f32>(31)?.into(),
            min_flicker_on_duration: row.get::<_, f32>(32)?.into(),
            max_flicker_on_duration: row.get::<_, f32>(33)?.into(),
            min_flicker_off_duration: row.get::<_, f32>(34)?.into(),
            max_flicker_off_duration: row.get::<_, f32>(35)?.into(),
            pulse_speed: row.get::<_, f32>(36)?.into(),
            pulse_on_length: row.get::<_, f32>(37)?.into(),
            pulse_fade_length: row.get::<_, f32>(38)?.into(),
            alpha: row.get::<_, i8>(39)?.into(),
            red: row.get::<_, i8>(40)?.into(),
            green: row.get::<_, i8>(41)?.into(),
            blue: row.get::<_, i8>(42)?.into(),
            blend_mode: row.get::<_, i8>(43)?.into(),
            combo: row.get::<_, String>(44)?.into(),
            render_layer: row.get::<_, i32>(45)?.into(),
            texture_length: row.get::<_, f32>(46)?.into(),
            wave_phase: row.get::<_, f32>(47)?.into(),
        });
    }
    Ok(spell_chain_effects::SpellChainEffects { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellDescriptionVariables() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellDescriptionVariables (
        id INTEGER PRIMARY KEY NOT NULL,
        variables TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SpellDescriptionVariables (
        id,
        variables
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        variables
    FROM `SpellDescriptionVariables`;"
    )
}


pub(crate) fn spell_description_variables_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_description_variables::SpellDescriptionVariables, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_description_variables::SpellDescriptionVariablesRow {
            id: row.get::<_, i32>(0)?.into(),
            variables: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(spell_description_variables::SpellDescriptionVariables { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellDifficulty() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellDifficulty (
        id INTEGER PRIMARY KEY NOT NULL,
        difficulty_spell_id_0 INTEGER NOT NULL,
        difficulty_spell_id_1 INTEGER NOT NULL,
        difficulty_spell_id_2 INTEGER NOT NULL,
        difficulty_spell_id_3 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellDifficulty (
        id,
        difficulty_spell_id_0,
        difficulty_spell_id_1,
        difficulty_spell_id_2,
        difficulty_spell_id_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        difficulty_spell_id_0,
        difficulty_spell_id_1,
        difficulty_spell_id_2,
        difficulty_spell_id_3
    FROM `SpellDifficulty`;"
    )
}


pub(crate) fn spell_difficulty_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_difficulty::SpellDifficulty, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_difficulty::SpellDifficultyRow {
            id: row.get::<_, i32>(0)?.into(),
            difficulty_spell_id: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
        });
    }
    Ok(spell_difficulty::SpellDifficulty { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellDispelType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellDispelType (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        mask INTEGER  NOT NULL,
        immunity_possible INTEGER  NOT NULL,
        internal_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SpellDispelType (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        mask,
        immunity_possible,
        internal_name
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        mask,
        immunity_possible,
        internal_name
    FROM `SpellDispelType`;"
    )
}


pub(crate) fn spell_dispel_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_dispel_type::SpellDispelType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_dispel_type::SpellDispelTypeRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            mask: row.get::<_, i32>(18)?.into(),
            immunity_possible: row.get::<_, i32>(19)?.into(),
            internal_name: row.get::<_, String>(20)?.into(),
        });
    }
    Ok(spell_dispel_type::SpellDispelType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellDuration() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellDuration (
        id INTEGER PRIMARY KEY NOT NULL,
        duration INTEGER  NOT NULL,
        duration_per_level INTEGER  NOT NULL,
        max_duration INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellDuration (
        id,
        duration,
        duration_per_level,
        max_duration
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        duration,
        duration_per_level,
        max_duration
    FROM `SpellDuration`;"
    )
}


pub(crate) fn spell_duration_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_duration::SpellDuration, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_duration::SpellDurationRow {
            id: row.get::<_, i32>(0)?.into(),
            duration: row.get::<_, i32>(1)?.into(),
            duration_per_level: row.get::<_, i32>(2)?.into(),
            max_duration: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(spell_duration::SpellDuration { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellEffectCameraShakes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellEffectCameraShakes (
        id INTEGER PRIMARY KEY NOT NULL,
        camera_shake_0 INTEGER NOT NULL,
        camera_shake_1 INTEGER NOT NULL,
        camera_shake_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellEffectCameraShakes (
        id,
        camera_shake_0,
        camera_shake_1,
        camera_shake_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        camera_shake_0,
        camera_shake_1,
        camera_shake_2
    FROM `SpellEffectCameraShakes`;"
    )
}


pub(crate) fn spell_effect_camera_shakes_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_effect_camera_shakes::SpellEffectCameraShakes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_effect_camera_shakes::SpellEffectCameraShakesRow {
            id: row.get::<_, i32>(0)?.into(),
            camera_shake: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(),             ],
        });
    }
    Ok(spell_effect_camera_shakes::SpellEffectCameraShakes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellFocusObject() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellFocusObject (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellFocusObject (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags
    FROM `SpellFocusObject`;"
    )
}


pub(crate) fn spell_focus_object_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_focus_object::SpellFocusObject, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_focus_object::SpellFocusObjectRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(spell_focus_object::SpellFocusObject { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellIcon() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellIcon (
        id INTEGER PRIMARY KEY NOT NULL,
        texture_filename TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SpellIcon (
        id,
        texture_filename
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        texture_filename
    FROM `SpellIcon`;"
    )
}


pub(crate) fn spell_icon_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_icon::SpellIcon, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_icon::SpellIconRow {
            id: row.get::<_, i32>(0)?.into(),
            texture_filename: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(spell_icon::SpellIcon { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellItemEnchantment() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellItemEnchantment (
        id INTEGER PRIMARY KEY NOT NULL,
        charges INTEGER  NOT NULL,
        effect_0 INTEGER NOT NULL,
        effect_1 INTEGER NOT NULL,
        effect_2 INTEGER NOT NULL,
        effect_points_min_0 INTEGER NOT NULL,
        effect_points_min_1 INTEGER NOT NULL,
        effect_points_min_2 INTEGER NOT NULL,
        effect_points_max_0 INTEGER NOT NULL,
        effect_points_max_1 INTEGER NOT NULL,
        effect_points_max_2 INTEGER NOT NULL,
        effect_arg_0 INTEGER NOT NULL,
        effect_arg_1 INTEGER NOT NULL,
        effect_arg_2 INTEGER NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        item_visual INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        src_item_id INTEGER  NOT NULL,
        condition_id INTEGER  NOT NULL,
        required_skill_id INTEGER  NOT NULL,
        required_skill_rank INTEGER  NOT NULL,
        min_level INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellItemEnchantment (
        id,
        charges,
        effect_0,
        effect_1,
        effect_2,
        effect_points_min_0,
        effect_points_min_1,
        effect_points_min_2,
        effect_points_max_0,
        effect_points_max_1,
        effect_points_max_2,
        effect_arg_0,
        effect_arg_1,
        effect_arg_2,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        item_visual,
        flags,
        src_item_id,
        condition_id,
        required_skill_id,
        required_skill_rank,
        min_level
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38
    );"
    ,
    "SELECT
        id,
        charges,
        effect_0,
        effect_1,
        effect_2,
        effect_points_min_0,
        effect_points_min_1,
        effect_points_min_2,
        effect_points_max_0,
        effect_points_max_1,
        effect_points_max_2,
        effect_arg_0,
        effect_arg_1,
        effect_arg_2,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        item_visual,
        flags,
        src_item_id,
        condition_id,
        required_skill_id,
        required_skill_rank,
        min_level
    FROM `SpellItemEnchantment`;"
    )
}


pub(crate) fn spell_item_enchantment_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_item_enchantment::SpellItemEnchantment, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_item_enchantment::SpellItemEnchantmentRow {
            id: row.get::<_, i32>(0)?.into(),
            charges: row.get::<_, i32>(1)?.into(),
            effect: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            effect_points_min: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(),             ],
            effect_points_max: [row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            effect_arg: [row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(14)?.into(),
                ko_kr: row.get::<_, String>(15)?.into(),
                fr_fr: row.get::<_, String>(16)?.into(),
                de_de: row.get::<_, String>(17)?.into(),
                en_cn: row.get::<_, String>(18)?.into(),
                en_tw: row.get::<_, String>(19)?.into(),
                es_es: row.get::<_, String>(20)?.into(),
                es_mx: row.get::<_, String>(21)?.into(),
                ru_ru: row.get::<_, String>(22)?.into(),
                ja_jp: row.get::<_, String>(23)?.into(),
                pt_pt: row.get::<_, String>(24)?.into(),
                it_it: row.get::<_, String>(25)?.into(),
                unknown_12: row.get::<_, String>(26)?.into(),
                unknown_13: row.get::<_, String>(27)?.into(),
                unknown_14: row.get::<_, String>(28)?.into(),
                unknown_15: row.get::<_, String>(29)?.into(),
                flags: row.get::<_, u32>(30)?.into(),
            },
            item_visual: row.get::<_, i32>(31)?.into(),
            flags: row.get::<_, i32>(32)?.into(),
            src_item_id: row.get::<_, i32>(33)?.into(),
            condition_id: row.get::<_, i32>(34)?.into(),
            required_skill_id: row.get::<_, i32>(35)?.into(),
            required_skill_rank: row.get::<_, i32>(36)?.into(),
            min_level: row.get::<_, i32>(37)?.into(),
        });
    }
    Ok(spell_item_enchantment::SpellItemEnchantment { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellItemEnchantmentCondition() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellItemEnchantmentCondition (
        id INTEGER PRIMARY KEY NOT NULL,
        lt_operand_type_0 INTEGER NOT NULL,
        lt_operand_type_1 INTEGER NOT NULL,
        lt_operand_type_2 INTEGER NOT NULL,
        lt_operand_type_3 INTEGER NOT NULL,
        lt_operand_type_4 INTEGER NOT NULL,
        lt_operand_0 INTEGER NOT NULL,
        lt_operand_1 INTEGER NOT NULL,
        lt_operand_2 INTEGER NOT NULL,
        lt_operand_3 INTEGER NOT NULL,
        lt_operand_4 INTEGER NOT NULL,
        operator_0 INTEGER NOT NULL,
        operator_1 INTEGER NOT NULL,
        operator_2 INTEGER NOT NULL,
        operator_3 INTEGER NOT NULL,
        operator_4 INTEGER NOT NULL,
        rt_operand_type_0 INTEGER NOT NULL,
        rt_operand_type_1 INTEGER NOT NULL,
        rt_operand_type_2 INTEGER NOT NULL,
        rt_operand_type_3 INTEGER NOT NULL,
        rt_operand_type_4 INTEGER NOT NULL,
        rt_operand_0 INTEGER NOT NULL,
        rt_operand_1 INTEGER NOT NULL,
        rt_operand_2 INTEGER NOT NULL,
        rt_operand_3 INTEGER NOT NULL,
        rt_operand_4 INTEGER NOT NULL,
        logic_0 INTEGER NOT NULL,
        logic_1 INTEGER NOT NULL,
        logic_2 INTEGER NOT NULL,
        logic_3 INTEGER NOT NULL,
        logic_4 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellItemEnchantmentCondition (
        id,
        lt_operand_type_0,
        lt_operand_type_1,
        lt_operand_type_2,
        lt_operand_type_3,
        lt_operand_type_4,
        lt_operand_0,
        lt_operand_1,
        lt_operand_2,
        lt_operand_3,
        lt_operand_4,
        operator_0,
        operator_1,
        operator_2,
        operator_3,
        operator_4,
        rt_operand_type_0,
        rt_operand_type_1,
        rt_operand_type_2,
        rt_operand_type_3,
        rt_operand_type_4,
        rt_operand_0,
        rt_operand_1,
        rt_operand_2,
        rt_operand_3,
        rt_operand_4,
        logic_0,
        logic_1,
        logic_2,
        logic_3,
        logic_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31
    );"
    ,
    "SELECT
        id,
        lt_operand_type_0,
        lt_operand_type_1,
        lt_operand_type_2,
        lt_operand_type_3,
        lt_operand_type_4,
        lt_operand_0,
        lt_operand_1,
        lt_operand_2,
        lt_operand_3,
        lt_operand_4,
        operator_0,
        operator_1,
        operator_2,
        operator_3,
        operator_4,
        rt_operand_type_0,
        rt_operand_type_1,
        rt_operand_type_2,
        rt_operand_type_3,
        rt_operand_type_4,
        rt_operand_0,
        rt_operand_1,
        rt_operand_2,
        rt_operand_3,
        rt_operand_4,
        logic_0,
        logic_1,
        logic_2,
        logic_3,
        logic_4
    FROM `SpellItemEnchantmentCondition`;"
    )
}


pub(crate) fn spell_item_enchantment_condition_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_item_enchantment_condition::SpellItemEnchantmentCondition, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_item_enchantment_condition::SpellItemEnchantmentConditionRow {
            id: row.get::<_, i32>(0)?.into(),
            lt_operand_type: [row.get::<_, i8>(1)?.into(), row.get::<_, i8>(2)?.into(), row.get::<_, i8>(3)?.into(), row.get::<_, i8>(4)?.into(), row.get::<_, i8>(5)?.into(),             ],
            lt_operand: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(),             ],
            operator: [row.get::<_, i8>(11)?.into(), row.get::<_, i8>(12)?.into(), row.get::<_, i8>(13)?.into(), row.get::<_, i8>(14)?.into(), row.get::<_, i8>(15)?.into(),             ],
            rt_operand_type: [row.get::<_, i8>(16)?.into(), row.get::<_, i8>(17)?.into(), row.get::<_, i8>(18)?.into(), row.get::<_, i8>(19)?.into(), row.get::<_, i8>(20)?.into(),             ],
            rt_operand: [row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(),             ],
            logic: [row.get::<_, i8>(26)?.into(), row.get::<_, i8>(27)?.into(), row.get::<_, i8>(28)?.into(), row.get::<_, i8>(29)?.into(), row.get::<_, i8>(30)?.into(),             ],
        });
    }
    Ok(spell_item_enchantment_condition::SpellItemEnchantmentCondition { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellMechanic() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellMechanic (
        id INTEGER PRIMARY KEY NOT NULL,
        state_name_lang_en_gb TEXT NOT NULL,
        state_name_lang_ko_kr TEXT NOT NULL,
        state_name_lang_fr_fr TEXT NOT NULL,
        state_name_lang_de_de TEXT NOT NULL,
        state_name_lang_en_cn TEXT NOT NULL,
        state_name_lang_en_tw TEXT NOT NULL,
        state_name_lang_es_es TEXT NOT NULL,
        state_name_lang_es_mx TEXT NOT NULL,
        state_name_lang_ru_ru TEXT NOT NULL,
        state_name_lang_ja_jp TEXT NOT NULL,
        state_name_lang_pt_pt TEXT NOT NULL,
        state_name_lang_it_it TEXT NOT NULL,
        state_name_lang_unknown_12 TEXT NOT NULL,
        state_name_lang_unknown_13 TEXT NOT NULL,
        state_name_lang_unknown_14 TEXT NOT NULL,
        state_name_lang_unknown_15 TEXT NOT NULL,
        state_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellMechanic (
        id,
        state_name_lang_en_gb,
        state_name_lang_ko_kr,
        state_name_lang_fr_fr,
        state_name_lang_de_de,
        state_name_lang_en_cn,
        state_name_lang_en_tw,
        state_name_lang_es_es,
        state_name_lang_es_mx,
        state_name_lang_ru_ru,
        state_name_lang_ja_jp,
        state_name_lang_pt_pt,
        state_name_lang_it_it,
        state_name_lang_unknown_12,
        state_name_lang_unknown_13,
        state_name_lang_unknown_14,
        state_name_lang_unknown_15,
        state_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18
    );"
    ,
    "SELECT
        id,
        state_name_lang_en_gb,
        state_name_lang_ko_kr,
        state_name_lang_fr_fr,
        state_name_lang_de_de,
        state_name_lang_en_cn,
        state_name_lang_en_tw,
        state_name_lang_es_es,
        state_name_lang_es_mx,
        state_name_lang_ru_ru,
        state_name_lang_ja_jp,
        state_name_lang_pt_pt,
        state_name_lang_it_it,
        state_name_lang_unknown_12,
        state_name_lang_unknown_13,
        state_name_lang_unknown_14,
        state_name_lang_unknown_15,
        state_name_lang_flags
    FROM `SpellMechanic`;"
    )
}


pub(crate) fn spell_mechanic_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_mechanic::SpellMechanic, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_mechanic::SpellMechanicRow {
            id: row.get::<_, i32>(0)?.into(),
            state_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
        });
    }
    Ok(spell_mechanic::SpellMechanic { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellMissile() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellMissile (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        default_pitch_min REAL  NOT NULL,
        default_pitch_max REAL  NOT NULL,
        default_speed_min REAL  NOT NULL,
        default_speed_max REAL  NOT NULL,
        randomize_facing_min REAL  NOT NULL,
        randomize_facing_max REAL  NOT NULL,
        randomize_pitch_min REAL  NOT NULL,
        randomize_pitch_max REAL  NOT NULL,
        randomize_speed_min REAL  NOT NULL,
        randomize_speed_max REAL  NOT NULL,
        gravity REAL  NOT NULL,
        max_duration REAL  NOT NULL,
        collision_radius REAL  NOT NULL
    );"
    ,
    "INSERT INTO SpellMissile (
        id,
        flags,
        default_pitch_min,
        default_pitch_max,
        default_speed_min,
        default_speed_max,
        randomize_facing_min,
        randomize_facing_max,
        randomize_pitch_min,
        randomize_pitch_max,
        randomize_speed_min,
        randomize_speed_max,
        gravity,
        max_duration,
        collision_radius
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15
    );"
    ,
    "SELECT
        id,
        flags,
        default_pitch_min,
        default_pitch_max,
        default_speed_min,
        default_speed_max,
        randomize_facing_min,
        randomize_facing_max,
        randomize_pitch_min,
        randomize_pitch_max,
        randomize_speed_min,
        randomize_speed_max,
        gravity,
        max_duration,
        collision_radius
    FROM `SpellMissile`;"
    )
}


pub(crate) fn spell_missile_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_missile::SpellMissile, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_missile::SpellMissileRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            default_pitch_min: row.get::<_, f32>(2)?.into(),
            default_pitch_max: row.get::<_, f32>(3)?.into(),
            default_speed_min: row.get::<_, f32>(4)?.into(),
            default_speed_max: row.get::<_, f32>(5)?.into(),
            randomize_facing_min: row.get::<_, f32>(6)?.into(),
            randomize_facing_max: row.get::<_, f32>(7)?.into(),
            randomize_pitch_min: row.get::<_, f32>(8)?.into(),
            randomize_pitch_max: row.get::<_, f32>(9)?.into(),
            randomize_speed_min: row.get::<_, f32>(10)?.into(),
            randomize_speed_max: row.get::<_, f32>(11)?.into(),
            gravity: row.get::<_, f32>(12)?.into(),
            max_duration: row.get::<_, f32>(13)?.into(),
            collision_radius: row.get::<_, f32>(14)?.into(),
        });
    }
    Ok(spell_missile::SpellMissile { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellMissileMotion() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellMissileMotion (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        script_body TEXT  NOT NULL,
        flags INTEGER  NOT NULL,
        missile_count INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellMissileMotion (
        id,
        name,
        script_body,
        flags,
        missile_count
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        name,
        script_body,
        flags,
        missile_count
    FROM `SpellMissileMotion`;"
    )
}


pub(crate) fn spell_missile_motion_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_missile_motion::SpellMissileMotion, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_missile_motion::SpellMissileMotionRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            script_body: row.get::<_, String>(2)?.into(),
            flags: row.get::<_, i32>(3)?.into(),
            missile_count: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(spell_missile_motion::SpellMissileMotion { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellRadius() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellRadius (
        id INTEGER PRIMARY KEY NOT NULL,
        radius REAL  NOT NULL,
        radius_per_level REAL  NOT NULL,
        radius_max REAL  NOT NULL
    );"
    ,
    "INSERT INTO SpellRadius (
        id,
        radius,
        radius_per_level,
        radius_max
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        radius,
        radius_per_level,
        radius_max
    FROM `SpellRadius`;"
    )
}


pub(crate) fn spell_radius_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_radius::SpellRadius, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_radius::SpellRadiusRow {
            id: row.get::<_, i32>(0)?.into(),
            radius: row.get::<_, f32>(1)?.into(),
            radius_per_level: row.get::<_, f32>(2)?.into(),
            radius_max: row.get::<_, f32>(3)?.into(),
        });
    }
    Ok(spell_radius::SpellRadius { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellRange() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellRange (
        id INTEGER PRIMARY KEY NOT NULL,
        range_min_0 REAL NOT NULL,
        range_min_1 REAL NOT NULL,
        range_max_0 REAL NOT NULL,
        range_max_1 REAL NOT NULL,
        flags INTEGER  NOT NULL,
        display_name_lang_en_gb TEXT NOT NULL,
        display_name_lang_ko_kr TEXT NOT NULL,
        display_name_lang_fr_fr TEXT NOT NULL,
        display_name_lang_de_de TEXT NOT NULL,
        display_name_lang_en_cn TEXT NOT NULL,
        display_name_lang_en_tw TEXT NOT NULL,
        display_name_lang_es_es TEXT NOT NULL,
        display_name_lang_es_mx TEXT NOT NULL,
        display_name_lang_ru_ru TEXT NOT NULL,
        display_name_lang_ja_jp TEXT NOT NULL,
        display_name_lang_pt_pt TEXT NOT NULL,
        display_name_lang_it_it TEXT NOT NULL,
        display_name_lang_unknown_12 TEXT NOT NULL,
        display_name_lang_unknown_13 TEXT NOT NULL,
        display_name_lang_unknown_14 TEXT NOT NULL,
        display_name_lang_unknown_15 TEXT NOT NULL,
        display_name_lang_flags INTEGER NOT NULL,
        display_name_short_lang_en_gb TEXT NOT NULL,
        display_name_short_lang_ko_kr TEXT NOT NULL,
        display_name_short_lang_fr_fr TEXT NOT NULL,
        display_name_short_lang_de_de TEXT NOT NULL,
        display_name_short_lang_en_cn TEXT NOT NULL,
        display_name_short_lang_en_tw TEXT NOT NULL,
        display_name_short_lang_es_es TEXT NOT NULL,
        display_name_short_lang_es_mx TEXT NOT NULL,
        display_name_short_lang_ru_ru TEXT NOT NULL,
        display_name_short_lang_ja_jp TEXT NOT NULL,
        display_name_short_lang_pt_pt TEXT NOT NULL,
        display_name_short_lang_it_it TEXT NOT NULL,
        display_name_short_lang_unknown_12 TEXT NOT NULL,
        display_name_short_lang_unknown_13 TEXT NOT NULL,
        display_name_short_lang_unknown_14 TEXT NOT NULL,
        display_name_short_lang_unknown_15 TEXT NOT NULL,
        display_name_short_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellRange (
        id,
        range_min_0,
        range_min_1,
        range_max_0,
        range_max_1,
        flags,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        display_name_short_lang_en_gb,
        display_name_short_lang_ko_kr,
        display_name_short_lang_fr_fr,
        display_name_short_lang_de_de,
        display_name_short_lang_en_cn,
        display_name_short_lang_en_tw,
        display_name_short_lang_es_es,
        display_name_short_lang_es_mx,
        display_name_short_lang_ru_ru,
        display_name_short_lang_ja_jp,
        display_name_short_lang_pt_pt,
        display_name_short_lang_it_it,
        display_name_short_lang_unknown_12,
        display_name_short_lang_unknown_13,
        display_name_short_lang_unknown_14,
        display_name_short_lang_unknown_15,
        display_name_short_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40
    );"
    ,
    "SELECT
        id,
        range_min_0,
        range_min_1,
        range_max_0,
        range_max_1,
        flags,
        display_name_lang_en_gb,
        display_name_lang_ko_kr,
        display_name_lang_fr_fr,
        display_name_lang_de_de,
        display_name_lang_en_cn,
        display_name_lang_en_tw,
        display_name_lang_es_es,
        display_name_lang_es_mx,
        display_name_lang_ru_ru,
        display_name_lang_ja_jp,
        display_name_lang_pt_pt,
        display_name_lang_it_it,
        display_name_lang_unknown_12,
        display_name_lang_unknown_13,
        display_name_lang_unknown_14,
        display_name_lang_unknown_15,
        display_name_lang_flags,
        display_name_short_lang_en_gb,
        display_name_short_lang_ko_kr,
        display_name_short_lang_fr_fr,
        display_name_short_lang_de_de,
        display_name_short_lang_en_cn,
        display_name_short_lang_en_tw,
        display_name_short_lang_es_es,
        display_name_short_lang_es_mx,
        display_name_short_lang_ru_ru,
        display_name_short_lang_ja_jp,
        display_name_short_lang_pt_pt,
        display_name_short_lang_it_it,
        display_name_short_lang_unknown_12,
        display_name_short_lang_unknown_13,
        display_name_short_lang_unknown_14,
        display_name_short_lang_unknown_15,
        display_name_short_lang_flags
    FROM `SpellRange`;"
    )
}


pub(crate) fn spell_range_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_range::SpellRange, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_range::SpellRangeRow {
            id: row.get::<_, i32>(0)?.into(),
            range_min: [row.get::<_, f32>(1)?.into(), row.get::<_, f32>(2)?.into(),             ],
            range_max: [row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(),             ],
            flags: row.get::<_, i32>(5)?.into(),
            display_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(6)?.into(),
                ko_kr: row.get::<_, String>(7)?.into(),
                fr_fr: row.get::<_, String>(8)?.into(),
                de_de: row.get::<_, String>(9)?.into(),
                en_cn: row.get::<_, String>(10)?.into(),
                en_tw: row.get::<_, String>(11)?.into(),
                es_es: row.get::<_, String>(12)?.into(),
                es_mx: row.get::<_, String>(13)?.into(),
                ru_ru: row.get::<_, String>(14)?.into(),
                ja_jp: row.get::<_, String>(15)?.into(),
                pt_pt: row.get::<_, String>(16)?.into(),
                it_it: row.get::<_, String>(17)?.into(),
                unknown_12: row.get::<_, String>(18)?.into(),
                unknown_13: row.get::<_, String>(19)?.into(),
                unknown_14: row.get::<_, String>(20)?.into(),
                unknown_15: row.get::<_, String>(21)?.into(),
                flags: row.get::<_, u32>(22)?.into(),
            },
            display_name_short_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(23)?.into(),
                ko_kr: row.get::<_, String>(24)?.into(),
                fr_fr: row.get::<_, String>(25)?.into(),
                de_de: row.get::<_, String>(26)?.into(),
                en_cn: row.get::<_, String>(27)?.into(),
                en_tw: row.get::<_, String>(28)?.into(),
                es_es: row.get::<_, String>(29)?.into(),
                es_mx: row.get::<_, String>(30)?.into(),
                ru_ru: row.get::<_, String>(31)?.into(),
                ja_jp: row.get::<_, String>(32)?.into(),
                pt_pt: row.get::<_, String>(33)?.into(),
                it_it: row.get::<_, String>(34)?.into(),
                unknown_12: row.get::<_, String>(35)?.into(),
                unknown_13: row.get::<_, String>(36)?.into(),
                unknown_14: row.get::<_, String>(37)?.into(),
                unknown_15: row.get::<_, String>(38)?.into(),
                flags: row.get::<_, u32>(39)?.into(),
            },
        });
    }
    Ok(spell_range::SpellRange { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellRuneCost() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellRuneCost (
        id INTEGER PRIMARY KEY NOT NULL,
        blood INTEGER  NOT NULL,
        unholy INTEGER  NOT NULL,
        frost INTEGER  NOT NULL,
        runic_power INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellRuneCost (
        id,
        blood,
        unholy,
        frost,
        runic_power
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        blood,
        unholy,
        frost,
        runic_power
    FROM `SpellRuneCost`;"
    )
}


pub(crate) fn spell_rune_cost_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_rune_cost::SpellRuneCost, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_rune_cost::SpellRuneCostRow {
            id: row.get::<_, i32>(0)?.into(),
            blood: row.get::<_, i32>(1)?.into(),
            unholy: row.get::<_, i32>(2)?.into(),
            frost: row.get::<_, i32>(3)?.into(),
            runic_power: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(spell_rune_cost::SpellRuneCost { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellShapeshiftForm() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellShapeshiftForm (
        id INTEGER PRIMARY KEY NOT NULL,
        bonus_action_bar INTEGER  NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        flags INTEGER  NOT NULL,
        creature_type INTEGER  NOT NULL,
        attack_icon_id INTEGER  NOT NULL,
        combat_round_time INTEGER  NOT NULL,
        creature_display_id_0 INTEGER NOT NULL,
        creature_display_id_1 INTEGER NOT NULL,
        creature_display_id_2 INTEGER NOT NULL,
        creature_display_id_3 INTEGER NOT NULL,
        preset_spell_id_0 INTEGER NOT NULL,
        preset_spell_id_1 INTEGER NOT NULL,
        preset_spell_id_2 INTEGER NOT NULL,
        preset_spell_id_3 INTEGER NOT NULL,
        preset_spell_id_4 INTEGER NOT NULL,
        preset_spell_id_5 INTEGER NOT NULL,
        preset_spell_id_6 INTEGER NOT NULL,
        preset_spell_id_7 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO SpellShapeshiftForm (
        id,
        bonus_action_bar,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        flags,
        creature_type,
        attack_icon_id,
        combat_round_time,
        creature_display_id_0,
        creature_display_id_1,
        creature_display_id_2,
        creature_display_id_3,
        preset_spell_id_0,
        preset_spell_id_1,
        preset_spell_id_2,
        preset_spell_id_3,
        preset_spell_id_4,
        preset_spell_id_5,
        preset_spell_id_6,
        preset_spell_id_7
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35
    );"
    ,
    "SELECT
        id,
        bonus_action_bar,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        flags,
        creature_type,
        attack_icon_id,
        combat_round_time,
        creature_display_id_0,
        creature_display_id_1,
        creature_display_id_2,
        creature_display_id_3,
        preset_spell_id_0,
        preset_spell_id_1,
        preset_spell_id_2,
        preset_spell_id_3,
        preset_spell_id_4,
        preset_spell_id_5,
        preset_spell_id_6,
        preset_spell_id_7
    FROM `SpellShapeshiftForm`;"
    )
}


pub(crate) fn spell_shapeshift_form_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_shapeshift_form::SpellShapeshiftForm, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_shapeshift_form::SpellShapeshiftFormRow {
            id: row.get::<_, i32>(0)?.into(),
            bonus_action_bar: row.get::<_, i32>(1)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
            flags: row.get::<_, i32>(19)?.into(),
            creature_type: row.get::<_, i32>(20)?.into(),
            attack_icon_id: row.get::<_, i32>(21)?.into(),
            combat_round_time: row.get::<_, i32>(22)?.into(),
            creature_display_id: [row.get::<_, i32>(23)?.into(), row.get::<_, i32>(24)?.into(), row.get::<_, i32>(25)?.into(), row.get::<_, i32>(26)?.into(),             ],
            preset_spell_id: [row.get::<_, i32>(27)?.into(), row.get::<_, i32>(28)?.into(), row.get::<_, i32>(29)?.into(), row.get::<_, i32>(30)?.into(), row.get::<_, i32>(31)?.into(), row.get::<_, i32>(32)?.into(), row.get::<_, i32>(33)?.into(), row.get::<_, i32>(34)?.into(),             ],
        });
    }
    Ok(spell_shapeshift_form::SpellShapeshiftForm { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisual() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisual (
        id INTEGER PRIMARY KEY NOT NULL,
        precast_kit INTEGER  NOT NULL,
        cast_kit INTEGER  NOT NULL,
        impact_kit INTEGER  NOT NULL,
        state_kit INTEGER  NOT NULL,
        state_done_kit INTEGER  NOT NULL,
        channel_kit INTEGER  NOT NULL,
        has_missile INTEGER  NOT NULL,
        missile_model INTEGER  NOT NULL,
        missile_path_type INTEGER  NOT NULL,
        missile_destination_attachment INTEGER  NOT NULL,
        missile_sound INTEGER  NOT NULL,
        anim_event_sound_id INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        caster_impact_kit INTEGER  NOT NULL,
        target_impact_kit INTEGER  NOT NULL,
        missile_attachment INTEGER  NOT NULL,
        missile_follow_ground_height INTEGER  NOT NULL,
        missile_follow_ground_drop_speed INTEGER  NOT NULL,
        missile_follow_ground_approach INTEGER  NOT NULL,
        missile_follow_ground_flags INTEGER  NOT NULL,
        missile_motion INTEGER  NOT NULL,
        missile_targeting_kit INTEGER  NOT NULL,
        instant_area_kit INTEGER  NOT NULL,
        impact_area_kit INTEGER  NOT NULL,
        persistent_area_kit INTEGER  NOT NULL,
        missile_cast_offset_0 REAL NOT NULL,
        missile_cast_offset_1 REAL NOT NULL,
        missile_cast_offset_2 REAL NOT NULL,
        missile_impact_offset_0 REAL NOT NULL,
        missile_impact_offset_1 REAL NOT NULL,
        missile_impact_offset_2 REAL NOT NULL
    );"
    ,
    "INSERT INTO SpellVisual (
        id,
        precast_kit,
        cast_kit,
        impact_kit,
        state_kit,
        state_done_kit,
        channel_kit,
        has_missile,
        missile_model,
        missile_path_type,
        missile_destination_attachment,
        missile_sound,
        anim_event_sound_id,
        flags,
        caster_impact_kit,
        target_impact_kit,
        missile_attachment,
        missile_follow_ground_height,
        missile_follow_ground_drop_speed,
        missile_follow_ground_approach,
        missile_follow_ground_flags,
        missile_motion,
        missile_targeting_kit,
        instant_area_kit,
        impact_area_kit,
        persistent_area_kit,
        missile_cast_offset_0,
        missile_cast_offset_1,
        missile_cast_offset_2,
        missile_impact_offset_0,
        missile_impact_offset_1,
        missile_impact_offset_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32
    );"
    ,
    "SELECT
        id,
        precast_kit,
        cast_kit,
        impact_kit,
        state_kit,
        state_done_kit,
        channel_kit,
        has_missile,
        missile_model,
        missile_path_type,
        missile_destination_attachment,
        missile_sound,
        anim_event_sound_id,
        flags,
        caster_impact_kit,
        target_impact_kit,
        missile_attachment,
        missile_follow_ground_height,
        missile_follow_ground_drop_speed,
        missile_follow_ground_approach,
        missile_follow_ground_flags,
        missile_motion,
        missile_targeting_kit,
        instant_area_kit,
        impact_area_kit,
        persistent_area_kit,
        missile_cast_offset_0,
        missile_cast_offset_1,
        missile_cast_offset_2,
        missile_impact_offset_0,
        missile_impact_offset_1,
        missile_impact_offset_2
    FROM `SpellVisual`;"
    )
}


pub(crate) fn spell_visual_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual::SpellVisual, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual::SpellVisualRow {
            id: row.get::<_, i32>(0)?.into(),
            precast_kit: row.get::<_, i32>(1)?.into(),
            cast_kit: row.get::<_, i32>(2)?.into(),
            impact_kit: row.get::<_, i32>(3)?.into(),
            state_kit: row.get::<_, i32>(4)?.into(),
            state_done_kit: row.get::<_, i32>(5)?.into(),
            channel_kit: row.get::<_, i32>(6)?.into(),
            has_missile: row.get::<_, i32>(7)?.into(),
            missile_model: row.get::<_, i32>(8)?.into(),
            missile_path_type: row.get::<_, i32>(9)?.into(),
            missile_destination_attachment: row.get::<_, i32>(10)?.into(),
            missile_sound: row.get::<_, i32>(11)?.into(),
            anim_event_sound_id: row.get::<_, i32>(12)?.into(),
            flags: row.get::<_, i32>(13)?.into(),
            caster_impact_kit: row.get::<_, i32>(14)?.into(),
            target_impact_kit: row.get::<_, i32>(15)?.into(),
            missile_attachment: row.get::<_, i32>(16)?.into(),
            missile_follow_ground_height: row.get::<_, i32>(17)?.into(),
            missile_follow_ground_drop_speed: row.get::<_, i32>(18)?.into(),
            missile_follow_ground_approach: row.get::<_, i32>(19)?.into(),
            missile_follow_ground_flags: row.get::<_, i32>(20)?.into(),
            missile_motion: row.get::<_, i32>(21)?.into(),
            missile_targeting_kit: row.get::<_, i32>(22)?.into(),
            instant_area_kit: row.get::<_, i32>(23)?.into(),
            impact_area_kit: row.get::<_, i32>(24)?.into(),
            persistent_area_kit: row.get::<_, i32>(25)?.into(),
            missile_cast_offset: [row.get::<_, f32>(26)?.into(), row.get::<_, f32>(27)?.into(), row.get::<_, f32>(28)?.into(),             ],
            missile_impact_offset: [row.get::<_, f32>(29)?.into(), row.get::<_, f32>(30)?.into(), row.get::<_, f32>(31)?.into(),             ],
        });
    }
    Ok(spell_visual::SpellVisual { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisualEffectName() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisualEffectName (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        file_name TEXT  NOT NULL,
        area_effect_size REAL  NOT NULL,
        scale REAL  NOT NULL,
        min_allowed_scale REAL  NOT NULL,
        max_allowed_scale REAL  NOT NULL
    );"
    ,
    "INSERT INTO SpellVisualEffectName (
        id,
        name,
        file_name,
        area_effect_size,
        scale,
        min_allowed_scale,
        max_allowed_scale
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        name,
        file_name,
        area_effect_size,
        scale,
        min_allowed_scale,
        max_allowed_scale
    FROM `SpellVisualEffectName`;"
    )
}


pub(crate) fn spell_visual_effect_name_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual_effect_name::SpellVisualEffectName, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual_effect_name::SpellVisualEffectNameRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            file_name: row.get::<_, String>(2)?.into(),
            area_effect_size: row.get::<_, f32>(3)?.into(),
            scale: row.get::<_, f32>(4)?.into(),
            min_allowed_scale: row.get::<_, f32>(5)?.into(),
            max_allowed_scale: row.get::<_, f32>(6)?.into(),
        });
    }
    Ok(spell_visual_effect_name::SpellVisualEffectName { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisualKit() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisualKit (
        id INTEGER PRIMARY KEY NOT NULL,
        start_anim_id INTEGER  NOT NULL,
        anim_id INTEGER  NOT NULL,
        head_effect INTEGER  NOT NULL,
        chest_effect INTEGER  NOT NULL,
        base_effect INTEGER  NOT NULL,
        left_hand_effect INTEGER  NOT NULL,
        right_hand_effect INTEGER  NOT NULL,
        breath_effect INTEGER  NOT NULL,
        left_weapon_effect INTEGER  NOT NULL,
        right_weapon_effect INTEGER  NOT NULL,
        special_effect_0 INTEGER NOT NULL,
        special_effect_1 INTEGER NOT NULL,
        special_effect_2 INTEGER NOT NULL,
        world_effect INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        shake_id INTEGER  NOT NULL,
        char_proc_0 INTEGER NOT NULL,
        char_proc_1 INTEGER NOT NULL,
        char_proc_2 INTEGER NOT NULL,
        char_proc_3 INTEGER NOT NULL,
        char_param_zero_0 REAL NOT NULL,
        char_param_zero_1 REAL NOT NULL,
        char_param_zero_2 REAL NOT NULL,
        char_param_zero_3 REAL NOT NULL,
        char_param_one_0 REAL NOT NULL,
        char_param_one_1 REAL NOT NULL,
        char_param_one_2 REAL NOT NULL,
        char_param_one_3 REAL NOT NULL,
        char_param_two_0 REAL NOT NULL,
        char_param_two_1 REAL NOT NULL,
        char_param_two_2 REAL NOT NULL,
        char_param_two_3 REAL NOT NULL,
        char_param_three_0 REAL NOT NULL,
        char_param_three_1 REAL NOT NULL,
        char_param_three_2 REAL NOT NULL,
        char_param_three_3 REAL NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellVisualKit (
        id,
        start_anim_id,
        anim_id,
        head_effect,
        chest_effect,
        base_effect,
        left_hand_effect,
        right_hand_effect,
        breath_effect,
        left_weapon_effect,
        right_weapon_effect,
        special_effect_0,
        special_effect_1,
        special_effect_2,
        world_effect,
        sound_id,
        shake_id,
        char_proc_0,
        char_proc_1,
        char_proc_2,
        char_proc_3,
        char_param_zero_0,
        char_param_zero_1,
        char_param_zero_2,
        char_param_zero_3,
        char_param_one_0,
        char_param_one_1,
        char_param_one_2,
        char_param_one_3,
        char_param_two_0,
        char_param_two_1,
        char_param_two_2,
        char_param_two_3,
        char_param_three_0,
        char_param_three_1,
        char_param_three_2,
        char_param_three_3,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38
    );"
    ,
    "SELECT
        id,
        start_anim_id,
        anim_id,
        head_effect,
        chest_effect,
        base_effect,
        left_hand_effect,
        right_hand_effect,
        breath_effect,
        left_weapon_effect,
        right_weapon_effect,
        special_effect_0,
        special_effect_1,
        special_effect_2,
        world_effect,
        sound_id,
        shake_id,
        char_proc_0,
        char_proc_1,
        char_proc_2,
        char_proc_3,
        char_param_zero_0,
        char_param_zero_1,
        char_param_zero_2,
        char_param_zero_3,
        char_param_one_0,
        char_param_one_1,
        char_param_one_2,
        char_param_one_3,
        char_param_two_0,
        char_param_two_1,
        char_param_two_2,
        char_param_two_3,
        char_param_three_0,
        char_param_three_1,
        char_param_three_2,
        char_param_three_3,
        flags
    FROM `SpellVisualKit`;"
    )
}


pub(crate) fn spell_visual_kit_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual_kit::SpellVisualKit, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual_kit::SpellVisualKitRow {
            id: row.get::<_, i32>(0)?.into(),
            start_anim_id: row.get::<_, i32>(1)?.into(),
            anim_id: row.get::<_, i32>(2)?.into(),
            head_effect: row.get::<_, i32>(3)?.into(),
            chest_effect: row.get::<_, i32>(4)?.into(),
            base_effect: row.get::<_, i32>(5)?.into(),
            left_hand_effect: row.get::<_, i32>(6)?.into(),
            right_hand_effect: row.get::<_, i32>(7)?.into(),
            breath_effect: row.get::<_, i32>(8)?.into(),
            left_weapon_effect: row.get::<_, i32>(9)?.into(),
            right_weapon_effect: row.get::<_, i32>(10)?.into(),
            special_effect: [row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            world_effect: row.get::<_, i32>(14)?.into(),
            sound_id: row.get::<_, i32>(15)?.into(),
            shake_id: row.get::<_, i32>(16)?.into(),
            char_proc: [row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(),             ],
            char_param_zero: [row.get::<_, f32>(21)?.into(), row.get::<_, f32>(22)?.into(), row.get::<_, f32>(23)?.into(), row.get::<_, f32>(24)?.into(),             ],
            char_param_one: [row.get::<_, f32>(25)?.into(), row.get::<_, f32>(26)?.into(), row.get::<_, f32>(27)?.into(), row.get::<_, f32>(28)?.into(),             ],
            char_param_two: [row.get::<_, f32>(29)?.into(), row.get::<_, f32>(30)?.into(), row.get::<_, f32>(31)?.into(), row.get::<_, f32>(32)?.into(),             ],
            char_param_three: [row.get::<_, f32>(33)?.into(), row.get::<_, f32>(34)?.into(), row.get::<_, f32>(35)?.into(), row.get::<_, f32>(36)?.into(),             ],
            flags: row.get::<_, i32>(37)?.into(),
        });
    }
    Ok(spell_visual_kit::SpellVisualKit { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisualKitAreaModel() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisualKitAreaModel (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        enum_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SpellVisualKitAreaModel (
        id,
        name,
        enum_id
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        name,
        enum_id
    FROM `SpellVisualKitAreaModel`;"
    )
}


pub(crate) fn spell_visual_kit_area_model_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual_kit_area_model::SpellVisualKitAreaModel, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual_kit_area_model::SpellVisualKitAreaModelRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            enum_id: row.get::<_, i32>(2)?.into(),
        });
    }
    Ok(spell_visual_kit_area_model::SpellVisualKitAreaModel { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisualKitModelAttach() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisualKitModelAttach (
        id INTEGER PRIMARY KEY NOT NULL,
        parent_spell_visual_kit_id INTEGER  NOT NULL,
        spell_visual_effect_name_id INTEGER  NOT NULL,
        attachment_id INTEGER  NOT NULL,
        offset_0 REAL NOT NULL,
        offset_1 REAL NOT NULL,
        offset_2 REAL NOT NULL,
        yaw REAL  NOT NULL,
        pitch REAL  NOT NULL,
        roll REAL  NOT NULL
    );"
    ,
    "INSERT INTO SpellVisualKitModelAttach (
        id,
        parent_spell_visual_kit_id,
        spell_visual_effect_name_id,
        attachment_id,
        offset_0,
        offset_1,
        offset_2,
        yaw,
        pitch,
        roll
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        parent_spell_visual_kit_id,
        spell_visual_effect_name_id,
        attachment_id,
        offset_0,
        offset_1,
        offset_2,
        yaw,
        pitch,
        roll
    FROM `SpellVisualKitModelAttach`;"
    )
}


pub(crate) fn spell_visual_kit_model_attach_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual_kit_model_attach::SpellVisualKitModelAttach, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual_kit_model_attach::SpellVisualKitModelAttachRow {
            id: row.get::<_, i32>(0)?.into(),
            parent_spell_visual_kit_id: row.get::<_, i32>(1)?.into(),
            spell_visual_effect_name_id: row.get::<_, i32>(2)?.into(),
            attachment_id: row.get::<_, i32>(3)?.into(),
            offset: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(),             ],
            yaw: row.get::<_, f32>(7)?.into(),
            pitch: row.get::<_, f32>(8)?.into(),
            roll: row.get::<_, f32>(9)?.into(),
        });
    }
    Ok(spell_visual_kit_model_attach::SpellVisualKitModelAttach { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SpellVisualPrecastTransitions() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SpellVisualPrecastTransitions (
        id INTEGER PRIMARY KEY NOT NULL,
        precast_load_anim_name TEXT  NOT NULL,
        precast_hold_anim_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO SpellVisualPrecastTransitions (
        id,
        precast_load_anim_name,
        precast_hold_anim_name
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        precast_load_anim_name,
        precast_hold_anim_name
    FROM `SpellVisualPrecastTransitions`;"
    )
}


pub(crate) fn spell_visual_precast_transitions_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<spell_visual_precast_transitions::SpellVisualPrecastTransitions, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(spell_visual_precast_transitions::SpellVisualPrecastTransitionsRow {
            id: row.get::<_, i32>(0)?.into(),
            precast_load_anim_name: row.get::<_, String>(1)?.into(),
            precast_hold_anim_name: row.get::<_, String>(2)?.into(),
        });
    }
    Ok(spell_visual_precast_transitions::SpellVisualPrecastTransitions { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn StableSlotPrices() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS StableSlotPrices (
        id INTEGER PRIMARY KEY NOT NULL,
        cost INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO StableSlotPrices (
        id,
        cost
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        cost
    FROM `StableSlotPrices`;"
    )
}


pub(crate) fn stable_slot_prices_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<stable_slot_prices::StableSlotPrices, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(stable_slot_prices::StableSlotPricesRow {
            id: row.get::<_, i32>(0)?.into(),
            cost: row.get::<_, i32>(1)?.into(),
        });
    }
    Ok(stable_slot_prices::StableSlotPrices { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Startup_Strings() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Startup_Strings (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        message_lang_en_gb TEXT NOT NULL,
        message_lang_ko_kr TEXT NOT NULL,
        message_lang_fr_fr TEXT NOT NULL,
        message_lang_de_de TEXT NOT NULL,
        message_lang_en_cn TEXT NOT NULL,
        message_lang_en_tw TEXT NOT NULL,
        message_lang_es_es TEXT NOT NULL,
        message_lang_es_mx TEXT NOT NULL,
        message_lang_ru_ru TEXT NOT NULL,
        message_lang_ja_jp TEXT NOT NULL,
        message_lang_pt_pt TEXT NOT NULL,
        message_lang_it_it TEXT NOT NULL,
        message_lang_unknown_12 TEXT NOT NULL,
        message_lang_unknown_13 TEXT NOT NULL,
        message_lang_unknown_14 TEXT NOT NULL,
        message_lang_unknown_15 TEXT NOT NULL,
        message_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Startup_Strings (
        id,
        name,
        message_lang_en_gb,
        message_lang_ko_kr,
        message_lang_fr_fr,
        message_lang_de_de,
        message_lang_en_cn,
        message_lang_en_tw,
        message_lang_es_es,
        message_lang_es_mx,
        message_lang_ru_ru,
        message_lang_ja_jp,
        message_lang_pt_pt,
        message_lang_it_it,
        message_lang_unknown_12,
        message_lang_unknown_13,
        message_lang_unknown_14,
        message_lang_unknown_15,
        message_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        name,
        message_lang_en_gb,
        message_lang_ko_kr,
        message_lang_fr_fr,
        message_lang_de_de,
        message_lang_en_cn,
        message_lang_en_tw,
        message_lang_es_es,
        message_lang_es_mx,
        message_lang_ru_ru,
        message_lang_ja_jp,
        message_lang_pt_pt,
        message_lang_it_it,
        message_lang_unknown_12,
        message_lang_unknown_13,
        message_lang_unknown_14,
        message_lang_unknown_15,
        message_lang_flags
    FROM `Startup_Strings`;"
    )
}


pub(crate) fn startup_strings_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<startup_strings::Startup_Strings, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(startup_strings::Startup_StringsRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            message_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
        });
    }
    Ok(startup_strings::Startup_Strings { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Stationery() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Stationery (
        id INTEGER PRIMARY KEY NOT NULL,
        item_id INTEGER  NOT NULL,
        texture TEXT  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO Stationery (
        id,
        item_id,
        texture,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        item_id,
        texture,
        flags
    FROM `Stationery`;"
    )
}


pub(crate) fn stationery_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<stationery::Stationery, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(stationery::StationeryRow {
            id: row.get::<_, i32>(0)?.into(),
            item_id: row.get::<_, i32>(1)?.into(),
            texture: row.get::<_, String>(2)?.into(),
            flags: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(stationery::Stationery { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn StringLookups() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS StringLookups (
        id INTEGER PRIMARY KEY NOT NULL,
        string TEXT  NOT NULL
    );"
    ,
    "INSERT INTO StringLookups (
        id,
        string
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        string
    FROM `StringLookups`;"
    )
}


pub(crate) fn string_lookups_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<string_lookups::StringLookups, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(string_lookups::StringLookupsRow {
            id: row.get::<_, i32>(0)?.into(),
            string: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(string_lookups::StringLookups { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn SummonProperties() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS SummonProperties (
        id INTEGER PRIMARY KEY NOT NULL,
        control INTEGER  NOT NULL,
        faction INTEGER  NOT NULL,
        title INTEGER  NOT NULL,
        slot INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO SummonProperties (
        id,
        control,
        faction,
        title,
        slot,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        id,
        control,
        faction,
        title,
        slot,
        flags
    FROM `SummonProperties`;"
    )
}


pub(crate) fn summon_properties_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<summon_properties::SummonProperties, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(summon_properties::SummonPropertiesRow {
            id: row.get::<_, i32>(0)?.into(),
            control: row.get::<_, i32>(1)?.into(),
            faction: row.get::<_, i32>(2)?.into(),
            title: row.get::<_, i32>(3)?.into(),
            slot: row.get::<_, i32>(4)?.into(),
            flags: row.get::<_, i32>(5)?.into(),
        });
    }
    Ok(summon_properties::SummonProperties { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Talent() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Talent (
        id INTEGER PRIMARY KEY NOT NULL,
        tab_id INTEGER  NOT NULL,
        tier_id INTEGER  NOT NULL,
        column_index INTEGER  NOT NULL,
        spell_rank_0 INTEGER NOT NULL,
        spell_rank_1 INTEGER NOT NULL,
        spell_rank_2 INTEGER NOT NULL,
        spell_rank_3 INTEGER NOT NULL,
        spell_rank_4 INTEGER NOT NULL,
        spell_rank_5 INTEGER NOT NULL,
        spell_rank_6 INTEGER NOT NULL,
        spell_rank_7 INTEGER NOT NULL,
        spell_rank_8 INTEGER NOT NULL,
        prereq_talent_0 INTEGER NOT NULL,
        prereq_talent_1 INTEGER NOT NULL,
        prereq_talent_2 INTEGER NOT NULL,
        prereq_rank_0 INTEGER NOT NULL,
        prereq_rank_1 INTEGER NOT NULL,
        prereq_rank_2 INTEGER NOT NULL,
        flags INTEGER  NOT NULL,
        required_spell_id INTEGER  NOT NULL,
        category_mask_0 INTEGER NOT NULL,
        category_mask_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Talent (
        id,
        tab_id,
        tier_id,
        column_index,
        spell_rank_0,
        spell_rank_1,
        spell_rank_2,
        spell_rank_3,
        spell_rank_4,
        spell_rank_5,
        spell_rank_6,
        spell_rank_7,
        spell_rank_8,
        prereq_talent_0,
        prereq_talent_1,
        prereq_talent_2,
        prereq_rank_0,
        prereq_rank_1,
        prereq_rank_2,
        flags,
        required_spell_id,
        category_mask_0,
        category_mask_1
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        tab_id,
        tier_id,
        column_index,
        spell_rank_0,
        spell_rank_1,
        spell_rank_2,
        spell_rank_3,
        spell_rank_4,
        spell_rank_5,
        spell_rank_6,
        spell_rank_7,
        spell_rank_8,
        prereq_talent_0,
        prereq_talent_1,
        prereq_talent_2,
        prereq_rank_0,
        prereq_rank_1,
        prereq_rank_2,
        flags,
        required_spell_id,
        category_mask_0,
        category_mask_1
    FROM `Talent`;"
    )
}


pub(crate) fn talent_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<talent::Talent, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(talent::TalentRow {
            id: row.get::<_, i32>(0)?.into(),
            tab_id: row.get::<_, i32>(1)?.into(),
            tier_id: row.get::<_, i32>(2)?.into(),
            column_index: row.get::<_, i32>(3)?.into(),
            spell_rank: [row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(),             ],
            prereq_talent: [row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(),             ],
            prereq_rank: [row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(),             ],
            flags: row.get::<_, i32>(19)?.into(),
            required_spell_id: row.get::<_, i32>(20)?.into(),
            category_mask: [row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
        });
    }
    Ok(talent::Talent { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TalentTab() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TalentTab (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        spell_icon_id INTEGER  NOT NULL,
        race_mask INTEGER  NOT NULL,
        class_mask INTEGER  NOT NULL,
        category_enum_id INTEGER  NOT NULL,
        order_index INTEGER  NOT NULL,
        background_file TEXT  NOT NULL
    );"
    ,
    "INSERT INTO TalentTab (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        spell_icon_id,
        race_mask,
        class_mask,
        category_enum_id,
        order_index,
        background_file
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        spell_icon_id,
        race_mask,
        class_mask,
        category_enum_id,
        order_index,
        background_file
    FROM `TalentTab`;"
    )
}


pub(crate) fn talent_tab_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<talent_tab::TalentTab, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(talent_tab::TalentTabRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            spell_icon_id: row.get::<_, i32>(18)?.into(),
            race_mask: row.get::<_, i32>(19)?.into(),
            class_mask: row.get::<_, i32>(20)?.into(),
            category_enum_id: row.get::<_, i32>(21)?.into(),
            order_index: row.get::<_, i32>(22)?.into(),
            background_file: row.get::<_, String>(23)?.into(),
        });
    }
    Ok(talent_tab::TalentTab { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TaxiNodes() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TaxiNodes (
        id INTEGER PRIMARY KEY NOT NULL,
        continent_id INTEGER  NOT NULL,
        pos_0 REAL NOT NULL,
        pos_1 REAL NOT NULL,
        pos_2 REAL NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        mount_creature_id_0 INTEGER NOT NULL,
        mount_creature_id_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO TaxiNodes (
        id,
        continent_id,
        pos_0,
        pos_1,
        pos_2,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        mount_creature_id_0,
        mount_creature_id_1
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24
    );"
    ,
    "SELECT
        id,
        continent_id,
        pos_0,
        pos_1,
        pos_2,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        mount_creature_id_0,
        mount_creature_id_1
    FROM `TaxiNodes`;"
    )
}


pub(crate) fn taxi_nodes_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<taxi_nodes::TaxiNodes, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(taxi_nodes::TaxiNodesRow {
            id: row.get::<_, i32>(0)?.into(),
            continent_id: row.get::<_, i32>(1)?.into(),
            pos: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(),             ],
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
            mount_creature_id: [row.get::<_, i32>(22)?.into(), row.get::<_, i32>(23)?.into(),             ],
        });
    }
    Ok(taxi_nodes::TaxiNodes { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TaxiPath() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TaxiPath (
        id INTEGER PRIMARY KEY NOT NULL,
        from_taxi_node INTEGER  NOT NULL,
        to_taxi_node INTEGER  NOT NULL,
        cost INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO TaxiPath (
        id,
        from_taxi_node,
        to_taxi_node,
        cost
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        from_taxi_node,
        to_taxi_node,
        cost
    FROM `TaxiPath`;"
    )
}


pub(crate) fn taxi_path_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<taxi_path::TaxiPath, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(taxi_path::TaxiPathRow {
            id: row.get::<_, i32>(0)?.into(),
            from_taxi_node: row.get::<_, i32>(1)?.into(),
            to_taxi_node: row.get::<_, i32>(2)?.into(),
            cost: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(taxi_path::TaxiPath { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TaxiPathNode() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TaxiPathNode (
        id INTEGER PRIMARY KEY NOT NULL,
        path_id INTEGER  NOT NULL,
        node_index INTEGER  NOT NULL,
        continent_id INTEGER  NOT NULL,
        loc_0 REAL NOT NULL,
        loc_1 REAL NOT NULL,
        loc_2 REAL NOT NULL,
        flags INTEGER  NOT NULL,
        delay INTEGER  NOT NULL,
        arrival_event_id INTEGER  NOT NULL,
        departure_event_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO TaxiPathNode (
        id,
        path_id,
        node_index,
        continent_id,
        loc_0,
        loc_1,
        loc_2,
        flags,
        delay,
        arrival_event_id,
        departure_event_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        path_id,
        node_index,
        continent_id,
        loc_0,
        loc_1,
        loc_2,
        flags,
        delay,
        arrival_event_id,
        departure_event_id
    FROM `TaxiPathNode`;"
    )
}


pub(crate) fn taxi_path_node_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<taxi_path_node::TaxiPathNode, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(taxi_path_node::TaxiPathNodeRow {
            id: row.get::<_, i32>(0)?.into(),
            path_id: row.get::<_, i32>(1)?.into(),
            node_index: row.get::<_, i32>(2)?.into(),
            continent_id: row.get::<_, i32>(3)?.into(),
            loc: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(),             ],
            flags: row.get::<_, i32>(7)?.into(),
            delay: row.get::<_, i32>(8)?.into(),
            arrival_event_id: row.get::<_, i32>(9)?.into(),
            departure_event_id: row.get::<_, i32>(10)?.into(),
        });
    }
    Ok(taxi_path_node::TaxiPathNode { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TeamContributionPoints() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TeamContributionPoints (
        id INTEGER PRIMARY KEY NOT NULL,
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO TeamContributionPoints (
        id,
        data
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        data
    FROM `TeamContributionPoints`;"
    )
}


pub(crate) fn team_contribution_points_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<team_contribution_points::TeamContributionPoints, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(team_contribution_points::TeamContributionPointsRow {
            id: row.get::<_, i32>(0)?.into(),
            data: row.get::<_, f32>(1)?.into(),
        });
    }
    Ok(team_contribution_points::TeamContributionPoints { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TerrainType() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TerrainType (
        terrain_id INTEGER  NOT NULL,
        terrain_desc TEXT  NOT NULL,
        footstep_spray_run INTEGER  NOT NULL,
        footstep_spray_walk INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL,
        flags INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO TerrainType (
        terrain_id,
        terrain_desc,
        footstep_spray_run,
        footstep_spray_walk,
        sound_id,
        flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6
    );"
    ,
    "SELECT
        terrain_id,
        terrain_desc,
        footstep_spray_run,
        footstep_spray_walk,
        sound_id,
        flags
    FROM `TerrainType`;"
    )
}


pub(crate) fn terrain_type_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<terrain_type::TerrainType, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(terrain_type::TerrainTypeRow {
            terrain_id: row.get::<_, i32>(0)?.into(),
            terrain_desc: row.get::<_, String>(1)?.into(),
            footstep_spray_run: row.get::<_, i32>(2)?.into(),
            footstep_spray_walk: row.get::<_, i32>(3)?.into(),
            sound_id: row.get::<_, i32>(4)?.into(),
            flags: row.get::<_, i32>(5)?.into(),
        });
    }
    Ok(terrain_type::TerrainType { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TerrainTypeSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TerrainTypeSounds (
        id INTEGER PRIMARY KEY NOT NULL
    );"
    ,
    "INSERT INTO TerrainTypeSounds (
        id
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        id
    FROM `TerrainTypeSounds`;"
    )
}


pub(crate) fn terrain_type_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<terrain_type_sounds::TerrainTypeSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(terrain_type_sounds::TerrainTypeSoundsRow {
            id: row.get::<_, i32>(0)?.into(),
        });
    }
    Ok(terrain_type_sounds::TerrainTypeSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TotemCategory() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TotemCategory (
        id INTEGER PRIMARY KEY NOT NULL,
        name_lang_en_gb TEXT NOT NULL,
        name_lang_ko_kr TEXT NOT NULL,
        name_lang_fr_fr TEXT NOT NULL,
        name_lang_de_de TEXT NOT NULL,
        name_lang_en_cn TEXT NOT NULL,
        name_lang_en_tw TEXT NOT NULL,
        name_lang_es_es TEXT NOT NULL,
        name_lang_es_mx TEXT NOT NULL,
        name_lang_ru_ru TEXT NOT NULL,
        name_lang_ja_jp TEXT NOT NULL,
        name_lang_pt_pt TEXT NOT NULL,
        name_lang_it_it TEXT NOT NULL,
        name_lang_unknown_12 TEXT NOT NULL,
        name_lang_unknown_13 TEXT NOT NULL,
        name_lang_unknown_14 TEXT NOT NULL,
        name_lang_unknown_15 TEXT NOT NULL,
        name_lang_flags INTEGER NOT NULL,
        totem_category_type INTEGER  NOT NULL,
        totem_category_mask INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO TotemCategory (
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        totem_category_type,
        totem_category_mask
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20
    );"
    ,
    "SELECT
        id,
        name_lang_en_gb,
        name_lang_ko_kr,
        name_lang_fr_fr,
        name_lang_de_de,
        name_lang_en_cn,
        name_lang_en_tw,
        name_lang_es_es,
        name_lang_es_mx,
        name_lang_ru_ru,
        name_lang_ja_jp,
        name_lang_pt_pt,
        name_lang_it_it,
        name_lang_unknown_12,
        name_lang_unknown_13,
        name_lang_unknown_14,
        name_lang_unknown_15,
        name_lang_flags,
        totem_category_type,
        totem_category_mask
    FROM `TotemCategory`;"
    )
}


pub(crate) fn totem_category_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<totem_category::TotemCategory, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(totem_category::TotemCategoryRow {
            id: row.get::<_, i32>(0)?.into(),
            name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(1)?.into(),
                ko_kr: row.get::<_, String>(2)?.into(),
                fr_fr: row.get::<_, String>(3)?.into(),
                de_de: row.get::<_, String>(4)?.into(),
                en_cn: row.get::<_, String>(5)?.into(),
                en_tw: row.get::<_, String>(6)?.into(),
                es_es: row.get::<_, String>(7)?.into(),
                es_mx: row.get::<_, String>(8)?.into(),
                ru_ru: row.get::<_, String>(9)?.into(),
                ja_jp: row.get::<_, String>(10)?.into(),
                pt_pt: row.get::<_, String>(11)?.into(),
                it_it: row.get::<_, String>(12)?.into(),
                unknown_12: row.get::<_, String>(13)?.into(),
                unknown_13: row.get::<_, String>(14)?.into(),
                unknown_14: row.get::<_, String>(15)?.into(),
                unknown_15: row.get::<_, String>(16)?.into(),
                flags: row.get::<_, u32>(17)?.into(),
            },
            totem_category_type: row.get::<_, i32>(18)?.into(),
            totem_category_mask: row.get::<_, i32>(19)?.into(),
        });
    }
    Ok(totem_category::TotemCategory { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TransportAnimation() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TransportAnimation (
        id INTEGER PRIMARY KEY NOT NULL,
        transport_id INTEGER  NOT NULL,
        time_index INTEGER  NOT NULL,
        pos_0 REAL NOT NULL,
        pos_1 REAL NOT NULL,
        pos_2 REAL NOT NULL,
        sequence_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO TransportAnimation (
        id,
        transport_id,
        time_index,
        pos_0,
        pos_1,
        pos_2,
        sequence_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        transport_id,
        time_index,
        pos_0,
        pos_1,
        pos_2,
        sequence_id
    FROM `TransportAnimation`;"
    )
}


pub(crate) fn transport_animation_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<transport_animation::TransportAnimation, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(transport_animation::TransportAnimationRow {
            id: row.get::<_, i32>(0)?.into(),
            transport_id: row.get::<_, i32>(1)?.into(),
            time_index: row.get::<_, i32>(2)?.into(),
            pos: [row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(),             ],
            sequence_id: row.get::<_, i32>(6)?.into(),
        });
    }
    Ok(transport_animation::TransportAnimation { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TransportPhysics() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TransportPhysics (
        id INTEGER PRIMARY KEY NOT NULL,
        wave_amp REAL  NOT NULL,
        wave_time_scale REAL  NOT NULL,
        roll_amp REAL  NOT NULL,
        roll_time_scale REAL  NOT NULL,
        pitch_amp REAL  NOT NULL,
        pitch_time_scale REAL  NOT NULL,
        max_bank REAL  NOT NULL,
        max_bank_turn_speed REAL  NOT NULL,
        speed_damp_thresh REAL  NOT NULL,
        speed_damp REAL  NOT NULL
    );"
    ,
    "INSERT INTO TransportPhysics (
        id,
        wave_amp,
        wave_time_scale,
        roll_amp,
        roll_time_scale,
        pitch_amp,
        pitch_time_scale,
        max_bank,
        max_bank_turn_speed,
        speed_damp_thresh,
        speed_damp
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        wave_amp,
        wave_time_scale,
        roll_amp,
        roll_time_scale,
        pitch_amp,
        pitch_time_scale,
        max_bank,
        max_bank_turn_speed,
        speed_damp_thresh,
        speed_damp
    FROM `TransportPhysics`;"
    )
}


pub(crate) fn transport_physics_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<transport_physics::TransportPhysics, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(transport_physics::TransportPhysicsRow {
            id: row.get::<_, i32>(0)?.into(),
            wave_amp: row.get::<_, f32>(1)?.into(),
            wave_time_scale: row.get::<_, f32>(2)?.into(),
            roll_amp: row.get::<_, f32>(3)?.into(),
            roll_time_scale: row.get::<_, f32>(4)?.into(),
            pitch_amp: row.get::<_, f32>(5)?.into(),
            pitch_time_scale: row.get::<_, f32>(6)?.into(),
            max_bank: row.get::<_, f32>(7)?.into(),
            max_bank_turn_speed: row.get::<_, f32>(8)?.into(),
            speed_damp_thresh: row.get::<_, f32>(9)?.into(),
            speed_damp: row.get::<_, f32>(10)?.into(),
        });
    }
    Ok(transport_physics::TransportPhysics { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn TransportRotation() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS TransportRotation (
        id INTEGER PRIMARY KEY NOT NULL,
        game_objects_id INTEGER  NOT NULL,
        time_index INTEGER  NOT NULL,
        rot_0 REAL NOT NULL,
        rot_1 REAL NOT NULL,
        rot_2 REAL NOT NULL,
        rot_3 REAL NOT NULL
    );"
    ,
    "INSERT INTO TransportRotation (
        id,
        game_objects_id,
        time_index,
        rot_0,
        rot_1,
        rot_2,
        rot_3
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        game_objects_id,
        time_index,
        rot_0,
        rot_1,
        rot_2,
        rot_3
    FROM `TransportRotation`;"
    )
}


pub(crate) fn transport_rotation_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<transport_rotation::TransportRotation, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(transport_rotation::TransportRotationRow {
            id: row.get::<_, i32>(0)?.into(),
            game_objects_id: row.get::<_, i32>(1)?.into(),
            time_index: row.get::<_, i32>(2)?.into(),
            rot: [row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(),             ],
        });
    }
    Ok(transport_rotation::TransportRotation { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn UISoundLookups() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS UISoundLookups (
        id INTEGER PRIMARY KEY NOT NULL,
        sound_id INTEGER  NOT NULL,
        sound_name TEXT  NOT NULL
    );"
    ,
    "INSERT INTO UISoundLookups (
        id,
        sound_id,
        sound_name
        ) VALUES (
        ?1,
        ?2,
        ?3
    );"
    ,
    "SELECT
        id,
        sound_id,
        sound_name
    FROM `UISoundLookups`;"
    )
}


pub(crate) fn ui_sound_lookups_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<ui_sound_lookups::UISoundLookups, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(ui_sound_lookups::UISoundLookupsRow {
            id: row.get::<_, i32>(0)?.into(),
            sound_id: row.get::<_, i32>(1)?.into(),
            sound_name: row.get::<_, String>(2)?.into(),
        });
    }
    Ok(ui_sound_lookups::UISoundLookups { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn UnitBlood() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS UnitBlood (
        id INTEGER PRIMARY KEY NOT NULL,
        combat_blood_spurt_front_0 INTEGER NOT NULL,
        combat_blood_spurt_front_1 INTEGER NOT NULL,
        combat_blood_spurt_back_0 INTEGER NOT NULL,
        combat_blood_spurt_back_1 INTEGER NOT NULL,
        ground_blood_0 TEXT NOT NULL,
        ground_blood_1 TEXT NOT NULL,
        ground_blood_2 TEXT NOT NULL,
        ground_blood_3 TEXT NOT NULL,
        ground_blood_4 TEXT NOT NULL
    );"
    ,
    "INSERT INTO UnitBlood (
        id,
        combat_blood_spurt_front_0,
        combat_blood_spurt_front_1,
        combat_blood_spurt_back_0,
        combat_blood_spurt_back_1,
        ground_blood_0,
        ground_blood_1,
        ground_blood_2,
        ground_blood_3,
        ground_blood_4
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        combat_blood_spurt_front_0,
        combat_blood_spurt_front_1,
        combat_blood_spurt_back_0,
        combat_blood_spurt_back_1,
        ground_blood_0,
        ground_blood_1,
        ground_blood_2,
        ground_blood_3,
        ground_blood_4
    FROM `UnitBlood`;"
    )
}


pub(crate) fn unit_blood_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<unit_blood::UnitBlood, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(unit_blood::UnitBloodRow {
            id: row.get::<_, i32>(0)?.into(),
            combat_blood_spurt_front: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(),             ],
            combat_blood_spurt_back: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            ground_blood: [row.get::<_, String>(5)?.into(), row.get::<_, String>(6)?.into(), row.get::<_, String>(7)?.into(), row.get::<_, String>(8)?.into(), row.get::<_, String>(9)?.into(),             ],
        });
    }
    Ok(unit_blood::UnitBlood { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn UnitBloodLevels() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS UnitBloodLevels (
        id INTEGER PRIMARY KEY NOT NULL,
        violencelevel_0 INTEGER NOT NULL,
        violencelevel_1 INTEGER NOT NULL,
        violencelevel_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO UnitBloodLevels (
        id,
        violencelevel_0,
        violencelevel_1,
        violencelevel_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        violencelevel_0,
        violencelevel_1,
        violencelevel_2
    FROM `UnitBloodLevels`;"
    )
}


pub(crate) fn unit_blood_levels_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<unit_blood_levels::UnitBloodLevels, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(unit_blood_levels::UnitBloodLevelsRow {
            id: row.get::<_, i32>(0)?.into(),
            violencelevel: [row.get::<_, i32>(1)?.into(), row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(),             ],
        });
    }
    Ok(unit_blood_levels::UnitBloodLevels { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Vehicle() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Vehicle (
        id INTEGER PRIMARY KEY NOT NULL,
        flags INTEGER  NOT NULL,
        turn_speed REAL  NOT NULL,
        pitch_speed REAL  NOT NULL,
        pitch_min REAL  NOT NULL,
        pitch_max REAL  NOT NULL,
        seat_id_0 INTEGER NOT NULL,
        seat_id_1 INTEGER NOT NULL,
        seat_id_2 INTEGER NOT NULL,
        seat_id_3 INTEGER NOT NULL,
        seat_id_4 INTEGER NOT NULL,
        seat_id_5 INTEGER NOT NULL,
        seat_id_6 INTEGER NOT NULL,
        seat_id_7 INTEGER NOT NULL,
        mouse_look_offset_pitch REAL  NOT NULL,
        camera_fade_dist_scalar_min REAL  NOT NULL,
        camera_fade_dist_scalar_max REAL  NOT NULL,
        camera_pitch_offset REAL  NOT NULL,
        facing_limit_right REAL  NOT NULL,
        facing_limit_left REAL  NOT NULL,
        mssl_trgt_turn_lingering REAL  NOT NULL,
        mssl_trgt_pitch_lingering REAL  NOT NULL,
        mssl_trgt_mouse_lingering REAL  NOT NULL,
        mssl_trgt_end_opacity REAL  NOT NULL,
        mssl_trgt_arc_speed REAL  NOT NULL,
        mssl_trgt_arc_repeat REAL  NOT NULL,
        mssl_trgt_arc_width REAL  NOT NULL,
        mssl_trgt_impact_radius_0 REAL NOT NULL,
        mssl_trgt_impact_radius_1 REAL NOT NULL,
        mssl_trgt_arc_texture TEXT  NOT NULL,
        mssl_trgt_impact_texture TEXT  NOT NULL,
        mssl_trgt_impact_model_0 TEXT NOT NULL,
        mssl_trgt_impact_model_1 TEXT NOT NULL,
        camera_yaw_offset REAL  NOT NULL,
        ui_locomotion_type INTEGER  NOT NULL,
        mssl_trgt_impact_tex_radius REAL  NOT NULL,
        vehicle_u_i_indicator_id INTEGER  NOT NULL,
        power_display_id_0 INTEGER NOT NULL,
        power_display_id_1 INTEGER NOT NULL,
        power_display_id_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO Vehicle (
        id,
        flags,
        turn_speed,
        pitch_speed,
        pitch_min,
        pitch_max,
        seat_id_0,
        seat_id_1,
        seat_id_2,
        seat_id_3,
        seat_id_4,
        seat_id_5,
        seat_id_6,
        seat_id_7,
        mouse_look_offset_pitch,
        camera_fade_dist_scalar_min,
        camera_fade_dist_scalar_max,
        camera_pitch_offset,
        facing_limit_right,
        facing_limit_left,
        mssl_trgt_turn_lingering,
        mssl_trgt_pitch_lingering,
        mssl_trgt_mouse_lingering,
        mssl_trgt_end_opacity,
        mssl_trgt_arc_speed,
        mssl_trgt_arc_repeat,
        mssl_trgt_arc_width,
        mssl_trgt_impact_radius_0,
        mssl_trgt_impact_radius_1,
        mssl_trgt_arc_texture,
        mssl_trgt_impact_texture,
        mssl_trgt_impact_model_0,
        mssl_trgt_impact_model_1,
        camera_yaw_offset,
        ui_locomotion_type,
        mssl_trgt_impact_tex_radius,
        vehicle_u_i_indicator_id,
        power_display_id_0,
        power_display_id_1,
        power_display_id_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40
    );"
    ,
    "SELECT
        id,
        flags,
        turn_speed,
        pitch_speed,
        pitch_min,
        pitch_max,
        seat_id_0,
        seat_id_1,
        seat_id_2,
        seat_id_3,
        seat_id_4,
        seat_id_5,
        seat_id_6,
        seat_id_7,
        mouse_look_offset_pitch,
        camera_fade_dist_scalar_min,
        camera_fade_dist_scalar_max,
        camera_pitch_offset,
        facing_limit_right,
        facing_limit_left,
        mssl_trgt_turn_lingering,
        mssl_trgt_pitch_lingering,
        mssl_trgt_mouse_lingering,
        mssl_trgt_end_opacity,
        mssl_trgt_arc_speed,
        mssl_trgt_arc_repeat,
        mssl_trgt_arc_width,
        mssl_trgt_impact_radius_0,
        mssl_trgt_impact_radius_1,
        mssl_trgt_arc_texture,
        mssl_trgt_impact_texture,
        mssl_trgt_impact_model_0,
        mssl_trgt_impact_model_1,
        camera_yaw_offset,
        ui_locomotion_type,
        mssl_trgt_impact_tex_radius,
        vehicle_u_i_indicator_id,
        power_display_id_0,
        power_display_id_1,
        power_display_id_2
    FROM `Vehicle`;"
    )
}


pub(crate) fn vehicle_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<vehicle::Vehicle, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(vehicle::VehicleRow {
            id: row.get::<_, i32>(0)?.into(),
            flags: row.get::<_, i32>(1)?.into(),
            turn_speed: row.get::<_, f32>(2)?.into(),
            pitch_speed: row.get::<_, f32>(3)?.into(),
            pitch_min: row.get::<_, f32>(4)?.into(),
            pitch_max: row.get::<_, f32>(5)?.into(),
            seat_id: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(), row.get::<_, i32>(13)?.into(),             ],
            mouse_look_offset_pitch: row.get::<_, f32>(14)?.into(),
            camera_fade_dist_scalar_min: row.get::<_, f32>(15)?.into(),
            camera_fade_dist_scalar_max: row.get::<_, f32>(16)?.into(),
            camera_pitch_offset: row.get::<_, f32>(17)?.into(),
            facing_limit_right: row.get::<_, f32>(18)?.into(),
            facing_limit_left: row.get::<_, f32>(19)?.into(),
            mssl_trgt_turn_lingering: row.get::<_, f32>(20)?.into(),
            mssl_trgt_pitch_lingering: row.get::<_, f32>(21)?.into(),
            mssl_trgt_mouse_lingering: row.get::<_, f32>(22)?.into(),
            mssl_trgt_end_opacity: row.get::<_, f32>(23)?.into(),
            mssl_trgt_arc_speed: row.get::<_, f32>(24)?.into(),
            mssl_trgt_arc_repeat: row.get::<_, f32>(25)?.into(),
            mssl_trgt_arc_width: row.get::<_, f32>(26)?.into(),
            mssl_trgt_impact_radius: [row.get::<_, f32>(27)?.into(), row.get::<_, f32>(28)?.into(),             ],
            mssl_trgt_arc_texture: row.get::<_, String>(29)?.into(),
            mssl_trgt_impact_texture: row.get::<_, String>(30)?.into(),
            mssl_trgt_impact_model: [row.get::<_, String>(31)?.into(), row.get::<_, String>(32)?.into(),             ],
            camera_yaw_offset: row.get::<_, f32>(33)?.into(),
            ui_locomotion_type: row.get::<_, i32>(34)?.into(),
            mssl_trgt_impact_tex_radius: row.get::<_, f32>(35)?.into(),
            vehicle_u_i_indicator_id: row.get::<_, i32>(36)?.into(),
            power_display_id: [row.get::<_, i32>(37)?.into(), row.get::<_, i32>(38)?.into(), row.get::<_, i32>(39)?.into(),             ],
        });
    }
    Ok(vehicle::Vehicle { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn VehicleSeat() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS VehicleSeat (
        id INTEGER PRIMARY KEY NOT NULL,
        field_3_3_5_12213_001 REAL  NOT NULL,
        attachment_id INTEGER  NOT NULL,
        attachment_offset_0 REAL NOT NULL,
        attachment_offset_1 REAL NOT NULL,
        attachment_offset_2 REAL NOT NULL,
        field_3_3_5_12213_004 REAL  NOT NULL,
        enter_speed REAL  NOT NULL,
        enter_gravity REAL  NOT NULL,
        enter_min_duration REAL  NOT NULL,
        enter_max_duration REAL  NOT NULL,
        enter_min_arc_height REAL  NOT NULL,
        enter_max_arc_height REAL  NOT NULL,
        enter_anim_start INTEGER  NOT NULL,
        enter_anim_loop INTEGER  NOT NULL,
        ride_anim_start INTEGER  NOT NULL,
        ride_anim_loop INTEGER  NOT NULL,
        ride_upper_anim_start INTEGER  NOT NULL,
        ride_upper_anim_loop INTEGER  NOT NULL,
        field_3_3_5_12213_017 REAL  NOT NULL,
        exit_speed REAL  NOT NULL,
        exit_gravity REAL  NOT NULL,
        exit_min_duration REAL  NOT NULL,
        exit_max_duration REAL  NOT NULL,
        exit_min_arc_height REAL  NOT NULL,
        exit_max_arc_height REAL  NOT NULL,
        exit_anim_start INTEGER  NOT NULL,
        exit_anim_loop INTEGER  NOT NULL,
        exit_anim_end INTEGER  NOT NULL,
        field_3_3_5_12213_027 REAL  NOT NULL,
        passenger_pitch REAL  NOT NULL,
        field_3_3_5_12213_029 REAL  NOT NULL,
        passenger_attachment_id INTEGER  NOT NULL,
        vehicle_enter_anim INTEGER  NOT NULL,
        vehicle_exit_anim INTEGER  NOT NULL,
        vehicle_ride_anim_loop INTEGER  NOT NULL,
        field_3_3_5_12213_034 INTEGER  NOT NULL,
        vehicle_exit_anim_bone INTEGER  NOT NULL,
        vehicle_enter_anim_bone INTEGER  NOT NULL,
        field_3_3_5_12213_037 REAL  NOT NULL,
        field_3_3_5_12213_038 REAL  NOT NULL,
        vehicle_ability_display INTEGER  NOT NULL,
        enter_u_i_sound_id INTEGER  NOT NULL,
        field_3_3_5_12213_041 INTEGER  NOT NULL,
        ui_skin INTEGER  NOT NULL,
        field_3_3_5_12213_043 REAL  NOT NULL,
        field_3_3_5_12213_044 REAL  NOT NULL,
        field_3_3_5_12213_045 REAL  NOT NULL,
        field_3_3_5_12213_046 INTEGER  NOT NULL,
        field_3_3_5_12213_047 REAL  NOT NULL,
        field_3_3_5_12213_048 REAL  NOT NULL,
        field_3_3_5_12213_049 REAL  NOT NULL,
        field_3_3_5_12213_050 REAL  NOT NULL,
        field_3_3_5_12213_051 REAL  NOT NULL,
        field_3_3_5_12213_052 REAL  NOT NULL,
        field_3_3_5_12213_053 REAL  NOT NULL,
        field_3_3_5_12213_054 REAL  NOT NULL,
        field_3_3_5_12213_055 REAL  NOT NULL
    );"
    ,
    "INSERT INTO VehicleSeat (
        id,
        field_3_3_5_12213_001,
        attachment_id,
        attachment_offset_0,
        attachment_offset_1,
        attachment_offset_2,
        field_3_3_5_12213_004,
        enter_speed,
        enter_gravity,
        enter_min_duration,
        enter_max_duration,
        enter_min_arc_height,
        enter_max_arc_height,
        enter_anim_start,
        enter_anim_loop,
        ride_anim_start,
        ride_anim_loop,
        ride_upper_anim_start,
        ride_upper_anim_loop,
        field_3_3_5_12213_017,
        exit_speed,
        exit_gravity,
        exit_min_duration,
        exit_max_duration,
        exit_min_arc_height,
        exit_max_arc_height,
        exit_anim_start,
        exit_anim_loop,
        exit_anim_end,
        field_3_3_5_12213_027,
        passenger_pitch,
        field_3_3_5_12213_029,
        passenger_attachment_id,
        vehicle_enter_anim,
        vehicle_exit_anim,
        vehicle_ride_anim_loop,
        field_3_3_5_12213_034,
        vehicle_exit_anim_bone,
        vehicle_enter_anim_bone,
        field_3_3_5_12213_037,
        field_3_3_5_12213_038,
        vehicle_ability_display,
        enter_u_i_sound_id,
        field_3_3_5_12213_041,
        ui_skin,
        field_3_3_5_12213_043,
        field_3_3_5_12213_044,
        field_3_3_5_12213_045,
        field_3_3_5_12213_046,
        field_3_3_5_12213_047,
        field_3_3_5_12213_048,
        field_3_3_5_12213_049,
        field_3_3_5_12213_050,
        field_3_3_5_12213_051,
        field_3_3_5_12213_052,
        field_3_3_5_12213_053,
        field_3_3_5_12213_054,
        field_3_3_5_12213_055
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58
    );"
    ,
    "SELECT
        id,
        field_3_3_5_12213_001,
        attachment_id,
        attachment_offset_0,
        attachment_offset_1,
        attachment_offset_2,
        field_3_3_5_12213_004,
        enter_speed,
        enter_gravity,
        enter_min_duration,
        enter_max_duration,
        enter_min_arc_height,
        enter_max_arc_height,
        enter_anim_start,
        enter_anim_loop,
        ride_anim_start,
        ride_anim_loop,
        ride_upper_anim_start,
        ride_upper_anim_loop,
        field_3_3_5_12213_017,
        exit_speed,
        exit_gravity,
        exit_min_duration,
        exit_max_duration,
        exit_min_arc_height,
        exit_max_arc_height,
        exit_anim_start,
        exit_anim_loop,
        exit_anim_end,
        field_3_3_5_12213_027,
        passenger_pitch,
        field_3_3_5_12213_029,
        passenger_attachment_id,
        vehicle_enter_anim,
        vehicle_exit_anim,
        vehicle_ride_anim_loop,
        field_3_3_5_12213_034,
        vehicle_exit_anim_bone,
        vehicle_enter_anim_bone,
        field_3_3_5_12213_037,
        field_3_3_5_12213_038,
        vehicle_ability_display,
        enter_u_i_sound_id,
        field_3_3_5_12213_041,
        ui_skin,
        field_3_3_5_12213_043,
        field_3_3_5_12213_044,
        field_3_3_5_12213_045,
        field_3_3_5_12213_046,
        field_3_3_5_12213_047,
        field_3_3_5_12213_048,
        field_3_3_5_12213_049,
        field_3_3_5_12213_050,
        field_3_3_5_12213_051,
        field_3_3_5_12213_052,
        field_3_3_5_12213_053,
        field_3_3_5_12213_054,
        field_3_3_5_12213_055
    FROM `VehicleSeat`;"
    )
}


pub(crate) fn vehicle_seat_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<vehicle_seat::VehicleSeat, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(vehicle_seat::VehicleSeatRow {
            id: row.get::<_, i32>(0)?.into(),
            field_3_3_5_12213_001: row.get::<_, f32>(1)?.into(),
            attachment_id: row.get::<_, i32>(2)?.into(),
            attachment_offset: [row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(),             ],
            field_3_3_5_12213_004: row.get::<_, f32>(6)?.into(),
            enter_speed: row.get::<_, f32>(7)?.into(),
            enter_gravity: row.get::<_, f32>(8)?.into(),
            enter_min_duration: row.get::<_, f32>(9)?.into(),
            enter_max_duration: row.get::<_, f32>(10)?.into(),
            enter_min_arc_height: row.get::<_, f32>(11)?.into(),
            enter_max_arc_height: row.get::<_, f32>(12)?.into(),
            enter_anim_start: row.get::<_, i32>(13)?.into(),
            enter_anim_loop: row.get::<_, i32>(14)?.into(),
            ride_anim_start: row.get::<_, i32>(15)?.into(),
            ride_anim_loop: row.get::<_, i32>(16)?.into(),
            ride_upper_anim_start: row.get::<_, i32>(17)?.into(),
            ride_upper_anim_loop: row.get::<_, i32>(18)?.into(),
            field_3_3_5_12213_017: row.get::<_, f32>(19)?.into(),
            exit_speed: row.get::<_, f32>(20)?.into(),
            exit_gravity: row.get::<_, f32>(21)?.into(),
            exit_min_duration: row.get::<_, f32>(22)?.into(),
            exit_max_duration: row.get::<_, f32>(23)?.into(),
            exit_min_arc_height: row.get::<_, f32>(24)?.into(),
            exit_max_arc_height: row.get::<_, f32>(25)?.into(),
            exit_anim_start: row.get::<_, i32>(26)?.into(),
            exit_anim_loop: row.get::<_, i32>(27)?.into(),
            exit_anim_end: row.get::<_, i32>(28)?.into(),
            field_3_3_5_12213_027: row.get::<_, f32>(29)?.into(),
            passenger_pitch: row.get::<_, f32>(30)?.into(),
            field_3_3_5_12213_029: row.get::<_, f32>(31)?.into(),
            passenger_attachment_id: row.get::<_, i32>(32)?.into(),
            vehicle_enter_anim: row.get::<_, i32>(33)?.into(),
            vehicle_exit_anim: row.get::<_, i32>(34)?.into(),
            vehicle_ride_anim_loop: row.get::<_, i32>(35)?.into(),
            field_3_3_5_12213_034: row.get::<_, i32>(36)?.into(),
            vehicle_exit_anim_bone: row.get::<_, i32>(37)?.into(),
            vehicle_enter_anim_bone: row.get::<_, i32>(38)?.into(),
            field_3_3_5_12213_037: row.get::<_, f32>(39)?.into(),
            field_3_3_5_12213_038: row.get::<_, f32>(40)?.into(),
            vehicle_ability_display: row.get::<_, i32>(41)?.into(),
            enter_u_i_sound_id: row.get::<_, i32>(42)?.into(),
            field_3_3_5_12213_041: row.get::<_, i32>(43)?.into(),
            ui_skin: row.get::<_, i32>(44)?.into(),
            field_3_3_5_12213_043: row.get::<_, f32>(45)?.into(),
            field_3_3_5_12213_044: row.get::<_, f32>(46)?.into(),
            field_3_3_5_12213_045: row.get::<_, f32>(47)?.into(),
            field_3_3_5_12213_046: row.get::<_, i32>(48)?.into(),
            field_3_3_5_12213_047: row.get::<_, f32>(49)?.into(),
            field_3_3_5_12213_048: row.get::<_, f32>(50)?.into(),
            field_3_3_5_12213_049: row.get::<_, f32>(51)?.into(),
            field_3_3_5_12213_050: row.get::<_, f32>(52)?.into(),
            field_3_3_5_12213_051: row.get::<_, f32>(53)?.into(),
            field_3_3_5_12213_052: row.get::<_, f32>(54)?.into(),
            field_3_3_5_12213_053: row.get::<_, f32>(55)?.into(),
            field_3_3_5_12213_054: row.get::<_, f32>(56)?.into(),
            field_3_3_5_12213_055: row.get::<_, f32>(57)?.into(),
        });
    }
    Ok(vehicle_seat::VehicleSeat { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn VehicleUIIndSeat() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS VehicleUIIndSeat (
        id INTEGER PRIMARY KEY NOT NULL,
        vehicle_u_i_indicator_id INTEGER  NOT NULL,
        virtual_seat_index INTEGER  NOT NULL,
        x_pos REAL  NOT NULL,
        y_pos REAL  NOT NULL
    );"
    ,
    "INSERT INTO VehicleUIIndSeat (
        id,
        vehicle_u_i_indicator_id,
        virtual_seat_index,
        x_pos,
        y_pos
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        vehicle_u_i_indicator_id,
        virtual_seat_index,
        x_pos,
        y_pos
    FROM `VehicleUIIndSeat`;"
    )
}


pub(crate) fn vehicle_ui_ind_seat_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<vehicle_ui_ind_seat::VehicleUIIndSeat, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(vehicle_ui_ind_seat::VehicleUIIndSeatRow {
            id: row.get::<_, i32>(0)?.into(),
            vehicle_u_i_indicator_id: row.get::<_, i32>(1)?.into(),
            virtual_seat_index: row.get::<_, i32>(2)?.into(),
            x_pos: row.get::<_, f32>(3)?.into(),
            y_pos: row.get::<_, f32>(4)?.into(),
        });
    }
    Ok(vehicle_ui_ind_seat::VehicleUIIndSeat { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn VehicleUIIndicator() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS VehicleUIIndicator (
        id INTEGER PRIMARY KEY NOT NULL,
        background_texture TEXT  NOT NULL
    );"
    ,
    "INSERT INTO VehicleUIIndicator (
        id,
        background_texture
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        background_texture
    FROM `VehicleUIIndicator`;"
    )
}


pub(crate) fn vehicle_ui_indicator_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<vehicle_ui_indicator::VehicleUIIndicator, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(vehicle_ui_indicator::VehicleUIIndicatorRow {
            id: row.get::<_, i32>(0)?.into(),
            background_texture: row.get::<_, String>(1)?.into(),
        });
    }
    Ok(vehicle_ui_indicator::VehicleUIIndicator { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn VideoHardware() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS VideoHardware (
        id INTEGER PRIMARY KEY NOT NULL,
        vendor_id INTEGER  NOT NULL,
        device_id INTEGER  NOT NULL,
        farclip_idx INTEGER  NOT NULL,
        terrain_l_o_d_dist_idx INTEGER  NOT NULL,
        terrain_shadow_l_o_d INTEGER  NOT NULL,
        detail_doodad_density_idx INTEGER  NOT NULL,
        detail_doodad_alpha INTEGER  NOT NULL,
        animating_doodad_idx INTEGER  NOT NULL,
        trilinear INTEGER  NOT NULL,
        num_lights INTEGER  NOT NULL,
        specularity INTEGER  NOT NULL,
        water_l_o_d_idx INTEGER  NOT NULL,
        particle_density_idx INTEGER  NOT NULL,
        unit_draw_dist_idx INTEGER  NOT NULL,
        small_cull_dist_idx INTEGER  NOT NULL,
        resolution_idx INTEGER  NOT NULL,
        base_mip_level INTEGER  NOT NULL,
        ogl_overrides TEXT  NOT NULL,
        d3d_overrides TEXT  NOT NULL,
        fix_lag INTEGER  NOT NULL,
        multisample INTEGER  NOT NULL,
        atlasdisable INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO VideoHardware (
        id,
        vendor_id,
        device_id,
        farclip_idx,
        terrain_l_o_d_dist_idx,
        terrain_shadow_l_o_d,
        detail_doodad_density_idx,
        detail_doodad_alpha,
        animating_doodad_idx,
        trilinear,
        num_lights,
        specularity,
        water_l_o_d_idx,
        particle_density_idx,
        unit_draw_dist_idx,
        small_cull_dist_idx,
        resolution_idx,
        base_mip_level,
        ogl_overrides,
        d3d_overrides,
        fix_lag,
        multisample,
        atlasdisable
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        vendor_id,
        device_id,
        farclip_idx,
        terrain_l_o_d_dist_idx,
        terrain_shadow_l_o_d,
        detail_doodad_density_idx,
        detail_doodad_alpha,
        animating_doodad_idx,
        trilinear,
        num_lights,
        specularity,
        water_l_o_d_idx,
        particle_density_idx,
        unit_draw_dist_idx,
        small_cull_dist_idx,
        resolution_idx,
        base_mip_level,
        ogl_overrides,
        d3d_overrides,
        fix_lag,
        multisample,
        atlasdisable
    FROM `VideoHardware`;"
    )
}


pub(crate) fn video_hardware_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<video_hardware::VideoHardware, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(video_hardware::VideoHardwareRow {
            id: row.get::<_, i32>(0)?.into(),
            vendor_id: row.get::<_, i32>(1)?.into(),
            device_id: row.get::<_, i32>(2)?.into(),
            farclip_idx: row.get::<_, i32>(3)?.into(),
            terrain_l_o_d_dist_idx: row.get::<_, i32>(4)?.into(),
            terrain_shadow_l_o_d: row.get::<_, i32>(5)?.into(),
            detail_doodad_density_idx: row.get::<_, i32>(6)?.into(),
            detail_doodad_alpha: row.get::<_, i32>(7)?.into(),
            animating_doodad_idx: row.get::<_, i32>(8)?.into(),
            trilinear: row.get::<_, i32>(9)?.into(),
            num_lights: row.get::<_, i32>(10)?.into(),
            specularity: row.get::<_, i32>(11)?.into(),
            water_l_o_d_idx: row.get::<_, i32>(12)?.into(),
            particle_density_idx: row.get::<_, i32>(13)?.into(),
            unit_draw_dist_idx: row.get::<_, i32>(14)?.into(),
            small_cull_dist_idx: row.get::<_, i32>(15)?.into(),
            resolution_idx: row.get::<_, i32>(16)?.into(),
            base_mip_level: row.get::<_, i32>(17)?.into(),
            ogl_overrides: row.get::<_, String>(18)?.into(),
            d3d_overrides: row.get::<_, String>(19)?.into(),
            fix_lag: row.get::<_, i32>(20)?.into(),
            multisample: row.get::<_, i32>(21)?.into(),
            atlasdisable: row.get::<_, i32>(22)?.into(),
        });
    }
    Ok(video_hardware::VideoHardware { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn VocalUISounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS VocalUISounds (
        id INTEGER PRIMARY KEY NOT NULL,
        vocal_u_i_enum INTEGER  NOT NULL,
        race_id INTEGER  NOT NULL,
        normal_sound_id_0 INTEGER NOT NULL,
        normal_sound_id_1 INTEGER NOT NULL,
        pissed_sound_id_0 INTEGER NOT NULL,
        pissed_sound_id_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO VocalUISounds (
        id,
        vocal_u_i_enum,
        race_id,
        normal_sound_id_0,
        normal_sound_id_1,
        pissed_sound_id_0,
        pissed_sound_id_1
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7
    );"
    ,
    "SELECT
        id,
        vocal_u_i_enum,
        race_id,
        normal_sound_id_0,
        normal_sound_id_1,
        pissed_sound_id_0,
        pissed_sound_id_1
    FROM `VocalUISounds`;"
    )
}


pub(crate) fn vocal_ui_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<vocal_ui_sounds::VocalUISounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(vocal_ui_sounds::VocalUISoundsRow {
            id: row.get::<_, i32>(0)?.into(),
            vocal_u_i_enum: row.get::<_, i32>(1)?.into(),
            race_id: row.get::<_, i32>(2)?.into(),
            normal_sound_id: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(),             ],
            pissed_sound_id: [row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(),             ],
        });
    }
    Ok(vocal_ui_sounds::VocalUISounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WMOAreaTable() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WMOAreaTable (
        id INTEGER PRIMARY KEY NOT NULL,
        w_m_o_id INTEGER  NOT NULL,
        name_set_id INTEGER  NOT NULL,
        w_m_o_group_id INTEGER  NOT NULL,
        sound_provider_pref INTEGER  NOT NULL,
        sound_provider_pref_underwater INTEGER  NOT NULL,
        ambience_id INTEGER  NOT NULL,
        zone_music INTEGER  NOT NULL,
        intro_sound INTEGER  NOT NULL,
        flags INTEGER  NOT NULL,
        area_table_id INTEGER  NOT NULL,
        area_name_lang_en_gb TEXT NOT NULL,
        area_name_lang_ko_kr TEXT NOT NULL,
        area_name_lang_fr_fr TEXT NOT NULL,
        area_name_lang_de_de TEXT NOT NULL,
        area_name_lang_en_cn TEXT NOT NULL,
        area_name_lang_en_tw TEXT NOT NULL,
        area_name_lang_es_es TEXT NOT NULL,
        area_name_lang_es_mx TEXT NOT NULL,
        area_name_lang_ru_ru TEXT NOT NULL,
        area_name_lang_ja_jp TEXT NOT NULL,
        area_name_lang_pt_pt TEXT NOT NULL,
        area_name_lang_it_it TEXT NOT NULL,
        area_name_lang_unknown_12 TEXT NOT NULL,
        area_name_lang_unknown_13 TEXT NOT NULL,
        area_name_lang_unknown_14 TEXT NOT NULL,
        area_name_lang_unknown_15 TEXT NOT NULL,
        area_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO WMOAreaTable (
        id,
        w_m_o_id,
        name_set_id,
        w_m_o_group_id,
        sound_provider_pref,
        sound_provider_pref_underwater,
        ambience_id,
        zone_music,
        intro_sound,
        flags,
        area_table_id,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28
    );"
    ,
    "SELECT
        id,
        w_m_o_id,
        name_set_id,
        w_m_o_group_id,
        sound_provider_pref,
        sound_provider_pref_underwater,
        ambience_id,
        zone_music,
        intro_sound,
        flags,
        area_table_id,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags
    FROM `WMOAreaTable`;"
    )
}


pub(crate) fn wmo_area_table_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<wmo_area_table::WMOAreaTable, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(wmo_area_table::WMOAreaTableRow {
            id: row.get::<_, i32>(0)?.into(),
            w_m_o_id: row.get::<_, i32>(1)?.into(),
            name_set_id: row.get::<_, i32>(2)?.into(),
            w_m_o_group_id: row.get::<_, i32>(3)?.into(),
            sound_provider_pref: row.get::<_, i32>(4)?.into(),
            sound_provider_pref_underwater: row.get::<_, i32>(5)?.into(),
            ambience_id: row.get::<_, i32>(6)?.into(),
            zone_music: row.get::<_, i32>(7)?.into(),
            intro_sound: row.get::<_, i32>(8)?.into(),
            flags: row.get::<_, i32>(9)?.into(),
            area_table_id: row.get::<_, i32>(10)?.into(),
            area_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(11)?.into(),
                ko_kr: row.get::<_, String>(12)?.into(),
                fr_fr: row.get::<_, String>(13)?.into(),
                de_de: row.get::<_, String>(14)?.into(),
                en_cn: row.get::<_, String>(15)?.into(),
                en_tw: row.get::<_, String>(16)?.into(),
                es_es: row.get::<_, String>(17)?.into(),
                es_mx: row.get::<_, String>(18)?.into(),
                ru_ru: row.get::<_, String>(19)?.into(),
                ja_jp: row.get::<_, String>(20)?.into(),
                pt_pt: row.get::<_, String>(21)?.into(),
                it_it: row.get::<_, String>(22)?.into(),
                unknown_12: row.get::<_, String>(23)?.into(),
                unknown_13: row.get::<_, String>(24)?.into(),
                unknown_14: row.get::<_, String>(25)?.into(),
                unknown_15: row.get::<_, String>(26)?.into(),
                flags: row.get::<_, u32>(27)?.into(),
            },
        });
    }
    Ok(wmo_area_table::WMOAreaTable { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WeaponImpactSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WeaponImpactSounds (
        id INTEGER PRIMARY KEY NOT NULL,
        weapon_sub_class_id INTEGER  NOT NULL,
        parry_sound_type INTEGER  NOT NULL,
        impact_sound_id_0 INTEGER NOT NULL,
        impact_sound_id_1 INTEGER NOT NULL,
        impact_sound_id_2 INTEGER NOT NULL,
        impact_sound_id_3 INTEGER NOT NULL,
        impact_sound_id_4 INTEGER NOT NULL,
        impact_sound_id_5 INTEGER NOT NULL,
        impact_sound_id_6 INTEGER NOT NULL,
        impact_sound_id_7 INTEGER NOT NULL,
        impact_sound_id_8 INTEGER NOT NULL,
        impact_sound_id_9 INTEGER NOT NULL,
        crit_impact_sound_id_0 INTEGER NOT NULL,
        crit_impact_sound_id_1 INTEGER NOT NULL,
        crit_impact_sound_id_2 INTEGER NOT NULL,
        crit_impact_sound_id_3 INTEGER NOT NULL,
        crit_impact_sound_id_4 INTEGER NOT NULL,
        crit_impact_sound_id_5 INTEGER NOT NULL,
        crit_impact_sound_id_6 INTEGER NOT NULL,
        crit_impact_sound_id_7 INTEGER NOT NULL,
        crit_impact_sound_id_8 INTEGER NOT NULL,
        crit_impact_sound_id_9 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO WeaponImpactSounds (
        id,
        weapon_sub_class_id,
        parry_sound_type,
        impact_sound_id_0,
        impact_sound_id_1,
        impact_sound_id_2,
        impact_sound_id_3,
        impact_sound_id_4,
        impact_sound_id_5,
        impact_sound_id_6,
        impact_sound_id_7,
        impact_sound_id_8,
        impact_sound_id_9,
        crit_impact_sound_id_0,
        crit_impact_sound_id_1,
        crit_impact_sound_id_2,
        crit_impact_sound_id_3,
        crit_impact_sound_id_4,
        crit_impact_sound_id_5,
        crit_impact_sound_id_6,
        crit_impact_sound_id_7,
        crit_impact_sound_id_8,
        crit_impact_sound_id_9
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    );"
    ,
    "SELECT
        id,
        weapon_sub_class_id,
        parry_sound_type,
        impact_sound_id_0,
        impact_sound_id_1,
        impact_sound_id_2,
        impact_sound_id_3,
        impact_sound_id_4,
        impact_sound_id_5,
        impact_sound_id_6,
        impact_sound_id_7,
        impact_sound_id_8,
        impact_sound_id_9,
        crit_impact_sound_id_0,
        crit_impact_sound_id_1,
        crit_impact_sound_id_2,
        crit_impact_sound_id_3,
        crit_impact_sound_id_4,
        crit_impact_sound_id_5,
        crit_impact_sound_id_6,
        crit_impact_sound_id_7,
        crit_impact_sound_id_8,
        crit_impact_sound_id_9
    FROM `WeaponImpactSounds`;"
    )
}


pub(crate) fn weapon_impact_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<weapon_impact_sounds::WeaponImpactSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(weapon_impact_sounds::WeaponImpactSoundsRow {
            id: row.get::<_, i32>(0)?.into(),
            weapon_sub_class_id: row.get::<_, i32>(1)?.into(),
            parry_sound_type: row.get::<_, i32>(2)?.into(),
            impact_sound_id: [row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(), row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(), row.get::<_, i32>(8)?.into(), row.get::<_, i32>(9)?.into(), row.get::<_, i32>(10)?.into(), row.get::<_, i32>(11)?.into(), row.get::<_, i32>(12)?.into(),             ],
            crit_impact_sound_id: [row.get::<_, i32>(13)?.into(), row.get::<_, i32>(14)?.into(), row.get::<_, i32>(15)?.into(), row.get::<_, i32>(16)?.into(), row.get::<_, i32>(17)?.into(), row.get::<_, i32>(18)?.into(), row.get::<_, i32>(19)?.into(), row.get::<_, i32>(20)?.into(), row.get::<_, i32>(21)?.into(), row.get::<_, i32>(22)?.into(),             ],
        });
    }
    Ok(weapon_impact_sounds::WeaponImpactSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WeaponSwingSounds2() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WeaponSwingSounds2 (
        id INTEGER PRIMARY KEY NOT NULL,
        swing_type INTEGER  NOT NULL,
        crit INTEGER  NOT NULL,
        sound_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WeaponSwingSounds2 (
        id,
        swing_type,
        crit,
        sound_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4
    );"
    ,
    "SELECT
        id,
        swing_type,
        crit,
        sound_id
    FROM `WeaponSwingSounds2`;"
    )
}


pub(crate) fn weapon_swing_sounds2_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<weapon_swing_sounds2::WeaponSwingSounds2, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(weapon_swing_sounds2::WeaponSwingSounds2Row {
            id: row.get::<_, i32>(0)?.into(),
            swing_type: row.get::<_, i32>(1)?.into(),
            crit: row.get::<_, i32>(2)?.into(),
            sound_id: row.get::<_, i32>(3)?.into(),
        });
    }
    Ok(weapon_swing_sounds2::WeaponSwingSounds2 { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn Weather() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS Weather (
        id INTEGER PRIMARY KEY NOT NULL,
        ambience_id INTEGER  NOT NULL,
        effect_type INTEGER  NOT NULL,
        transition_sky_box REAL  NOT NULL,
        effect_color_0 REAL NOT NULL,
        effect_color_1 REAL NOT NULL,
        effect_color_2 REAL NOT NULL,
        effect_texture TEXT  NOT NULL
    );"
    ,
    "INSERT INTO Weather (
        id,
        ambience_id,
        effect_type,
        transition_sky_box,
        effect_color_0,
        effect_color_1,
        effect_color_2,
        effect_texture
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        ambience_id,
        effect_type,
        transition_sky_box,
        effect_color_0,
        effect_color_1,
        effect_color_2,
        effect_texture
    FROM `Weather`;"
    )
}


pub(crate) fn weather_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<weather::Weather, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(weather::WeatherRow {
            id: row.get::<_, i32>(0)?.into(),
            ambience_id: row.get::<_, i32>(1)?.into(),
            effect_type: row.get::<_, i32>(2)?.into(),
            transition_sky_box: row.get::<_, f32>(3)?.into(),
            effect_color: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(), row.get::<_, f32>(6)?.into(),             ],
            effect_texture: row.get::<_, String>(7)?.into(),
        });
    }
    Ok(weather::Weather { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldChunkSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldChunkSounds (
        id INTEGER PRIMARY KEY NOT NULL,
        chunk_x INTEGER  NOT NULL,
        chunk_y INTEGER  NOT NULL,
        subchunk_x INTEGER  NOT NULL,
        subchunk_y INTEGER  NOT NULL,
        zone_intro_music_id INTEGER  NOT NULL,
        zone_music_id INTEGER  NOT NULL,
        sound_ambience_id INTEGER  NOT NULL,
        sound_provider_preferences_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldChunkSounds (
        id,
        chunk_x,
        chunk_y,
        subchunk_x,
        subchunk_y,
        zone_intro_music_id,
        zone_music_id,
        sound_ambience_id,
        sound_provider_preferences_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9
    );"
    ,
    "SELECT
        id,
        chunk_x,
        chunk_y,
        subchunk_x,
        subchunk_y,
        zone_intro_music_id,
        zone_music_id,
        sound_ambience_id,
        sound_provider_preferences_id
    FROM `WorldChunkSounds`;"
    )
}


pub(crate) fn world_chunk_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_chunk_sounds::WorldChunkSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_chunk_sounds::WorldChunkSoundsRow {
            id: row.get::<_, i32>(0)?.into(),
            chunk_x: row.get::<_, i32>(1)?.into(),
            chunk_y: row.get::<_, i32>(2)?.into(),
            subchunk_x: row.get::<_, i32>(3)?.into(),
            subchunk_y: row.get::<_, i32>(4)?.into(),
            zone_intro_music_id: row.get::<_, i32>(5)?.into(),
            zone_music_id: row.get::<_, i32>(6)?.into(),
            sound_ambience_id: row.get::<_, i32>(7)?.into(),
            sound_provider_preferences_id: row.get::<_, i32>(8)?.into(),
        });
    }
    Ok(world_chunk_sounds::WorldChunkSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldMapArea() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldMapArea (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        area_id INTEGER  NOT NULL,
        area_name TEXT  NOT NULL,
        loc_left REAL  NOT NULL,
        loc_right REAL  NOT NULL,
        loc_top REAL  NOT NULL,
        loc_bottom REAL  NOT NULL,
        display_map_id INTEGER  NOT NULL,
        default_dungeon_floor INTEGER  NOT NULL,
        parent_world_map_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldMapArea (
        id,
        map_id,
        area_id,
        area_name,
        loc_left,
        loc_right,
        loc_top,
        loc_bottom,
        display_map_id,
        default_dungeon_floor,
        parent_world_map_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11
    );"
    ,
    "SELECT
        id,
        map_id,
        area_id,
        area_name,
        loc_left,
        loc_right,
        loc_top,
        loc_bottom,
        display_map_id,
        default_dungeon_floor,
        parent_world_map_id
    FROM `WorldMapArea`;"
    )
}


pub(crate) fn world_map_area_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_map_area::WorldMapArea, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_map_area::WorldMapAreaRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            area_id: row.get::<_, i32>(2)?.into(),
            area_name: row.get::<_, String>(3)?.into(),
            loc_left: row.get::<_, f32>(4)?.into(),
            loc_right: row.get::<_, f32>(5)?.into(),
            loc_top: row.get::<_, f32>(6)?.into(),
            loc_bottom: row.get::<_, f32>(7)?.into(),
            display_map_id: row.get::<_, i32>(8)?.into(),
            default_dungeon_floor: row.get::<_, i32>(9)?.into(),
            parent_world_map_id: row.get::<_, i32>(10)?.into(),
        });
    }
    Ok(world_map_area::WorldMapArea { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldMapContinent() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldMapContinent (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        left_boundary INTEGER  NOT NULL,
        right_boundary INTEGER  NOT NULL,
        top_boundary INTEGER  NOT NULL,
        bottom_boundary INTEGER  NOT NULL,
        continent_offset_0 REAL NOT NULL,
        continent_offset_1 REAL NOT NULL,
        scale REAL  NOT NULL,
        taxi_min_0 REAL NOT NULL,
        taxi_min_1 REAL NOT NULL,
        taxi_max_0 REAL NOT NULL,
        taxi_max_1 REAL NOT NULL,
        world_map_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldMapContinent (
        id,
        map_id,
        left_boundary,
        right_boundary,
        top_boundary,
        bottom_boundary,
        continent_offset_0,
        continent_offset_1,
        scale,
        taxi_min_0,
        taxi_min_1,
        taxi_max_0,
        taxi_max_1,
        world_map_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14
    );"
    ,
    "SELECT
        id,
        map_id,
        left_boundary,
        right_boundary,
        top_boundary,
        bottom_boundary,
        continent_offset_0,
        continent_offset_1,
        scale,
        taxi_min_0,
        taxi_min_1,
        taxi_max_0,
        taxi_max_1,
        world_map_id
    FROM `WorldMapContinent`;"
    )
}


pub(crate) fn world_map_continent_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_map_continent::WorldMapContinent, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_map_continent::WorldMapContinentRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            left_boundary: row.get::<_, i32>(2)?.into(),
            right_boundary: row.get::<_, i32>(3)?.into(),
            top_boundary: row.get::<_, i32>(4)?.into(),
            bottom_boundary: row.get::<_, i32>(5)?.into(),
            continent_offset: [row.get::<_, f32>(6)?.into(), row.get::<_, f32>(7)?.into(),             ],
            scale: row.get::<_, f32>(8)?.into(),
            taxi_min: [row.get::<_, f32>(9)?.into(), row.get::<_, f32>(10)?.into(),             ],
            taxi_max: [row.get::<_, f32>(11)?.into(), row.get::<_, f32>(12)?.into(),             ],
            world_map_id: row.get::<_, i32>(13)?.into(),
        });
    }
    Ok(world_map_continent::WorldMapContinent { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldMapOverlay() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldMapOverlay (
        id INTEGER PRIMARY KEY NOT NULL,
        map_area_id INTEGER  NOT NULL,
        area_id_0 INTEGER NOT NULL,
        area_id_1 INTEGER NOT NULL,
        area_id_2 INTEGER NOT NULL,
        area_id_3 INTEGER NOT NULL,
        map_point_x INTEGER  NOT NULL,
        map_point_y INTEGER  NOT NULL,
        texture_name TEXT  NOT NULL,
        texture_width INTEGER  NOT NULL,
        texture_height INTEGER  NOT NULL,
        offset_x INTEGER  NOT NULL,
        offset_y INTEGER  NOT NULL,
        hit_rect_top INTEGER  NOT NULL,
        hit_rect_left INTEGER  NOT NULL,
        hit_rect_bottom INTEGER  NOT NULL,
        hit_rect_right INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldMapOverlay (
        id,
        map_area_id,
        area_id_0,
        area_id_1,
        area_id_2,
        area_id_3,
        map_point_x,
        map_point_y,
        texture_name,
        texture_width,
        texture_height,
        offset_x,
        offset_y,
        hit_rect_top,
        hit_rect_left,
        hit_rect_bottom,
        hit_rect_right
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17
    );"
    ,
    "SELECT
        id,
        map_area_id,
        area_id_0,
        area_id_1,
        area_id_2,
        area_id_3,
        map_point_x,
        map_point_y,
        texture_name,
        texture_width,
        texture_height,
        offset_x,
        offset_y,
        hit_rect_top,
        hit_rect_left,
        hit_rect_bottom,
        hit_rect_right
    FROM `WorldMapOverlay`;"
    )
}


pub(crate) fn world_map_overlay_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_map_overlay::WorldMapOverlay, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_map_overlay::WorldMapOverlayRow {
            id: row.get::<_, i32>(0)?.into(),
            map_area_id: row.get::<_, i32>(1)?.into(),
            area_id: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(), row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
            map_point_x: row.get::<_, i32>(6)?.into(),
            map_point_y: row.get::<_, i32>(7)?.into(),
            texture_name: row.get::<_, String>(8)?.into(),
            texture_width: row.get::<_, i32>(9)?.into(),
            texture_height: row.get::<_, i32>(10)?.into(),
            offset_x: row.get::<_, i32>(11)?.into(),
            offset_y: row.get::<_, i32>(12)?.into(),
            hit_rect_top: row.get::<_, i32>(13)?.into(),
            hit_rect_left: row.get::<_, i32>(14)?.into(),
            hit_rect_bottom: row.get::<_, i32>(15)?.into(),
            hit_rect_right: row.get::<_, i32>(16)?.into(),
        });
    }
    Ok(world_map_overlay::WorldMapOverlay { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldMapTransforms() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldMapTransforms (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        region_min_0 REAL NOT NULL,
        region_min_1 REAL NOT NULL,
        region_max_0 REAL NOT NULL,
        region_max_1 REAL NOT NULL,
        new_map_id INTEGER  NOT NULL,
        region_offset_0 REAL NOT NULL,
        region_offset_1 REAL NOT NULL,
        new_dungeon_map_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldMapTransforms (
        id,
        map_id,
        region_min_0,
        region_min_1,
        region_max_0,
        region_max_1,
        new_map_id,
        region_offset_0,
        region_offset_1,
        new_dungeon_map_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10
    );"
    ,
    "SELECT
        id,
        map_id,
        region_min_0,
        region_min_1,
        region_max_0,
        region_max_1,
        new_map_id,
        region_offset_0,
        region_offset_1,
        new_dungeon_map_id
    FROM `WorldMapTransforms`;"
    )
}


pub(crate) fn world_map_transforms_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_map_transforms::WorldMapTransforms, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_map_transforms::WorldMapTransformsRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            region_min: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(),             ],
            region_max: [row.get::<_, f32>(4)?.into(), row.get::<_, f32>(5)?.into(),             ],
            new_map_id: row.get::<_, i32>(6)?.into(),
            region_offset: [row.get::<_, f32>(7)?.into(), row.get::<_, f32>(8)?.into(),             ],
            new_dungeon_map_id: row.get::<_, i32>(9)?.into(),
        });
    }
    Ok(world_map_transforms::WorldMapTransforms { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldSafeLocs() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldSafeLocs (
        id INTEGER PRIMARY KEY NOT NULL,
        continent INTEGER  NOT NULL,
        loc_0 REAL NOT NULL,
        loc_1 REAL NOT NULL,
        loc_2 REAL NOT NULL,
        area_name_lang_en_gb TEXT NOT NULL,
        area_name_lang_ko_kr TEXT NOT NULL,
        area_name_lang_fr_fr TEXT NOT NULL,
        area_name_lang_de_de TEXT NOT NULL,
        area_name_lang_en_cn TEXT NOT NULL,
        area_name_lang_en_tw TEXT NOT NULL,
        area_name_lang_es_es TEXT NOT NULL,
        area_name_lang_es_mx TEXT NOT NULL,
        area_name_lang_ru_ru TEXT NOT NULL,
        area_name_lang_ja_jp TEXT NOT NULL,
        area_name_lang_pt_pt TEXT NOT NULL,
        area_name_lang_it_it TEXT NOT NULL,
        area_name_lang_unknown_12 TEXT NOT NULL,
        area_name_lang_unknown_13 TEXT NOT NULL,
        area_name_lang_unknown_14 TEXT NOT NULL,
        area_name_lang_unknown_15 TEXT NOT NULL,
        area_name_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO WorldSafeLocs (
        id,
        continent,
        loc_0,
        loc_1,
        loc_2,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22
    );"
    ,
    "SELECT
        id,
        continent,
        loc_0,
        loc_1,
        loc_2,
        area_name_lang_en_gb,
        area_name_lang_ko_kr,
        area_name_lang_fr_fr,
        area_name_lang_de_de,
        area_name_lang_en_cn,
        area_name_lang_en_tw,
        area_name_lang_es_es,
        area_name_lang_es_mx,
        area_name_lang_ru_ru,
        area_name_lang_ja_jp,
        area_name_lang_pt_pt,
        area_name_lang_it_it,
        area_name_lang_unknown_12,
        area_name_lang_unknown_13,
        area_name_lang_unknown_14,
        area_name_lang_unknown_15,
        area_name_lang_flags
    FROM `WorldSafeLocs`;"
    )
}


pub(crate) fn world_safe_locs_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_safe_locs::WorldSafeLocs, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_safe_locs::WorldSafeLocsRow {
            id: row.get::<_, i32>(0)?.into(),
            continent: row.get::<_, i32>(1)?.into(),
            loc: [row.get::<_, f32>(2)?.into(), row.get::<_, f32>(3)?.into(), row.get::<_, f32>(4)?.into(),             ],
            area_name_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
        });
    }
    Ok(world_safe_locs::WorldSafeLocs { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldStateUI() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldStateUI (
        id INTEGER PRIMARY KEY NOT NULL,
        map_id INTEGER  NOT NULL,
        area_id INTEGER  NOT NULL,
        phase_shift INTEGER  NOT NULL,
        icon TEXT  NOT NULL,
        string_lang_en_gb TEXT NOT NULL,
        string_lang_ko_kr TEXT NOT NULL,
        string_lang_fr_fr TEXT NOT NULL,
        string_lang_de_de TEXT NOT NULL,
        string_lang_en_cn TEXT NOT NULL,
        string_lang_en_tw TEXT NOT NULL,
        string_lang_es_es TEXT NOT NULL,
        string_lang_es_mx TEXT NOT NULL,
        string_lang_ru_ru TEXT NOT NULL,
        string_lang_ja_jp TEXT NOT NULL,
        string_lang_pt_pt TEXT NOT NULL,
        string_lang_it_it TEXT NOT NULL,
        string_lang_unknown_12 TEXT NOT NULL,
        string_lang_unknown_13 TEXT NOT NULL,
        string_lang_unknown_14 TEXT NOT NULL,
        string_lang_unknown_15 TEXT NOT NULL,
        string_lang_flags INTEGER NOT NULL,
        tooltip_lang_en_gb TEXT NOT NULL,
        tooltip_lang_ko_kr TEXT NOT NULL,
        tooltip_lang_fr_fr TEXT NOT NULL,
        tooltip_lang_de_de TEXT NOT NULL,
        tooltip_lang_en_cn TEXT NOT NULL,
        tooltip_lang_en_tw TEXT NOT NULL,
        tooltip_lang_es_es TEXT NOT NULL,
        tooltip_lang_es_mx TEXT NOT NULL,
        tooltip_lang_ru_ru TEXT NOT NULL,
        tooltip_lang_ja_jp TEXT NOT NULL,
        tooltip_lang_pt_pt TEXT NOT NULL,
        tooltip_lang_it_it TEXT NOT NULL,
        tooltip_lang_unknown_12 TEXT NOT NULL,
        tooltip_lang_unknown_13 TEXT NOT NULL,
        tooltip_lang_unknown_14 TEXT NOT NULL,
        tooltip_lang_unknown_15 TEXT NOT NULL,
        tooltip_lang_flags INTEGER NOT NULL,
        state_variable INTEGER  NOT NULL,
        ty INTEGER  NOT NULL,
        dynamic_icon TEXT  NOT NULL,
        dynamic_tooltip_lang_en_gb TEXT NOT NULL,
        dynamic_tooltip_lang_ko_kr TEXT NOT NULL,
        dynamic_tooltip_lang_fr_fr TEXT NOT NULL,
        dynamic_tooltip_lang_de_de TEXT NOT NULL,
        dynamic_tooltip_lang_en_cn TEXT NOT NULL,
        dynamic_tooltip_lang_en_tw TEXT NOT NULL,
        dynamic_tooltip_lang_es_es TEXT NOT NULL,
        dynamic_tooltip_lang_es_mx TEXT NOT NULL,
        dynamic_tooltip_lang_ru_ru TEXT NOT NULL,
        dynamic_tooltip_lang_ja_jp TEXT NOT NULL,
        dynamic_tooltip_lang_pt_pt TEXT NOT NULL,
        dynamic_tooltip_lang_it_it TEXT NOT NULL,
        dynamic_tooltip_lang_unknown_12 TEXT NOT NULL,
        dynamic_tooltip_lang_unknown_13 TEXT NOT NULL,
        dynamic_tooltip_lang_unknown_14 TEXT NOT NULL,
        dynamic_tooltip_lang_unknown_15 TEXT NOT NULL,
        dynamic_tooltip_lang_flags INTEGER NOT NULL,
        extended_u_i TEXT  NOT NULL,
        extended_u_i_state_variable_0 INTEGER NOT NULL,
        extended_u_i_state_variable_1 INTEGER NOT NULL,
        extended_u_i_state_variable_2 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO WorldStateUI (
        id,
        map_id,
        area_id,
        phase_shift,
        icon,
        string_lang_en_gb,
        string_lang_ko_kr,
        string_lang_fr_fr,
        string_lang_de_de,
        string_lang_en_cn,
        string_lang_en_tw,
        string_lang_es_es,
        string_lang_es_mx,
        string_lang_ru_ru,
        string_lang_ja_jp,
        string_lang_pt_pt,
        string_lang_it_it,
        string_lang_unknown_12,
        string_lang_unknown_13,
        string_lang_unknown_14,
        string_lang_unknown_15,
        string_lang_flags,
        tooltip_lang_en_gb,
        tooltip_lang_ko_kr,
        tooltip_lang_fr_fr,
        tooltip_lang_de_de,
        tooltip_lang_en_cn,
        tooltip_lang_en_tw,
        tooltip_lang_es_es,
        tooltip_lang_es_mx,
        tooltip_lang_ru_ru,
        tooltip_lang_ja_jp,
        tooltip_lang_pt_pt,
        tooltip_lang_it_it,
        tooltip_lang_unknown_12,
        tooltip_lang_unknown_13,
        tooltip_lang_unknown_14,
        tooltip_lang_unknown_15,
        tooltip_lang_flags,
        state_variable,
        ty,
        dynamic_icon,
        dynamic_tooltip_lang_en_gb,
        dynamic_tooltip_lang_ko_kr,
        dynamic_tooltip_lang_fr_fr,
        dynamic_tooltip_lang_de_de,
        dynamic_tooltip_lang_en_cn,
        dynamic_tooltip_lang_en_tw,
        dynamic_tooltip_lang_es_es,
        dynamic_tooltip_lang_es_mx,
        dynamic_tooltip_lang_ru_ru,
        dynamic_tooltip_lang_ja_jp,
        dynamic_tooltip_lang_pt_pt,
        dynamic_tooltip_lang_it_it,
        dynamic_tooltip_lang_unknown_12,
        dynamic_tooltip_lang_unknown_13,
        dynamic_tooltip_lang_unknown_14,
        dynamic_tooltip_lang_unknown_15,
        dynamic_tooltip_lang_flags,
        extended_u_i,
        extended_u_i_state_variable_0,
        extended_u_i_state_variable_1,
        extended_u_i_state_variable_2
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23,
        ?24,
        ?25,
        ?26,
        ?27,
        ?28,
        ?29,
        ?30,
        ?31,
        ?32,
        ?33,
        ?34,
        ?35,
        ?36,
        ?37,
        ?38,
        ?39,
        ?40,
        ?41,
        ?42,
        ?43,
        ?44,
        ?45,
        ?46,
        ?47,
        ?48,
        ?49,
        ?50,
        ?51,
        ?52,
        ?53,
        ?54,
        ?55,
        ?56,
        ?57,
        ?58,
        ?59,
        ?60,
        ?61,
        ?62,
        ?63
    );"
    ,
    "SELECT
        id,
        map_id,
        area_id,
        phase_shift,
        icon,
        string_lang_en_gb,
        string_lang_ko_kr,
        string_lang_fr_fr,
        string_lang_de_de,
        string_lang_en_cn,
        string_lang_en_tw,
        string_lang_es_es,
        string_lang_es_mx,
        string_lang_ru_ru,
        string_lang_ja_jp,
        string_lang_pt_pt,
        string_lang_it_it,
        string_lang_unknown_12,
        string_lang_unknown_13,
        string_lang_unknown_14,
        string_lang_unknown_15,
        string_lang_flags,
        tooltip_lang_en_gb,
        tooltip_lang_ko_kr,
        tooltip_lang_fr_fr,
        tooltip_lang_de_de,
        tooltip_lang_en_cn,
        tooltip_lang_en_tw,
        tooltip_lang_es_es,
        tooltip_lang_es_mx,
        tooltip_lang_ru_ru,
        tooltip_lang_ja_jp,
        tooltip_lang_pt_pt,
        tooltip_lang_it_it,
        tooltip_lang_unknown_12,
        tooltip_lang_unknown_13,
        tooltip_lang_unknown_14,
        tooltip_lang_unknown_15,
        tooltip_lang_flags,
        state_variable,
        ty,
        dynamic_icon,
        dynamic_tooltip_lang_en_gb,
        dynamic_tooltip_lang_ko_kr,
        dynamic_tooltip_lang_fr_fr,
        dynamic_tooltip_lang_de_de,
        dynamic_tooltip_lang_en_cn,
        dynamic_tooltip_lang_en_tw,
        dynamic_tooltip_lang_es_es,
        dynamic_tooltip_lang_es_mx,
        dynamic_tooltip_lang_ru_ru,
        dynamic_tooltip_lang_ja_jp,
        dynamic_tooltip_lang_pt_pt,
        dynamic_tooltip_lang_it_it,
        dynamic_tooltip_lang_unknown_12,
        dynamic_tooltip_lang_unknown_13,
        dynamic_tooltip_lang_unknown_14,
        dynamic_tooltip_lang_unknown_15,
        dynamic_tooltip_lang_flags,
        extended_u_i,
        extended_u_i_state_variable_0,
        extended_u_i_state_variable_1,
        extended_u_i_state_variable_2
    FROM `WorldStateUI`;"
    )
}


pub(crate) fn world_state_ui_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_state_ui::WorldStateUI, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_state_ui::WorldStateUIRow {
            id: row.get::<_, i32>(0)?.into(),
            map_id: row.get::<_, i32>(1)?.into(),
            area_id: row.get::<_, i32>(2)?.into(),
            phase_shift: row.get::<_, i32>(3)?.into(),
            icon: row.get::<_, String>(4)?.into(),
            string_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(5)?.into(),
                ko_kr: row.get::<_, String>(6)?.into(),
                fr_fr: row.get::<_, String>(7)?.into(),
                de_de: row.get::<_, String>(8)?.into(),
                en_cn: row.get::<_, String>(9)?.into(),
                en_tw: row.get::<_, String>(10)?.into(),
                es_es: row.get::<_, String>(11)?.into(),
                es_mx: row.get::<_, String>(12)?.into(),
                ru_ru: row.get::<_, String>(13)?.into(),
                ja_jp: row.get::<_, String>(14)?.into(),
                pt_pt: row.get::<_, String>(15)?.into(),
                it_it: row.get::<_, String>(16)?.into(),
                unknown_12: row.get::<_, String>(17)?.into(),
                unknown_13: row.get::<_, String>(18)?.into(),
                unknown_14: row.get::<_, String>(19)?.into(),
                unknown_15: row.get::<_, String>(20)?.into(),
                flags: row.get::<_, u32>(21)?.into(),
            },
            tooltip_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(22)?.into(),
                ko_kr: row.get::<_, String>(23)?.into(),
                fr_fr: row.get::<_, String>(24)?.into(),
                de_de: row.get::<_, String>(25)?.into(),
                en_cn: row.get::<_, String>(26)?.into(),
                en_tw: row.get::<_, String>(27)?.into(),
                es_es: row.get::<_, String>(28)?.into(),
                es_mx: row.get::<_, String>(29)?.into(),
                ru_ru: row.get::<_, String>(30)?.into(),
                ja_jp: row.get::<_, String>(31)?.into(),
                pt_pt: row.get::<_, String>(32)?.into(),
                it_it: row.get::<_, String>(33)?.into(),
                unknown_12: row.get::<_, String>(34)?.into(),
                unknown_13: row.get::<_, String>(35)?.into(),
                unknown_14: row.get::<_, String>(36)?.into(),
                unknown_15: row.get::<_, String>(37)?.into(),
                flags: row.get::<_, u32>(38)?.into(),
            },
            state_variable: row.get::<_, i32>(39)?.into(),
            ty: row.get::<_, i32>(40)?.into(),
            dynamic_icon: row.get::<_, String>(41)?.into(),
            dynamic_tooltip_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(42)?.into(),
                ko_kr: row.get::<_, String>(43)?.into(),
                fr_fr: row.get::<_, String>(44)?.into(),
                de_de: row.get::<_, String>(45)?.into(),
                en_cn: row.get::<_, String>(46)?.into(),
                en_tw: row.get::<_, String>(47)?.into(),
                es_es: row.get::<_, String>(48)?.into(),
                es_mx: row.get::<_, String>(49)?.into(),
                ru_ru: row.get::<_, String>(50)?.into(),
                ja_jp: row.get::<_, String>(51)?.into(),
                pt_pt: row.get::<_, String>(52)?.into(),
                it_it: row.get::<_, String>(53)?.into(),
                unknown_12: row.get::<_, String>(54)?.into(),
                unknown_13: row.get::<_, String>(55)?.into(),
                unknown_14: row.get::<_, String>(56)?.into(),
                unknown_15: row.get::<_, String>(57)?.into(),
                flags: row.get::<_, u32>(58)?.into(),
            },
            extended_u_i: row.get::<_, String>(59)?.into(),
            extended_u_i_state_variable: [row.get::<_, i32>(60)?.into(), row.get::<_, i32>(61)?.into(), row.get::<_, i32>(62)?.into(),             ],
        });
    }
    Ok(world_state_ui::WorldStateUI { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WorldStateZoneSounds() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WorldStateZoneSounds (
        world_state_id INTEGER  NOT NULL,
        world_state_value INTEGER  NOT NULL,
        area_id INTEGER  NOT NULL,
        w_m_o_area_id INTEGER  NOT NULL,
        zone_intro_music_id INTEGER  NOT NULL,
        zone_music_id INTEGER  NOT NULL,
        sound_ambience_id INTEGER  NOT NULL,
        sound_provider_preferences_id INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO WorldStateZoneSounds (
        world_state_id,
        world_state_value,
        area_id,
        w_m_o_area_id,
        zone_intro_music_id,
        zone_music_id,
        sound_ambience_id,
        sound_provider_preferences_id
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        world_state_id,
        world_state_value,
        area_id,
        w_m_o_area_id,
        zone_intro_music_id,
        zone_music_id,
        sound_ambience_id,
        sound_provider_preferences_id
    FROM `WorldStateZoneSounds`;"
    )
}


pub(crate) fn world_state_zone_sounds_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<world_state_zone_sounds::WorldStateZoneSounds, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(world_state_zone_sounds::WorldStateZoneSoundsRow {
            world_state_id: row.get::<_, i32>(0)?.into(),
            world_state_value: row.get::<_, i32>(1)?.into(),
            area_id: row.get::<_, i32>(2)?.into(),
            w_m_o_area_id: row.get::<_, i32>(3)?.into(),
            zone_intro_music_id: row.get::<_, i32>(4)?.into(),
            zone_music_id: row.get::<_, i32>(5)?.into(),
            sound_ambience_id: row.get::<_, i32>(6)?.into(),
            sound_provider_preferences_id: row.get::<_, i32>(7)?.into(),
        });
    }
    Ok(world_state_zone_sounds::WorldStateZoneSounds { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn WowError_Strings() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS WowError_Strings (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        description_lang_en_gb TEXT NOT NULL,
        description_lang_ko_kr TEXT NOT NULL,
        description_lang_fr_fr TEXT NOT NULL,
        description_lang_de_de TEXT NOT NULL,
        description_lang_en_cn TEXT NOT NULL,
        description_lang_en_tw TEXT NOT NULL,
        description_lang_es_es TEXT NOT NULL,
        description_lang_es_mx TEXT NOT NULL,
        description_lang_ru_ru TEXT NOT NULL,
        description_lang_ja_jp TEXT NOT NULL,
        description_lang_pt_pt TEXT NOT NULL,
        description_lang_it_it TEXT NOT NULL,
        description_lang_unknown_12 TEXT NOT NULL,
        description_lang_unknown_13 TEXT NOT NULL,
        description_lang_unknown_14 TEXT NOT NULL,
        description_lang_unknown_15 TEXT NOT NULL,
        description_lang_flags INTEGER NOT NULL
    );"
    ,
    "INSERT INTO WowError_Strings (
        id,
        name,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19
    );"
    ,
    "SELECT
        id,
        name,
        description_lang_en_gb,
        description_lang_ko_kr,
        description_lang_fr_fr,
        description_lang_de_de,
        description_lang_en_cn,
        description_lang_en_tw,
        description_lang_es_es,
        description_lang_es_mx,
        description_lang_ru_ru,
        description_lang_ja_jp,
        description_lang_pt_pt,
        description_lang_it_it,
        description_lang_unknown_12,
        description_lang_unknown_13,
        description_lang_unknown_14,
        description_lang_unknown_15,
        description_lang_flags
    FROM `WowError_Strings`;"
    )
}


pub(crate) fn wow_error_strings_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<wow_error_strings::WowError_Strings, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(wow_error_strings::WowError_StringsRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            description_lang: ExtendedLocalizedString {
                en_gb: row.get::<_, String>(2)?.into(),
                ko_kr: row.get::<_, String>(3)?.into(),
                fr_fr: row.get::<_, String>(4)?.into(),
                de_de: row.get::<_, String>(5)?.into(),
                en_cn: row.get::<_, String>(6)?.into(),
                en_tw: row.get::<_, String>(7)?.into(),
                es_es: row.get::<_, String>(8)?.into(),
                es_mx: row.get::<_, String>(9)?.into(),
                ru_ru: row.get::<_, String>(10)?.into(),
                ja_jp: row.get::<_, String>(11)?.into(),
                pt_pt: row.get::<_, String>(12)?.into(),
                it_it: row.get::<_, String>(13)?.into(),
                unknown_12: row.get::<_, String>(14)?.into(),
                unknown_13: row.get::<_, String>(15)?.into(),
                unknown_14: row.get::<_, String>(16)?.into(),
                unknown_15: row.get::<_, String>(17)?.into(),
                flags: row.get::<_, u32>(18)?.into(),
            },
        });
    }
    Ok(wow_error_strings::WowError_Strings { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ZoneIntroMusicTable() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ZoneIntroMusicTable (
        id INTEGER PRIMARY KEY NOT NULL,
        name TEXT  NOT NULL,
        sound_id INTEGER  NOT NULL,
        priority INTEGER  NOT NULL,
        min_delay_minutes INTEGER  NOT NULL
    );"
    ,
    "INSERT INTO ZoneIntroMusicTable (
        id,
        name,
        sound_id,
        priority,
        min_delay_minutes
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5
    );"
    ,
    "SELECT
        id,
        name,
        sound_id,
        priority,
        min_delay_minutes
    FROM `ZoneIntroMusicTable`;"
    )
}


pub(crate) fn zone_intro_music_table_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<zone_intro_music_table::ZoneIntroMusicTable, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(zone_intro_music_table::ZoneIntroMusicTableRow {
            id: row.get::<_, i32>(0)?.into(),
            name: row.get::<_, String>(1)?.into(),
            sound_id: row.get::<_, i32>(2)?.into(),
            priority: row.get::<_, i32>(3)?.into(),
            min_delay_minutes: row.get::<_, i32>(4)?.into(),
        });
    }
    Ok(zone_intro_music_table::ZoneIntroMusicTable { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn ZoneMusic() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS ZoneMusic (
        id INTEGER PRIMARY KEY NOT NULL,
        set_name TEXT  NOT NULL,
        silence_interval_min_0 INTEGER NOT NULL,
        silence_interval_min_1 INTEGER NOT NULL,
        silence_interval_max_0 INTEGER NOT NULL,
        silence_interval_max_1 INTEGER NOT NULL,
        sounds_0 INTEGER NOT NULL,
        sounds_1 INTEGER NOT NULL
    );"
    ,
    "INSERT INTO ZoneMusic (
        id,
        set_name,
        silence_interval_min_0,
        silence_interval_min_1,
        silence_interval_max_0,
        silence_interval_max_1,
        sounds_0,
        sounds_1
        ) VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8
    );"
    ,
    "SELECT
        id,
        set_name,
        silence_interval_min_0,
        silence_interval_min_1,
        silence_interval_max_0,
        silence_interval_max_1,
        sounds_0,
        sounds_1
    FROM `ZoneMusic`;"
    )
}


pub(crate) fn zone_music_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<zone_music::ZoneMusic, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(zone_music::ZoneMusicRow {
            id: row.get::<_, i32>(0)?.into(),
            set_name: row.get::<_, String>(1)?.into(),
            silence_interval_min: [row.get::<_, i32>(2)?.into(), row.get::<_, i32>(3)?.into(),             ],
            silence_interval_max: [row.get::<_, i32>(4)?.into(), row.get::<_, i32>(5)?.into(),             ],
            sounds: [row.get::<_, i32>(6)?.into(), row.get::<_, i32>(7)?.into(),             ],
        });
    }
    Ok(zone_music::ZoneMusic { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtBarberShopCostBase() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtBarberShopCostBase (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtBarberShopCostBase (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtBarberShopCostBase`;"
    )
}


pub(crate) fn gt_barber_shop_cost_base_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_barber_shop_cost_base::gtBarberShopCostBase, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_barber_shop_cost_base::gtBarberShopCostBaseRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_barber_shop_cost_base::gtBarberShopCostBase { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtChanceToMeleeCrit() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtChanceToMeleeCrit (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtChanceToMeleeCrit (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtChanceToMeleeCrit`;"
    )
}


pub(crate) fn gt_chance_to_melee_crit_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_chance_to_melee_crit::gtChanceToMeleeCrit, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_chance_to_melee_crit::gtChanceToMeleeCritRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_chance_to_melee_crit::gtChanceToMeleeCrit { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtChanceToMeleeCritBase() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtChanceToMeleeCritBase (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtChanceToMeleeCritBase (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtChanceToMeleeCritBase`;"
    )
}


pub(crate) fn gt_chance_to_melee_crit_base_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_chance_to_melee_crit_base::gtChanceToMeleeCritBase, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_chance_to_melee_crit_base::gtChanceToMeleeCritBaseRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_chance_to_melee_crit_base::gtChanceToMeleeCritBase { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtChanceToSpellCrit() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtChanceToSpellCrit (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtChanceToSpellCrit (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtChanceToSpellCrit`;"
    )
}


pub(crate) fn gt_chance_to_spell_crit_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_chance_to_spell_crit::gtChanceToSpellCrit, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_chance_to_spell_crit::gtChanceToSpellCritRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_chance_to_spell_crit::gtChanceToSpellCrit { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtChanceToSpellCritBase() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtChanceToSpellCritBase (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtChanceToSpellCritBase (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtChanceToSpellCritBase`;"
    )
}


pub(crate) fn gt_chance_to_spell_crit_base_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_chance_to_spell_crit_base::gtChanceToSpellCritBase, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_chance_to_spell_crit_base::gtChanceToSpellCritBaseRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_chance_to_spell_crit_base::gtChanceToSpellCritBase { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtCombatRatings() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtCombatRatings (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtCombatRatings (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtCombatRatings`;"
    )
}


pub(crate) fn gt_combat_ratings_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_combat_ratings::gtCombatRatings, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_combat_ratings::gtCombatRatingsRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_combat_ratings::gtCombatRatings { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtNPCManaCostScaler() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtNPCManaCostScaler (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtNPCManaCostScaler (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtNPCManaCostScaler`;"
    )
}


pub(crate) fn gt_npc_mana_cost_scaler_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_npc_mana_cost_scaler::gtNPCManaCostScaler, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_npc_mana_cost_scaler::gtNPCManaCostScalerRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_npc_mana_cost_scaler::gtNPCManaCostScaler { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtOCTClassCombatRatingScalar() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtOCTClassCombatRatingScalar (
        id INTEGER PRIMARY KEY NOT NULL,
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtOCTClassCombatRatingScalar (
        id,
        data
        ) VALUES (
        ?1,
        ?2
    );"
    ,
    "SELECT
        id,
        data
    FROM `gtOCTClassCombatRatingScalar`;"
    )
}


pub(crate) fn gt_oct_class_combat_rating_scalar_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_oct_class_combat_rating_scalar::gtOCTClassCombatRatingScalar, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_oct_class_combat_rating_scalar::gtOCTClassCombatRatingScalarRow {
            id: row.get::<_, i32>(0)?.into(),
            data: row.get::<_, f32>(1)?.into(),
        });
    }
    Ok(gt_oct_class_combat_rating_scalar::gtOCTClassCombatRatingScalar { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtOCTRegenHP() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtOCTRegenHP (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtOCTRegenHP (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtOCTRegenHP`;"
    )
}


pub(crate) fn gt_oct_regen_hp_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_oct_regen_hp::gtOCTRegenHP, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_oct_regen_hp::gtOCTRegenHPRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_oct_regen_hp::gtOCTRegenHP { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtOCTRegenMP() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtOCTRegenMP (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtOCTRegenMP (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtOCTRegenMP`;"
    )
}


pub(crate) fn gt_oct_regen_mp_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_oct_regen_mp::gtOCTRegenMP, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_oct_regen_mp::gtOCTRegenMPRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_oct_regen_mp::gtOCTRegenMP { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtRegenHPPerSpt() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtRegenHPPerSpt (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtRegenHPPerSpt (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtRegenHPPerSpt`;"
    )
}


pub(crate) fn gt_regen_hp_per_spt_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_regen_hp_per_spt::gtRegenHPPerSpt, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_regen_hp_per_spt::gtRegenHPPerSptRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_regen_hp_per_spt::gtRegenHPPerSpt { rows: data })
}
#[allow(non_snake_case)]
pub(crate) fn gtRegenMPPerSpt() -> (&'static str, &'static str, &'static str) {
    (
    "CREATE TABLE IF NOT EXISTS gtRegenMPPerSpt (
        data REAL  NOT NULL
    );"
    ,
    "INSERT INTO gtRegenMPPerSpt (
        data
        ) VALUES (
        ?1
    );"
    ,
    "SELECT
        data
    FROM `gtRegenMPPerSpt`;"
    )
}


pub(crate) fn gt_regen_mp_per_spt_from_rows(rows: &mut rusqlite::Rows<'_>) -> Result<gt_regen_mp_per_spt::gtRegenMPPerSpt, SqliteError> {
    let mut data = Vec::new();
    while let Some(row) = rows.next()? {
        let row = row;
        data.push(gt_regen_mp_per_spt::gtRegenMPPerSptRow {
            data: row.get::<_, f32>(0)?.into(),
        });
    }
    Ok(gt_regen_mp_per_spt::gtRegenMPPerSpt { rows: data })
}
pub(crate) fn generate_dbc_for(name: &str, conn: &rusqlite::Connection, mut writer: impl std::io::Write) -> Result<(), SqliteError> {
    match name {
        "Achievement" => {
            let (_create, _insert, select) = Achievement();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = achievement_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Achievement_Category" => {
            let (_create, _insert, select) = Achievement_Category();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = achievement_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Achievement_Criteria" => {
            let (_create, _insert, select) = Achievement_Criteria();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = achievement_criteria_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AnimationData" => {
            let (_create, _insert, select) = AnimationData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = animation_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AreaGroup" => {
            let (_create, _insert, select) = AreaGroup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = area_group_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AreaPOI" => {
            let (_create, _insert, select) = AreaPOI();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = area_poi_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AreaTable" => {
            let (_create, _insert, select) = AreaTable();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = area_table_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AreaTrigger" => {
            let (_create, _insert, select) = AreaTrigger();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = area_trigger_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AttackAnimKits" => {
            let (_create, _insert, select) = AttackAnimKits();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = attack_anim_kits_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AttackAnimTypes" => {
            let (_create, _insert, select) = AttackAnimTypes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = attack_anim_types_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "AuctionHouse" => {
            let (_create, _insert, select) = AuctionHouse();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = auction_house_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "BankBagSlotPrices" => {
            let (_create, _insert, select) = BankBagSlotPrices();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = bank_bag_slot_prices_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "BannedAddOns" => {
            let (_create, _insert, select) = BannedAddOns();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = banned_add_ons_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "BarberShopStyle" => {
            let (_create, _insert, select) = BarberShopStyle();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = barber_shop_style_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "BattlemasterList" => {
            let (_create, _insert, select) = BattlemasterList();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = battlemaster_list_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CameraShakes" => {
            let (_create, _insert, select) = CameraShakes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = camera_shakes_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Cfg_Categories" => {
            let (_create, _insert, select) = Cfg_Categories();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = cfg_categories_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Cfg_Configs" => {
            let (_create, _insert, select) = Cfg_Configs();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = cfg_configs_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharBaseInfo" => {
            let (_create, _insert, select) = CharBaseInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_base_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharHairGeosets" => {
            let (_create, _insert, select) = CharHairGeosets();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_hair_geosets_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharHairTextures" => {
            let (_create, _insert, select) = CharHairTextures();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_hair_textures_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharSections" => {
            let (_create, _insert, select) = CharSections();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_sections_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharStartOutfit" => {
            let (_create, _insert, select) = CharStartOutfit();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_start_outfit_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharTitles" => {
            let (_create, _insert, select) = CharTitles();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_titles_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharVariations" => {
            let (_create, _insert, select) = CharVariations();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = char_variations_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CharacterFacialHairStyles" => {
            let (_create, _insert, select) = CharacterFacialHairStyles();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = character_facial_hair_styles_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ChatChannels" => {
            let (_create, _insert, select) = ChatChannels();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = chat_channels_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ChatProfanity" => {
            let (_create, _insert, select) = ChatProfanity();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = chat_profanity_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ChrClasses" => {
            let (_create, _insert, select) = ChrClasses();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = chr_classes_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ChrRaces" => {
            let (_create, _insert, select) = ChrRaces();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = chr_races_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CinematicCamera" => {
            let (_create, _insert, select) = CinematicCamera();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = cinematic_camera_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CinematicSequences" => {
            let (_create, _insert, select) = CinematicSequences();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = cinematic_sequences_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureDisplayInfo" => {
            let (_create, _insert, select) = CreatureDisplayInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_display_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureDisplayInfoExtra" => {
            let (_create, _insert, select) = CreatureDisplayInfoExtra();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_display_info_extra_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureFamily" => {
            let (_create, _insert, select) = CreatureFamily();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_family_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureModelData" => {
            let (_create, _insert, select) = CreatureModelData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_model_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureMovementInfo" => {
            let (_create, _insert, select) = CreatureMovementInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_movement_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureSoundData" => {
            let (_create, _insert, select) = CreatureSoundData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_sound_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureSpellData" => {
            let (_create, _insert, select) = CreatureSpellData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_spell_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CreatureType" => {
            let (_create, _insert, select) = CreatureType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = creature_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CurrencyCategory" => {
            let (_create, _insert, select) = CurrencyCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = currency_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "CurrencyTypes" => {
            let (_create, _insert, select) = CurrencyTypes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = currency_types_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DanceMoves" => {
            let (_create, _insert, select) = DanceMoves();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = dance_moves_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DeathThudLookups" => {
            let (_create, _insert, select) = DeathThudLookups();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = death_thud_lookups_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DeclinedWord" => {
            let (_create, _insert, select) = DeclinedWord();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = declined_word_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DeclinedWordCases" => {
            let (_create, _insert, select) = DeclinedWordCases();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = declined_word_cases_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DestructibleModelData" => {
            let (_create, _insert, select) = DestructibleModelData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = destructible_model_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DungeonEncounter" => {
            let (_create, _insert, select) = DungeonEncounter();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = dungeon_encounter_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DungeonMap" => {
            let (_create, _insert, select) = DungeonMap();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = dungeon_map_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DungeonMapChunk" => {
            let (_create, _insert, select) = DungeonMapChunk();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = dungeon_map_chunk_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DurabilityCosts" => {
            let (_create, _insert, select) = DurabilityCosts();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = durability_costs_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "DurabilityQuality" => {
            let (_create, _insert, select) = DurabilityQuality();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = durability_quality_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Emotes" => {
            let (_create, _insert, select) = Emotes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = emotes_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "EmotesText" => {
            let (_create, _insert, select) = EmotesText();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = emotes_text_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "EmotesTextData" => {
            let (_create, _insert, select) = EmotesTextData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = emotes_text_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "EmotesTextSound" => {
            let (_create, _insert, select) = EmotesTextSound();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = emotes_text_sound_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "EnvironmentalDamage" => {
            let (_create, _insert, select) = EnvironmentalDamage();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = environmental_damage_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Exhaustion" => {
            let (_create, _insert, select) = Exhaustion();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = exhaustion_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Faction" => {
            let (_create, _insert, select) = Faction();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = faction_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "FactionGroup" => {
            let (_create, _insert, select) = FactionGroup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = faction_group_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "FactionTemplate" => {
            let (_create, _insert, select) = FactionTemplate();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = faction_template_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "FileData" => {
            let (_create, _insert, select) = FileData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = file_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "FootprintTextures" => {
            let (_create, _insert, select) = FootprintTextures();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = footprint_textures_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "FootstepTerrainLookup" => {
            let (_create, _insert, select) = FootstepTerrainLookup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = footstep_terrain_lookup_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GMSurveyAnswers" => {
            let (_create, _insert, select) = GMSurveyAnswers();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gm_survey_answers_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GMSurveyCurrentSurvey" => {
            let (_create, _insert, select) = GMSurveyCurrentSurvey();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gm_survey_current_survey_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GMSurveyQuestions" => {
            let (_create, _insert, select) = GMSurveyQuestions();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gm_survey_questions_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GMSurveySurveys" => {
            let (_create, _insert, select) = GMSurveySurveys();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gm_survey_surveys_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GMTicketCategory" => {
            let (_create, _insert, select) = GMTicketCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gm_ticket_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GameObjectArtKit" => {
            let (_create, _insert, select) = GameObjectArtKit();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = game_object_art_kit_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GameObjectDisplayInfo" => {
            let (_create, _insert, select) = GameObjectDisplayInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = game_object_display_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GameTables" => {
            let (_create, _insert, select) = GameTables();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = game_tables_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GameTips" => {
            let (_create, _insert, select) = GameTips();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = game_tips_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GemProperties" => {
            let (_create, _insert, select) = GemProperties();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gem_properties_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GlyphProperties" => {
            let (_create, _insert, select) = GlyphProperties();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = glyph_properties_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GlyphSlot" => {
            let (_create, _insert, select) = GlyphSlot();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = glyph_slot_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GroundEffectDoodad" => {
            let (_create, _insert, select) = GroundEffectDoodad();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = ground_effect_doodad_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "GroundEffectTexture" => {
            let (_create, _insert, select) = GroundEffectTexture();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = ground_effect_texture_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "HelmetGeosetVisData" => {
            let (_create, _insert, select) = HelmetGeosetVisData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = helmet_geoset_vis_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "HolidayDescriptions" => {
            let (_create, _insert, select) = HolidayDescriptions();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = holiday_descriptions_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "HolidayNames" => {
            let (_create, _insert, select) = HolidayNames();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = holiday_names_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Holidays" => {
            let (_create, _insert, select) = Holidays();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = holidays_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Item" => {
            let (_create, _insert, select) = Item();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemBagFamily" => {
            let (_create, _insert, select) = ItemBagFamily();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_bag_family_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemClass" => {
            let (_create, _insert, select) = ItemClass();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_class_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemCondExtCosts" => {
            let (_create, _insert, select) = ItemCondExtCosts();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_cond_ext_costs_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemDisplayInfo" => {
            let (_create, _insert, select) = ItemDisplayInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_display_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemExtendedCost" => {
            let (_create, _insert, select) = ItemExtendedCost();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_extended_cost_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemGroupSounds" => {
            let (_create, _insert, select) = ItemGroupSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_group_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemLimitCategory" => {
            let (_create, _insert, select) = ItemLimitCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_limit_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemPetFood" => {
            let (_create, _insert, select) = ItemPetFood();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_pet_food_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemPurchaseGroup" => {
            let (_create, _insert, select) = ItemPurchaseGroup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_purchase_group_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemRandomProperties" => {
            let (_create, _insert, select) = ItemRandomProperties();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_random_properties_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemRandomSuffix" => {
            let (_create, _insert, select) = ItemRandomSuffix();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_random_suffix_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemSet" => {
            let (_create, _insert, select) = ItemSet();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_set_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemSubClass" => {
            let (_create, _insert, select) = ItemSubClass();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_sub_class_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemSubClassMask" => {
            let (_create, _insert, select) = ItemSubClassMask();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_sub_class_mask_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemVisualEffects" => {
            let (_create, _insert, select) = ItemVisualEffects();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_visual_effects_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ItemVisuals" => {
            let (_create, _insert, select) = ItemVisuals();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = item_visuals_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LFGDungeonExpansion" => {
            let (_create, _insert, select) = LFGDungeonExpansion();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = lfg_dungeon_expansion_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LFGDungeonGroup" => {
            let (_create, _insert, select) = LFGDungeonGroup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = lfg_dungeon_group_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LFGDungeons" => {
            let (_create, _insert, select) = LFGDungeons();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = lfg_dungeons_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LanguageWords" => {
            let (_create, _insert, select) = LanguageWords();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = language_words_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Languages" => {
            let (_create, _insert, select) = Languages();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = languages_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Light" => {
            let (_create, _insert, select) = Light();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = light_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LightFloatBand" => {
            let (_create, _insert, select) = LightFloatBand();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = light_float_band_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LightIntBand" => {
            let (_create, _insert, select) = LightIntBand();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = light_int_band_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LightParams" => {
            let (_create, _insert, select) = LightParams();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = light_params_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LightSkybox" => {
            let (_create, _insert, select) = LightSkybox();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = light_skybox_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LiquidMaterial" => {
            let (_create, _insert, select) = LiquidMaterial();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = liquid_material_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LiquidType" => {
            let (_create, _insert, select) = LiquidType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = liquid_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LoadingScreenTaxiSplines" => {
            let (_create, _insert, select) = LoadingScreenTaxiSplines();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = loading_screen_taxi_splines_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LoadingScreens" => {
            let (_create, _insert, select) = LoadingScreens();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = loading_screens_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Lock" => {
            let (_create, _insert, select) = Lock();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = lock_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "LockType" => {
            let (_create, _insert, select) = LockType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = lock_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "MailTemplate" => {
            let (_create, _insert, select) = MailTemplate();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = mail_template_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Map" => {
            let (_create, _insert, select) = Map();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = map_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "MapDifficulty" => {
            let (_create, _insert, select) = MapDifficulty();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = map_difficulty_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Material" => {
            let (_create, _insert, select) = Material();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = material_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Movie" => {
            let (_create, _insert, select) = Movie();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = movie_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "MovieFileData" => {
            let (_create, _insert, select) = MovieFileData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = movie_file_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "MovieVariation" => {
            let (_create, _insert, select) = MovieVariation();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = movie_variation_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "NPCSounds" => {
            let (_create, _insert, select) = NPCSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = npc_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "NameGen" => {
            let (_create, _insert, select) = NameGen();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = name_gen_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "NamesProfanity" => {
            let (_create, _insert, select) = NamesProfanity();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = names_profanity_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "NamesReserved" => {
            let (_create, _insert, select) = NamesReserved();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = names_reserved_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ObjectEffect" => {
            let (_create, _insert, select) = ObjectEffect();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = object_effect_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ObjectEffectGroup" => {
            let (_create, _insert, select) = ObjectEffectGroup();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = object_effect_group_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ObjectEffectModifier" => {
            let (_create, _insert, select) = ObjectEffectModifier();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = object_effect_modifier_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ObjectEffectPackage" => {
            let (_create, _insert, select) = ObjectEffectPackage();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = object_effect_package_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ObjectEffectPackageElem" => {
            let (_create, _insert, select) = ObjectEffectPackageElem();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = object_effect_package_elem_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "OverrideSpellData" => {
            let (_create, _insert, select) = OverrideSpellData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = override_spell_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Package" => {
            let (_create, _insert, select) = Package();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = package_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PageTextMaterial" => {
            let (_create, _insert, select) = PageTextMaterial();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = page_text_material_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PaperDollItemFrame" => {
            let (_create, _insert, select) = PaperDollItemFrame();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = paper_doll_item_frame_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ParticleColor" => {
            let (_create, _insert, select) = ParticleColor();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = particle_color_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PetPersonality" => {
            let (_create, _insert, select) = PetPersonality();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = pet_personality_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PetitionType" => {
            let (_create, _insert, select) = PetitionType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = petition_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PowerDisplay" => {
            let (_create, _insert, select) = PowerDisplay();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = power_display_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "PvpDifficulty" => {
            let (_create, _insert, select) = PvpDifficulty();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = pvp_difficulty_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "QuestFactionReward" => {
            let (_create, _insert, select) = QuestFactionReward();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = quest_faction_reward_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "QuestInfo" => {
            let (_create, _insert, select) = QuestInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = quest_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "QuestSort" => {
            let (_create, _insert, select) = QuestSort();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = quest_sort_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "QuestXP" => {
            let (_create, _insert, select) = QuestXP();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = quest_xp_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "RandPropPoints" => {
            let (_create, _insert, select) = RandPropPoints();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = rand_prop_points_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Resistances" => {
            let (_create, _insert, select) = Resistances();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = resistances_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ScalingStatDistribution" => {
            let (_create, _insert, select) = ScalingStatDistribution();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = scaling_stat_distribution_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ScalingStatValues" => {
            let (_create, _insert, select) = ScalingStatValues();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = scaling_stat_values_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ScreenEffect" => {
            let (_create, _insert, select) = ScreenEffect();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = screen_effect_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ServerMessages" => {
            let (_create, _insert, select) = ServerMessages();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = server_messages_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SheatheSoundLookups" => {
            let (_create, _insert, select) = SheatheSoundLookups();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sheathe_sound_lookups_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillCostsData" => {
            let (_create, _insert, select) = SkillCostsData();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_costs_data_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillLine" => {
            let (_create, _insert, select) = SkillLine();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_line_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillLineAbility" => {
            let (_create, _insert, select) = SkillLineAbility();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_line_ability_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillLineCategory" => {
            let (_create, _insert, select) = SkillLineCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_line_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillRaceClassInfo" => {
            let (_create, _insert, select) = SkillRaceClassInfo();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_race_class_info_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SkillTiers" => {
            let (_create, _insert, select) = SkillTiers();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = skill_tiers_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundAmbience" => {
            let (_create, _insert, select) = SoundAmbience();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_ambience_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundEmitters" => {
            let (_create, _insert, select) = SoundEmitters();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_emitters_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundEntries" => {
            let (_create, _insert, select) = SoundEntries();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_entries_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundEntriesAdvanced" => {
            let (_create, _insert, select) = SoundEntriesAdvanced();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_entries_advanced_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundFilter" => {
            let (_create, _insert, select) = SoundFilter();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_filter_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundFilterElem" => {
            let (_create, _insert, select) = SoundFilterElem();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_filter_elem_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundProviderPreferences" => {
            let (_create, _insert, select) = SoundProviderPreferences();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_provider_preferences_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundSamplePreferences" => {
            let (_create, _insert, select) = SoundSamplePreferences();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_sample_preferences_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SoundWaterType" => {
            let (_create, _insert, select) = SoundWaterType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = sound_water_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpamMessages" => {
            let (_create, _insert, select) = SpamMessages();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spam_messages_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Spell" => {
            let (_create, _insert, select) = Spell();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellCastTimes" => {
            let (_create, _insert, select) = SpellCastTimes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_cast_times_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellCategory" => {
            let (_create, _insert, select) = SpellCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellChainEffects" => {
            let (_create, _insert, select) = SpellChainEffects();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_chain_effects_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellDescriptionVariables" => {
            let (_create, _insert, select) = SpellDescriptionVariables();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_description_variables_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellDifficulty" => {
            let (_create, _insert, select) = SpellDifficulty();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_difficulty_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellDispelType" => {
            let (_create, _insert, select) = SpellDispelType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_dispel_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellDuration" => {
            let (_create, _insert, select) = SpellDuration();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_duration_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellEffectCameraShakes" => {
            let (_create, _insert, select) = SpellEffectCameraShakes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_effect_camera_shakes_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellFocusObject" => {
            let (_create, _insert, select) = SpellFocusObject();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_focus_object_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellIcon" => {
            let (_create, _insert, select) = SpellIcon();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_icon_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellItemEnchantment" => {
            let (_create, _insert, select) = SpellItemEnchantment();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_item_enchantment_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellItemEnchantmentCondition" => {
            let (_create, _insert, select) = SpellItemEnchantmentCondition();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_item_enchantment_condition_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellMechanic" => {
            let (_create, _insert, select) = SpellMechanic();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_mechanic_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellMissile" => {
            let (_create, _insert, select) = SpellMissile();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_missile_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellMissileMotion" => {
            let (_create, _insert, select) = SpellMissileMotion();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_missile_motion_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellRadius" => {
            let (_create, _insert, select) = SpellRadius();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_radius_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellRange" => {
            let (_create, _insert, select) = SpellRange();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_range_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellRuneCost" => {
            let (_create, _insert, select) = SpellRuneCost();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_rune_cost_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellShapeshiftForm" => {
            let (_create, _insert, select) = SpellShapeshiftForm();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_shapeshift_form_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisual" => {
            let (_create, _insert, select) = SpellVisual();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisualEffectName" => {
            let (_create, _insert, select) = SpellVisualEffectName();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_effect_name_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisualKit" => {
            let (_create, _insert, select) = SpellVisualKit();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_kit_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisualKitAreaModel" => {
            let (_create, _insert, select) = SpellVisualKitAreaModel();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_kit_area_model_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisualKitModelAttach" => {
            let (_create, _insert, select) = SpellVisualKitModelAttach();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_kit_model_attach_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SpellVisualPrecastTransitions" => {
            let (_create, _insert, select) = SpellVisualPrecastTransitions();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = spell_visual_precast_transitions_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "StableSlotPrices" => {
            let (_create, _insert, select) = StableSlotPrices();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = stable_slot_prices_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Startup_Strings" => {
            let (_create, _insert, select) = Startup_Strings();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = startup_strings_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Stationery" => {
            let (_create, _insert, select) = Stationery();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = stationery_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "StringLookups" => {
            let (_create, _insert, select) = StringLookups();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = string_lookups_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "SummonProperties" => {
            let (_create, _insert, select) = SummonProperties();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = summon_properties_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Talent" => {
            let (_create, _insert, select) = Talent();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = talent_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TalentTab" => {
            let (_create, _insert, select) = TalentTab();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = talent_tab_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TaxiNodes" => {
            let (_create, _insert, select) = TaxiNodes();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = taxi_nodes_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TaxiPath" => {
            let (_create, _insert, select) = TaxiPath();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = taxi_path_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TaxiPathNode" => {
            let (_create, _insert, select) = TaxiPathNode();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = taxi_path_node_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TeamContributionPoints" => {
            let (_create, _insert, select) = TeamContributionPoints();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = team_contribution_points_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TerrainType" => {
            let (_create, _insert, select) = TerrainType();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = terrain_type_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TerrainTypeSounds" => {
            let (_create, _insert, select) = TerrainTypeSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = terrain_type_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TotemCategory" => {
            let (_create, _insert, select) = TotemCategory();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = totem_category_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TransportAnimation" => {
            let (_create, _insert, select) = TransportAnimation();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = transport_animation_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TransportPhysics" => {
            let (_create, _insert, select) = TransportPhysics();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = transport_physics_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "TransportRotation" => {
            let (_create, _insert, select) = TransportRotation();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = transport_rotation_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "UISoundLookups" => {
            let (_create, _insert, select) = UISoundLookups();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = ui_sound_lookups_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "UnitBlood" => {
            let (_create, _insert, select) = UnitBlood();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = unit_blood_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "UnitBloodLevels" => {
            let (_create, _insert, select) = UnitBloodLevels();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = unit_blood_levels_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Vehicle" => {
            let (_create, _insert, select) = Vehicle();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = vehicle_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "VehicleSeat" => {
            let (_create, _insert, select) = VehicleSeat();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = vehicle_seat_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "VehicleUIIndSeat" => {
            let (_create, _insert, select) = VehicleUIIndSeat();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = vehicle_ui_ind_seat_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "VehicleUIIndicator" => {
            let (_create, _insert, select) = VehicleUIIndicator();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = vehicle_ui_indicator_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "VideoHardware" => {
            let (_create, _insert, select) = VideoHardware();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = video_hardware_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "VocalUISounds" => {
            let (_create, _insert, select) = VocalUISounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = vocal_ui_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WMOAreaTable" => {
            let (_create, _insert, select) = WMOAreaTable();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = wmo_area_table_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WeaponImpactSounds" => {
            let (_create, _insert, select) = WeaponImpactSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = weapon_impact_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WeaponSwingSounds2" => {
            let (_create, _insert, select) = WeaponSwingSounds2();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = weapon_swing_sounds2_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "Weather" => {
            let (_create, _insert, select) = Weather();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = weather_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldChunkSounds" => {
            let (_create, _insert, select) = WorldChunkSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_chunk_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldMapArea" => {
            let (_create, _insert, select) = WorldMapArea();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_map_area_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldMapContinent" => {
            let (_create, _insert, select) = WorldMapContinent();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_map_continent_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldMapOverlay" => {
            let (_create, _insert, select) = WorldMapOverlay();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_map_overlay_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldMapTransforms" => {
            let (_create, _insert, select) = WorldMapTransforms();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_map_transforms_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldSafeLocs" => {
            let (_create, _insert, select) = WorldSafeLocs();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_safe_locs_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldStateUI" => {
            let (_create, _insert, select) = WorldStateUI();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_state_ui_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WorldStateZoneSounds" => {
            let (_create, _insert, select) = WorldStateZoneSounds();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = world_state_zone_sounds_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "WowError_Strings" => {
            let (_create, _insert, select) = WowError_Strings();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = wow_error_strings_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ZoneIntroMusicTable" => {
            let (_create, _insert, select) = ZoneIntroMusicTable();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = zone_intro_music_table_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "ZoneMusic" => {
            let (_create, _insert, select) = ZoneMusic();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = zone_music_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtBarberShopCostBase" => {
            let (_create, _insert, select) = gtBarberShopCostBase();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_barber_shop_cost_base_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtChanceToMeleeCrit" => {
            let (_create, _insert, select) = gtChanceToMeleeCrit();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_chance_to_melee_crit_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtChanceToMeleeCritBase" => {
            let (_create, _insert, select) = gtChanceToMeleeCritBase();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_chance_to_melee_crit_base_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtChanceToSpellCrit" => {
            let (_create, _insert, select) = gtChanceToSpellCrit();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_chance_to_spell_crit_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtChanceToSpellCritBase" => {
            let (_create, _insert, select) = gtChanceToSpellCritBase();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_chance_to_spell_crit_base_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtCombatRatings" => {
            let (_create, _insert, select) = gtCombatRatings();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_combat_ratings_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtNPCManaCostScaler" => {
            let (_create, _insert, select) = gtNPCManaCostScaler();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_npc_mana_cost_scaler_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtOCTClassCombatRatingScalar" => {
            let (_create, _insert, select) = gtOCTClassCombatRatingScalar();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_oct_class_combat_rating_scalar_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtOCTRegenHP" => {
            let (_create, _insert, select) = gtOCTRegenHP();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_oct_regen_hp_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtOCTRegenMP" => {
            let (_create, _insert, select) = gtOCTRegenMP();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_oct_regen_mp_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtRegenHPPerSpt" => {
            let (_create, _insert, select) = gtRegenHPPerSpt();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_regen_hp_per_spt_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        "gtRegenMPPerSpt" => {
            let (_create, _insert, select) = gtRegenMPPerSpt();
            let mut stmt = conn.prepare(select)?;
            let mut rows = stmt.query([])?;
            let data = gt_regen_mp_per_spt_from_rows(&mut rows)?;
            data.write(&mut writer).map_err(|e| SqliteError::DbcError(wow_dbc::DbcError::Io(e)))?;
            Ok(())
        }
        _ => Err(SqliteError::FilenameNotFound { name: name.to_string() }),
    }
}

